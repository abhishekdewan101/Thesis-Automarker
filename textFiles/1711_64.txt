September 2012 CSMSC-12
DEPARTMENT OF COMPUTER SCIENCE
A dissertation submitted to the University of Bristol in accordance with the requirements
of the degree of Master of Science in the Faculty of Engineering
Separation between Games and UC
for the case of Key Exchange Protocols
Shailesh Prakash


A B S T R A C T
In this paper we have investigated the relationship between two standard
security models: Cryptographic games and Simulation based models. The
obtained result is new and previously unexplored in the context of key
exchange protocol. This is by pointing out inability to simulate specific cor-
ruption scheme in presence of adaptive adversary in the simulation based
security model. The results we found here provide the basic step to form
the relationship between these two models. Notion of both the security
models are not new but unfortunately the relationship is not fully un-
derstood. In general, cryptographers believe that simulation-based model
provides stronger security guarantee than cryptographic games. To under-
stand this problem, we model security guarantee of key exchange protocol
in both the models. As our aim is to compare these two security models
instead of providing security guarantee of actual protocol, we proposed a
new and simple to construct but sufficiently secure key exchange protocol,
KE(ENC,SIG). The protocol is based on two fundamental public key crypto-
graphic primitive, encryption and signature, to provide secrecy and authen-
ticity respectively. We used classical Bellare-Rogaway model (BR model) for
cryptographic games technique. For the simulation-based model, popular
Canetti’s Universal Compose-able framework has been used. As a main re-
sult, KE(ENC,SIG) is found secure for BR model in presence of the adaptive
adversary. On the other hand UC model declare the same protocol unse-
cure under same adversarial entity. The security analysis focuses on key
exchange and assumed long-term keys are pre-established and public keys
are verifiable with protocol user’s identities within the system. Our results
are based on previous work done by Nielsen for the non-committing en-
cryption to show separation between complexity theory and random oracle
models. The reason for failure in UC framework security modeling is due
to a fundamental issue of simulation in presence of adaptive adversary. The
issue arises due to asynchronous communication channels and inability to
simulate the real protocol corruption by just knowing the length of the
transmitted message in a feasible computational system. The result draws a
clear line of separation between two cryptographic security models and the
wider formal conjunctures from earlier believe of a stronger modelling ap-
proach by simulations. Simulation based models provide nice modular se-
curity definitions for complex cryptosystems. Cryptographic games should
not be ditched for the simulation based modeling technique just because of
sophistication in the security definitions. One should first understand the
relationship between the two.
v


C O N T E N T S
1 introduction 1
1.1 Related work 4
2 background 5
2.1 Key exchange protocols 5
2.2 Security Models 8
2.2.1 Adversary in Security Model 8
2.2.2 Adaptive Corruption in a protocol 8
2.2.3 Cryptographic Games 8
2.2.4 Universal Composable Framework 9
3 security models for key exchange 13
3.1 Cryptographic Games: Bellare-Rogaway Model 13
3.1.1 The Model 14
3.1.2 Mutual Authentication 14
3.2 Simulations: UC based Model 16
3.2.1 Joint State in UC 17
4 security analysis of ke(enc ,sig) 21
4.1 BR Secure Game 22
4.2 UC Security 26
4.2.1 K?E: KE with JUC side/effect 26
5 evaluation 29
5.1 Main Results 29
5.2 Moving Relationship to Separation 31
6 conclusion 35
6.1 Possible Future Work 35
a appendix 37
a.1 Random Oracle Model 37
a.2 Probability ofB guesses test session correctly 37
bibliography 39
ix
L I S T O F F I G U R E S
Figure 1 Communication between two parties in
key exchange 5
Figure 2 Abstract model to run Games for secu-
rity 9
Figure 3 Simulation based security model with re-
al/random execution of pi with E 9
Figure 4 Game execution state for protocol pi 15
Figure 5 Adversarial query model for protocol pi 16
Figure 6 Handling multiple session of piwith/with-
out joint state 18
Figure 7 Protocol KE(ENC,SIG) 21
Figure 8 Proof model for B breaks encryption if A
breaks protocol 23
Figure 9 Execution model for UC Framework 26
L I S T O F A L G O R I T H M S
Figure 1 FKE(ENC,SIG) 17
Figure 2 Corrupt(corrupted{0,1}, message, adv, user,
env) 19
Figure 3 Initialization(1?) 24
Figure 4 LeftoRightGame(m0, m1) 24
Figure 5 Dec(C?) 24
x
L I S T O F S Y M B O L S
pi real protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
Pi Party: Initiator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Pj Party: Responder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
A Party: Initiator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
B Party: Responder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .21
C Party: Suspicious . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
A Adversary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
B Adversary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
C Adversary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
S Simulator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
E Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .26
F Ideal Functionality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
A C R O N Y M S
itm Interactive Turing Machine
ppt Probabilistic Polynomial Time
cdh Computational Diffie-Hellman
uc Universal Composability
juc Universal Composability with Joint state
pki Public key Infrastructure
ke Key Exchange
xi

1
I N T R O D U C T I O N
Context. Cryptographic tasks protect valuable information and
hence security guarantee of such task become really vital. In
distributed environment like internet, an attacker can control
the network to manipulate transmitted data and may also ex-
tract extra information which is not known by just reading
the transmitting line. Intuitively, designers uses "design-then-
break" paradigm to provide security to a system. In this ap-
proach, the system is considered to be secure till someone finds
an error in the security. Then it is at risk till someone (else)
can find a fix. The system enjoys it’s security till the next cy-
cle of finding loop holes in security. Alternatively, model based
approach is a formal way to define security by using mathe-
matical abstractions of the system. In this approach the system
is considered as an algorithm, which is made of known secu-
rity primitive. RSA problem is a good example for it, which is
based on finding factorization of really large numbers render-
ing it hard. In a nutshell, the key exchange protocol is a cryp-
tographic tool, which allows two or more entities to exchange
common secret key over the public channel. The goal of the se-
curity is to keep this key secret from others. The security model
should allow this task by considering real and practical intrud-
ers to show any weakness or variability in the protocol. Bel-
lare and Rogaway[BR94]] showed how game based model can
be used for symmetric, two party setup. In simulation-based
model, security is defined by comparing protocols with adver-
sary to similar ideal process adversary with a trusted third party,
an ideal functionality.
Motivation. Modelling security of any cryptographic task with
proveable way is not new. Still, two standard security models
lack a formal relationship. Recently, Canetti proposed a simu-
lation based model, Universal composeable framework[Can01].
This framework gaining popularity over standard way of mod-
eling security, Cryptographic games. Basic advantage with UC
is a modular approach to analyse security. Later, there are sev-
eral changes and extensions were proposed to the original UC
framework, as it was unable to model security guarantee for ex-
isting practical tasks. The framework is very promising while
defining security to a new protocol. On the other hand crypto-
graphic games providing good security guarantee for existing
and new protocols. The dilemma of "which one is better" needs
1
2 introduction
to be investigated to get some conclusion.
Aims & Objectives. We are aiming to get implication and sepa-
ration between two standard security models for key exchange
pro-tocols. Forming relationship between security notions is
not a trivial task. Symmetric cryptosystems like encryption, pseu-
dorandom functions have a formal relationship for semantic se-
curity among each other but as system or corruption scheme be-
come more complex these starts lacking formalism. To achieve
the aim, tasks are as follows,
1. Model security for key exchange protocol, pi in game base
and simulation based framework considering an adap-
tive adversary and show corruption scheme for long term
keys.
2. Construct ideal functionality FKE for key exchange in Universal
Composability (UC) framework.
3. Patch protocol pi in UC for joint state to construct ˜.1
4. Prove or disprove protocol pi is game base secure but can
not be shown UC secure.
We had decided to find or come up with a protocol that should
be simple to analyse, allow practical corruptions and realistic
conclusion about models can be obtained by modelling it. We
finally proposed a new protocol KE(ENC,SIG) for exchanging
keys. The new results from this work will allow research com-
munity to explore and establish relationship in other areas of
secure communication and further to find a design pattern for
such technique. We are focusing our work to a practical task,
a protocol that is in daily practice over the internet. We deal
with strong security threat, adaptive corruption for this anal-
ysis with key-exchange protocol. It is interesting to model se-
curity for such a widely used protocol under practical security
threat.
The Process. We have presented a detail overview for game
based model. First we took up standard definition of Bellare
and Rogaway model but we needed to modify it a bit. Accord-
ing to original definition the attacker can test the real or random
value at the end. We felt it restrictive for adaptive adversary. In
our definition we allow attacker to make this query in between
and continue playing the game till he reveal all but two ses-
sions, session he wants to test and it’s partner session 3.3 or
1 protocol needs to be modified for the case of long-term key as joint state in
universal composition theorem.
introduction 3
the corruption of parties which runs these two sessions. Then
we used reduction to get the final conclusion of protocols secu-
rity in Games. Universal composable framework is too vast to
discuss in detail in this report. We have enlighten the main at-
tacked and key difference which are worth to explore without
loosing any pace with the analysis. We provided a conjecture
regarding the impossibility of proving the security of the pro-
tocol with informal explain why thus is the case, before taking
final results.
Our Results.
1. Proposed key exchange protocol KE(ENC,SIG) 4 is BR
Secure[BR94] but not UC Secure[Can01] in presence of
adaptive adversary.
2. To improve efficiency and modularity Universal Compos-
ability with Joint state (JUC) theorem[CR03] patch needed
to be added in universally composable theorem proposed
by Canetti[Can01]. This modification provides security guar-
antee to a bit changed protocol than we analyse in first
place.
3. Proving security by nesting more game is harder to for-
malise than proving a single game by reduction.
4. we got stronger result in games than we were hoping for.
The results shows the adaptive adversary cannot guess
key for any fresh session with matching conversation (we
required it for only one test session, St).
Organisation. The paper provides initial sketch of the work
in this chapter which is followed by detailed discussion about
key exchange & universal composable framework in the next
chapter. In Section 2.1 key exchange protocol and it’s security
requirements are analyzed. We provide enough examples and
informally discuss security loopholes before beginning with ac-
tual security modeling. Section 2.2 tells more about security
models and adversaries. We outline UC framework by [Can01]
and an example of idealised functionality to provide a clear
idea about this sophisticated security model for subsequent
Chapter 3 where we construct the model for proposed key ex-
change protocol along with Games. In Section 3.2 we introduce
Joint State and it’s treatment to multiple sessions share long-
term key to actively use this advance topic in key exchange. In
Chapter 4 we get all our results by providing formal proof of
KE(ENC,SIG) in Games and discussed insecurity in UC model
due to long-term key corruption. The Chapter 5 states direct
results and then critically analyses and evaluates the work we
4 introduction
have carried so far. This includes the KE(ENC,SIG) and both
the security models. We sum up all our work in Chapter 6 and
discuss few open problems on the same path. We put some
interesting and optional work in Appendix A. This includes de-
tails of Random oracle model which explains basis of idealised
cryptographic functions. Later, we put a weak independent re-
sult with adaptive and non-adaptive adversary found in game
based model.
1.1 related work
The closest to our work is done by Nielsen[Nie02], show-
ing separation results for non committing encryption between
complexity theory and random oracle model. The results show
possibility of adaptive adversary secure protocol for a non com-
mitting encryption is either by generating arbitrarily large keys
(w.r.t. size of the message) or programmable random oracle.
Our work uses this result but key exchange is way different
form public key encryption scheme. Work done by Canetti &
Krawczyk[CK02] shows a relation between cryptographic games
(SK security) section ?? and simulation based model (UC frame-
work) for key exchange protocol composed with secure chan-
nel but the work is done for non-adaptive adversary. They have
shown a strong relation between SK secure game and relaxed
UC secure model. Which is opposite to our result of separation
with adaptive adversary. The negative results do not contradict
their work but it stops to generalise the relationship further.
2
B A C K G R O U N D
2.1 key exchange protocols
Key exchange is the process by which parties, called as enti-
ties, distribute keys to use it later for other cryptographic tasks
like building secure channel for message transmission. One of
the security challenges is to partner with correct entity as they
can be remotely distributed over network like internet where
the communication channel is not secure. The second problem
is to maintain the secrecy of the key to be exchanged and it
should be transmitted from an initiator to a receiver correctly &
untempered over the distributed network. In this protocol, par-
ties generate a short-term key, termed as Session Key, derived
from a secret key for the exchange. This secret key is called as
long-term key.
A B
SK
SK
Symmetric Encryption
SK
Figure 1: Communication between two parties in key exchange
The above approach improves security of the protocol, as
only session keys are transmitted over the network and on com-
promise it can be freshly regenerated. But this improvement
adds complexity in the protocol and hence scope of security
problems also increases. By analyzing session keys one should
not guess the long-term key and also if the long-term keys of
small set of parties were exposed, it should not effect the over-
all security of the protocol. Moreover, the security definition
should capture real world characteristics of current problems
and efficiently usable for practice. There are different ways to
exchange keys, two or more parties may distribute keys in a
protocol. Even the distributed keys may be asymmetric or par-
ties may agree on a shared symmetric key. In this paper, we
consider two parties that want to exchange a symmetric secret
key and the protocol is in a Public key Infrastructure (PKI) set-
tings i.e.; if any cryptographic algorithm uses asymmetric keys
5
6 background
in the protocol, public key of entities are verified and bonded
correctly and we do not need to provide security guarantee for
it along with the protocol.
Definition 2.1 Key Exchange protocol is a key transport mechanism
to distribute keys among parties. This distribution may or may not
include pre-established long live key. All parties may or may not con-
tribute in key agreement.
Communication in KE. A protocol run consists of communica-
tion flows between parties before agreed on a final key. Each
flow is discrete in time and upon finish of one flow success-
fully, next stage starts except the final stage where protocol ter-
minates. A complete one round of communication for a party
is called as Round and maximum rounds for any of the party
(A or B) is defines the rounds of given protocol. For any stage,
party that send last message is called as Owner of the proto-
col till protocol moves to the next stage or it ends. Protocol is
said to be finished successfully when the last message reaches
to the other party. Parties which initiate the communication are
termed as an Initiator and parties which receive first message
sent by initiator are termed as responder. Any party can be
an initiator, a responder or both. One set of communication is
called as a session, which party runs locally as their part of the
protocol . Parties can run multiple sessions to same or different
party. Even a party can run the protocol to itself being an initia-
tor and responder of that session.
KE in action. We present examples based on symmetric key
and Diffie-Hellman key exchanged protocol. We also enquire
security concerns related to these protocols. Protocols rely on
some mathematical assumption made by the primitive crypto-
graphic algorithm. Hardness of Computational Diffie-Hellman
(CDH) or cipher text looks like random output (for encryption)
is the basis of following examples,
1. One pass key transport[MvOV96]:A point-to-point key up-
date process, depends on symmetric encryption for secure
key transport.
A ? B : Ekey(RA) (1)
The protocol derives session key, S based on a priori shared
long-term symmetric key K between parties A and B. To
maintain freshness optional time-stamp/sequence num-
ber can be sent to B. A redundant data, B will detect any
modification in data if sent along with RA. Session key
will remain same, S = RA
A ? B : Ekey(RA, ti,B) (1?)
2.1 key exchange protocols 7
2. challenge-response[MvOV96]:
A ? B : NB (1)
A ? B : Ekey(RA,NB,B?) (2)
Dependency on time-stamp is not reliable for freshness
but one can use a monotonic random number, nonce se-
quence to provide freshness. RA is the derived session key,
S = RA.
If both the parties want to add a share in derived key, a
random key RB can be used in the same setup.
A ? B : NB (1)
A ? B : Ekey(RA,NA,NB,B) (2)
A ? B : Ekey(RB,NB,NA,A) (3)
This 3-step protocol provides authenticated key exchanged
based on symmetric encryption scheme E. session key S
= (RA,RB)
3. Diffie-Hellman key exchange[MvOV96]:
one time distribution of an appropriate prime q & a gen-
erator g of Z(2 6 g 6 q? 2)
A ? B : ga mod q (... certA) (1)
A ? B : gb mod q (... certB) (2)
1 6 a,b 6 q? 2
Both A & B computes session key S = ga.b mod q
Protocol’s security relies on CDH assumption and expo-
nentiation provides a trapdore1. It removes the depen-
dency to pre-establish long term keys. The problem is
with authentication in this key exchange protocol.
TEST. Let’s assume C controls the network and able to
modify the message. Consider C as CB when it imperson-
ate B to A and the same for B with CB and C chooses c as
1 6 c 6 q? 2
A ? CB : ga mod q (1)
CA ? B : gc mod q (1?)
CA ? B : gb mod q (2)
A ? CB : gc mod q (2?)
After protocol execution, both parties A and B will have
key exchanged with C, SAC = ga.c mod q & SBC = gb.c
mod q respectively. C can maintain this setup to get all
transmitted data between A & B if SAC & SBC been used
for later cryptographic tasks.
These security tests can be written as mathematical algorithms.
The test relies on previously defined secure primitive and if the
protocol does not leak any extra information during it’s execu-
1 The CDH assumption is based on discreet logarithmic problem, it’s hard to
mathematically calculate logarithm of value base g (generator).
8 background
tion then it should remain secure as well. Last example vaguely
explains power of external entity C, which impersonates the ac-
tual user and breaks the security of protocol. C does not brake
any rules of the protocol hence we can say that the protocol is
not secure if someone other than A and B can alter the channel
of communication. Now the protocol must be updated to al-
low such kind of corruption if communication channel remains
public & controllable by C and parties A & B still wants to do
secure key exchange.
2.2 security models
2.2.1 Adversary in Security Model
Now we define an adversary and classify it based on power
given to it in a security model. Adversary is a polynomial time
running machine with a goal to break the security of given cryp-
tographic task. The system defines its power. When an eaves-
dropper can listen to the communication between parties and
try to gets information based on it, we call it passive adversary.
A more realistic adversary get control of the network and de-
cides whether to read, alter, block or inject the on-going com-
munication is active adversary. Another type of classification is
depending on when to corrupt the parties to get the secret infor-
mation. A static adversary can corrupt parties in the beginning
of the protocol run while adaptive adversary can corrupt parties
on the fly.
2.2.2 Adaptive Corruption in a protocol
An Adaptive Adversary is a type of adversary who can
corrupt parties on the fly. This gives the adversary power to
analyse previous communication if he can eavesdrops the com-
munication for some extra information which is not known in
general. By using this s¨ome extraïnformation it can choose the
next party to corrupt for the final task breaking the protocol
itself.
2.2.3 Cryptographic Games
Definition 2.2 Cryptographic Games is a PPM ITM 2 which accepts
query q from a finite set of predefined queries Q and return responses
to the output tape. In between the game progress, a special query Test
2 PPM ITM is deterministic turing machine with an added random tape
which interacts with I/O tapes on-line.
2.2 security models 9
can be fired to result the game play. The game overs when player
returns back with the guess query. The event of occurrence of guess
query strictly later than the test query.
A
queries
answers
Security Game
for
Cryptographic Task Game O/P
{0, 1}
b
Figure 2: Abstract model to run Games for security
Henceforth we call cryptographic games as Game in general. It
interacts with the adversary, A as a player to proceed with the
game, eventually it allows A to guess the internal game bit b
and A win/lose the game on his guess.
2.2.4 Universal Composable Framework
Simulations. Simulation based security model is based on re-
al/ideal model and any external adversarial entity, environ-
ment try to distinguish between these two execution. The sys-
tem is considered to be secure if environment cannot tell the
difference by looking at global output of these two models.
E
pi piideal
A
B
C
A
B
C
A
S
Figure 3: Simulation based security model with real/random execu-
tion of pi with E
Universal Composition framework is a simulation based secu-
rity framework. It addresses security issues of a cryptographic
protocol by making no assumption of other protocols in the
10 background
system. Those can be independent or concurrent executions of
same or different protocol instances in that system. Even it al-
lows protocol to compose with other unknown/dynamic com-
ponents in the system. These components can be unknown at
the time of analysis. Informally, in UC framework[Can01], real
adversary A is emulated in ideal world by a simulator S and
parties PI interact according to the protocol by giving their in-
put and taking output without any external interaction with
the trusted third party, idealised functionality. This is mimic by
an algorithm in ideal world, called as ideal functionality F in
context of UC. Here i is identifier of each party for particular
execution of the protocol instance. All operations are held in
the presence of an entity termed as environment, E which acts
as communicator. A controls the communication channel and
corrupt real PI. E gives inputs to all parties, reads back result
and communicates with S. The protocol is considered to be se-
cure if A interacts with real parties and S interacts with F in
this above setup such that the E can not distinguish between
the two executions interactively.
Definition 2.3 [Can01] Universal Composable Framework con-
sists of ({Pi}{1,..,n},A, {Fid}{1,..,m}, S,E) over three main components
real-model, ideal process and any outside world adversarial entity, to
define security guarantee of any protocol pi in any arbitrary system.
The tuples of framework are defined as follows,
• {Pi}{1,..,n}, where n ? N of ITMs may run as parties of a
protocol in real-model. n is predefined and N is a finite
number in polynomial size of security parameter.
• A is an adversarial ITM who tries to break the protocol in
real-model.
• {Fid}{1,..,m} is instances of ideal functionality of the given
protocol pi which is conceptually incorruptible & m ? M.
M is a finite number in polynomial size of security param-
eter. Informally, ideal functionality is a trusted third party
who runs the security primitive and interacts with parties
via some secure channel.
• S is an ITM, which tries to mimic the A by interacting
with F to get information as per security definition.
• E is an adversarial decision making ITM which tries to
"distinguish interactively" the real execution from ideal
process. E interacts with all party and adversaries. In ideal
world, due to secure channel between parties and trusted
2.2 security models 11
third party, its acts as a dummy party which bypass mes-
sages between E and F. The framework also imposes on-
line interaction only for adversaries to E to stop rewinding
of I/O tapes of TM.
Theorem 2.4 [Can01] A protocol pi realizes a functionality f securely
if for any real-life adversary A there exist an ideal process simulator S
such that the execution of real-life pi with A is indistinguishable with
running of the idealised model with simulator S by seeing the global
output of these two models.
The definition here is informal for clarity and brevity, mostly
referred from the Overview section of Canetti paper[c01]. See
there for full details.
Intuitively, this looks a strong security definition as it does
not care about the system and other concurrent task running
with the protocol . The notion of the security somewhat resem-
bles with the definition of Session-Key(SK) security ??. In SK-
security two games UM (unauthenticated model) and AM (au-
thenticated model) used to provide security by indistinguisha-
bility. Original protocol runs in AM and a protocol emulates the
original in UM. To test "difference by a outside observer an au-
thenticator provides description of emulated protocol. But def-
inition provided by UC is strictly stronger than SK security as
it does not put any condition on the distinguisher. The formal
definition of SK-security and relationship with UC is defined
in [CK02].

3
S E C U R I T Y M O D E L S F O R K E Y E X C H A N G E
Considering a two party protocol, we can fix an integer n of
size polynomial in the security parameter, k. The parties are
identified by some integer i, with 0 6 i 6 n. Let parties run an
algorithm, ? locally to compute session key as output There is
no guaranty of identifying sessions uniquely. Parties list down
the local session identifiers lsid ? Z x Z x Z x B is defined.
lsid = (i,j,k,b) refers kth session between parties i and j and if
binary value b is set j is the session initiator else i initiates the
session. In this two party protocol what we want is for the in-
volved parties exclusively compute a session key and it should
be independent of other similar communication.
Definition 3.1 [BFWW11] Key exchange protocol is a pair of cryp-
tographic algorithms (Kg, ?) where Kg is a randomization algorithm
which generates keys in some key space based on input security pa-
rameter k. ? is the algorithm which parties run locally as their part in
the protocol execution.
3.1 cryptographic games : bellare-rogaway model
Definition 3.2 [BR94] Two parties Pi & Pj are said to be in Match-
ing Conversation if,
• Initiate one session each locally.
• Asynchronously send /receive message in order to agreed proto-
col in that session.
• Last message reaches successfully to the other party.
Where i, j ? {1, n}.
Definition 3.3 Two instance A & B of the protocol pi is Partner
Sessions if,
• A & B are in Matching Conversation during session instances
pi(A,B,b) & pi(C,D,b?) respectively.
• Instances pi(A,B,b) & pi(C,D,b?) computes same session key, K
as output.
• K is independently generated with respect to similar communi-
cation with other instances. Where A = D, B = C & b? = b = 1
- b.
13
14 security models for key exchange
3.1.1 The Model
Now we model the protocol based on the technique pro-
posed by Bellare and Rogaway (BR Model).[BR94] Our model
fulfils the demands of their notion as session can be created on
the fly like real scenario and two local parties exchange session
key using matching conversation in the protocol .
To SETUP the game for adversary, first party states are al-
located and initialized. All parities pi to pn are initialized as
honest parties by unset ?? bit of their state. Asymmetric keys
for encryption and signing and verification key for signature
are generated by Kg(?) for each party. An empty set to con-
tain lsid is also associated with all the parties . The predicate
bit b is set to 0. To validate queries before execute, an algo-
rithm Valid checks validity of arguments. In this setup we take
query request from A in serial manner. The Game will accept
queries from input tape and to maintain atomic progress, a tri-
state variable, e ? {accept, running, reject} tracks game running
state.
3.1.2 Mutual Authentication
Definition 3.4 pi is a secure key exchange protocol with any polyno-
mial time adversary A,
1. if oracle pisA,B & pi
t
B,A and having matching conversation and
only both of these accept same session key.1
2. There is negligible probability of acceptance of a non-matching
conversation by both the parties .
3. There is negligible probability gaining extra information about
session key. e.i; there exists a negligible function negl(k) in the
security parameter k such that
AdvpiE 6 negl(k)
To model the above protocol in the Game, we need to define
extra state information which may not be a part of the proto-
col but required to run the game deterministically. Game state
consists,
1. A predicate bit, b to store response to Test query.
2. A tri-state variable, e to tell game running state.
3. A set of identifier for parties which can be initiator or
responder.
1 pisA,B,b : party A runs a session s with party B.
3.1 cryptographic games : bellare-rogaway model 15
SkVk
PkSik
lsid1.....lsidm
b
p1.....pn
SkVk
PkSik
??
Game
??
lsid1.....lsidm?
Party
Session
e
?, ?st
sid, k
?, ?, ?st
sid, k
?,?, ?st
sid, k
?,?, ?st
sid, k
?,RA,RB RA,RB RA,RB RA,RB
Figure 4: Game execution state for protocol pi
4. Collections of Party’s state mapped with each of the above
identifier. The arrow in above
figure denotes
input/ output tapes
with arrow
direction to the
game-box. The
internal arc arrow
denotes random
tape.
5. Party state consists long term keys for encryption and sig-
nature, a bit ?? to identify if these keys are corrupted or
not and a dynamic set of lsid.
6. Collection of session’s state mapped with each of above
lsid. Each element contains session id, sid and two bit,
? & ?? to keep track of "Reveal query" for this session
& partner session respectively. While ? ? {uninitialized,
negotiation, derived} is to check if session is not begun
yet or still under negotiation or completed. Any random
nonce generated for the session or partner’s nonce to be
use for generating signature is also stored in this state.
7. An additional collection to map sid to lsid for fast lookup
of local session state.
To identify party, instead of using Pi, we will use alphabets
like A,B,C for better understanding. The state associated with a
party is it’s long-term keys which is set at the beginning of the
game run. Any Kth session run by a party is identified by lsid
of that session.
Here is the full list of queries, Q that A can fire to the game.
1. New(A, B, i): Ask to start a new session for party A and
B where A is initiator if i=0 else A is responder.
16 security models for key exchange
2. Send(sid, M, U): Sends a message M to party U in session
sid.
3. Reveal(sid): Reveals the session key if it finishes the deriva-
tion for both parties for any session with identifier sid.
4. Corrupt(U): Corrupt a part U by giving secret key pair of
ENC and SIG.
5. Test(ST ): Test for winning of the adversary with two un-
corrupted parties involved in the derived session key of
session ST .
A
New
(A, B
,i)
send (si
d,U,M)
Currupt(U)
Reveal(sid)
Test(
ST )
partiesA B
A, B, i B,A, jsessions
Si Sj
Figure 5: Adversarial query model for protocol pi
Winning of adversary is decided by key indistinguishability.
The game allows it via Test query and result is compared by
Guess query, as follows
1. A issues a Test query for a session, ST .
2. The ST or its partner session, defined through matching
conversation is not corrupted by the adversary.
3. The parties running these sessions are also not corrupted
ie; long-term keys are not revealed for both the parties.
4. A fair coin is flipped and it is assigned to b. depending
on b, it sends response as session key or random key.
5. The adversary fires Guess query with bit b?. If b? = b, A
win else A loss.
3.2 simulations : uc based model
Real protocol execution progress same as per the protocol rules.
The real-world adversary A interacts with the execution look-
ing for any security problems. To model Ideal world execution
we need to define Ideal Functionality of KE(ENC,SIG) first. Let
parties P1, ....,Pn and idealised process adversary S running on
security parameter k.
3.2 simulations : uc based model 17
Algorithm 1 FKE(ENC,SIG)
[CK02]
Wait to receive a value (exchange,sid,Pi,Pj,b) from some
party Pi
Wait to receive a value (exchange,sid,Pj,Pi,b?) from party Pj.
if b = b? = ? then
choose K R?? {0, 1}?
else
if b 6= ? then
set k = b;
elsek = b?
Send (key,id,k) to Pi
Send (key,id,k) to Pj
Notify S return
3.2.1 Joint State in UC
Canetti & Rabin [CR03], extended the scope of [Can01], as
the proposed framework is not suitable for existing protocols.
Different Protocols may share common security primitive such
as common secret key within a system and can not be analyzed
efficiently in isolation. The extension allows composition of pro-
tocols if they share some amount of common secret or in gen-
erality some state called as JUC(composition operation with joint
state). The new proposed composition operation, JUC claims to
preserve security irrespective of whether different components
have some amount of joint state and joint randomness. It could
be useful in practice as for example, some protocols use Public
Key Infrastructure. JUC can provide security guarantee in such
scenarios. Informally, system consists of pi (high level protocol)
and ? (sub-protocol) as multiple instances with some joint state.
JUC theorem states that, we can construct a protocol ?ˆ, which
functionally behaves same as multiple copies of ?. To provide
security framework for such protocols, pi and ? runs same as
in UC then replaces all instances of ? with single instance of
?ˆ. Now we can execute the protocol pi with ?ˆ in environment
E as of multiple ? for JUC operation. The ideal functionality is
modified to do joint state operation and stated as F-hybrid. This
is by adding an additional sub-session identifier, ssid to the
Fsid to make it F{sid,ssid}. While the newly added ssid is locally
unique within a party. This construction improves efficiency sig-
nificantly as only single copy of F with joint state will replace
multiple instances of previous F. For example multi-session
protocol no longer needs to get exclusive copy of ideal function-
ality for each session of a party, these can share a single F. JUC
18 security models for key exchange
gives security definition in F-hybrid maodel which is nothing
but real model and parties has access to idealised functionality,
F same as dummy parties. Long-term key corruption. Corruption
FKE{sid,ssid3}
E
FKEsid1 FKEsid2
FKEsid3
E
FKE{sid,ssid1}
FKE{sid,ssid2}
(a). With Joint State
(b). Without Joint State
Figure 6: Handling multiple session of pi with/without joint state
of idealised functionality is not very precisely specified in the
UC model. We are using a macro which can plug to the ideal
functionality to provide long-term key corruption for adaptive
adversary. This approach is similar to the work of [KT08]. In
their work a generalised macro is written for non-adaptive and
adaptive adversary. While we have specifically done it for adap-
tive adversary.
long-term corruption scheme for KE(ENC,SIG)
• E can check for the corruption state.
• A can corrupt an uncorrupted party. On corruption, all
further communication with other parties will be send to
A
• Other parties can communicate to the corrupted party in
the protocol.
3.2 simulations : uc based model 19
Algorithm 2 Corrupt(corrupted{0,1}, message, adv, user, env)
Require: initialised
Ensure: len = 0
Ensure: Listuser 6= ?
if recv(IsCorrupted) from env then
send(corrupted) to env
if recv(corrupt) from adv and ¬corrupted then
corrupted? true
send(corrupted, message) to adv
if corrupted and recv(send, msg, user) from adv then
assert user ? Listuser
assert 0 < |msg| 6 len
result? 0
send msg to user
if corrupted and recv(msg) from user then
assert user ? Listuser
result? 0
send(Recv, msg, user)
if corrupted and recv(Recv, r) from env then
send(Recv, r) to adv
len? |r|

4
S E C U R I T Y A N A LY S I S O F K E ( E N C , S I G )
KE(ENC,SIG) is a secure key exchange protocol with par-
ties pi where 0 < i 6 n. To provide secure communication it
uses security primitive such as Encryption & Signature. Parties
locally run ? to evaluate session key. It uses public-key signa-
ture, SIG(1?,Sik,Vk) and asymmetric encryption, ENC(1?,Sk,Pk)
to provide authentication and secrecy respectively but we need
to show the overall protocol is also secure if and only if the
security primitive is secure enough1. Key pairs (Ski, Pki), (Siki,
Vki) are used as encryption keys and signature keys respec-
tively for any party pi and generated by the key generation al-
gorithm. Certificate Authority is a trusted third party which
Initiator A Responder B
Choose a nonce
NA ? {0, 1}?.
Send A,NA
Choose a nonce
NB ? {0, 1}?.
Send B,NB
1. Calculate signature of
(A,NA,B,NB)
2. Select a session key, K
3. Encrypt message, 1&2
{SIGSikA(A,NA,B,NB), K}
Send
ENCPkB{SIGNSikA(A,NA,B,NB), K}
decrypt message
& verify signature
Figure 7: Protocol KE(ENC,SIG)
generates certi for each party, Pi. This provides a mechanism
of binding long-term state information to any party. Basically,
it prevents two honest user to acquire same Pi and prevent ad-
versary to fake any party’s identification. For example, internet
1 Pr[breaking of algorithm]6 f(n) + negl. Where f(n) is fair chance of predicate
to be unsecured, possibly zero in most cases
21
22 security analysis of ke(enc ,sig)
uses email id and other physical details of registered domain
to provide SSL certificate. The enforcement and binding is not
part of our proof so we do not consider these for our security
model.
Definition 4.1 Protocol KE(ENC,SIG) is a key exchange protocol if
it satisfies following conditions:
• Kg output quadruple of keys in pair (Sk, Pk) & (Sik, Vk) for all
parties pi where 0 < i 6 n.
• Any instance of ? outputs n-bit string, session key on success-
fully finishing the protocol steps. Otherwise a special fail sym-
bol, ? is output by the instance.
• Two instance of protocol n1 & n2 are Partner Session and
produces keys S1 & S2 locally such as;
S1 = ?(1n, P1, Sik1, P2, Pk2, k, b)
S2 = ?(1n, P2, Sk2, P1, Vk1, k?, b)
S1 = S2
Lets assume parties run algorithm pi in protocol KE(ENC,SIG)
and two parties A and B have keys (SkA, PkA), (SikA, VkA) &
(SkB, PkB), (SikB, VkB) respectively. As a shorthand an instance
can be represented as pi(A,B,ki,b). The last instance between par-
ties A & B is represented by pi(A,B,b).2 At the end of execution
both of them will have session key, Ki as an output.
4.1 br secure game
Theorem 4.2 If ENC is IND-CCA secure and SIG is UF-CMA se-
cure then KE(ENC, SIG) is a secure key exchange protocol in the
presence of an adaptive adversary, A.
Lemma 4.3 If SIG is UF-CMA secure then at most one session ac-
cepts signature of message, {A,NA,B,NB} in the protocol in presence
of an adaptive adversary A.
The protocol pi based on asymmetric encryption and public-
key signature scheme. To show pi is secure, we need to show
that it maintains secrecy if ENC is secure by giving proof for
Theorem 4.2. Before showing the proof, first we need to argue
about Lemma 4.3. Even if A breaks the encryption, still parties
A & B can do conversation authentically and A can only in-
fringement the conversation during protocol steps. The proto-
col maintains authentication if public-key signature is UF-CMA
2 If we consider parties in two isolated set of initiator and responder, we
can omit requirement of bit b, the protocol still be valid for key exchange
protocol .
4.1 br secure game 23
secure. To show proof for this, we can construct an adversary
C which runs in time t?? using blackbox access of A and will
able to break the public-key signature scheme, SIG of protocol
pi. The correctness of protocol run by A relies on simulation of
B or C. If A evaluates that the simulated game environment
has cheated it, A can abort the execution. Let A is playing the
game while encryption scheme used in protocol pi is IND-CCA
secure. Suppose A runs the game and wins in time t with an
advantage more than negl.
Advantage[A] = |Pr[A = 1|b = 0] ? Pr[A = 1|b = 1]| > negl
Using A , we can construct another adversary B which runs in
time t? using black-box access of A and will able to break the
encryption scheme, ENC of protocol pi.
Pr[Break the ENC] = |Pr[BO
pi
k,b=1 = 1] ? Pr[BO
pi
k,b=0 = 1]|
+ |Pr[BO
pi
k,b=0 = 0] ? Pr[BO
pi
k,b=1 = 0]| < negl(k) ...eq(1)
This is a contradiction of our initial assumption that pi uses IND-
CCA secure encryption scheme hence A is not able to break
the system. Informally, If A is able to distinguish between an
encrypted message and a random message then B will be able
to distinguish between m1&m2 to break encryption scheme of
IND-CCA game. And if A can change session key in last mes-
sage to a responder then C can break the signature scheme. To
show such contradiction we will prove it by reduction as fol-
lows, to proceed to game, B needs to provide simulated envi-
B
parties
Enc Dec
???
??
m
1,m
2
???
???
C
? =m
b
Sk
Vk .......
Pk .......
Sik
A B
A, B, i, bnew query
B,A, j, b?sessions
S St
A
????
??
C
? 6= C
?
??
m
?
Figure 8: Proof model for B breaks encryption if A breaks protocol
ronment to A. As a setup A needs public keys of all parties . B
24 security analysis of ke(enc ,sig)
can guess on which session A can run Test query and involve
parties A(initiator), B(responder) in polynomial time. If B can’t
guess the test session correctly it will simply output a random
choice by flipping a coin. For every party B chooses random en-
cryption keys and signing key except responder B’s public key,
which it will provide from the experiment of IND-CCA game.
To run this game, B also need to track protocol progress (keep
transcript). To do so it maintains several maps to store nonce
and session key it generated using keyed with lsid and a map
of lsid keyed with sid for fast lookup. We are assuming that
query input is not needed to validate here and at any point if B
receives an invalid sid it aborts with a random guess for IND-
CCA game. GAME G1 for B to simulate for A’s game. Oracle
Algorithm 3 Initialization(1?)
Require: vector? [ ]
Require: map? [ ]
for i? 0 to n do
((pki, ski), (siki, vki))? Kg
add (pki, ski) to map as key-value pair
add (vki, siki) to map as key-value pair return
vector((pk1, vk1), ....., (pkn, vkn))result()
if A finishes gracefully then return bit b, result of game
played by A
else##[A aborted in between] return b? ?$ {0, 1}
procedure for IND-CCA Game to B
Algorithm 4 LeftoRightGame(m0, m1)
C? ENC(mb,pk)
output C
Algorithm 5 Dec(C?)
if thenC? 6= C
m? ? Dec(C?,sk) return m?
elsereturn ?
Queries response of B to A
• New(A, B): B notes down by adding an entry in directory
that it started a session sid, lsid(A,B,kth,b) and responds
with sid.
• Send(sid, message): B will lookup in the map for it’s own
or partner’s nonce for validity and respond with nonce
4.1 br secure game 25
and identity for first two stages. It can also produce en-
cryption and signature as it has all the keys to generate
message for final stage except the session it guesses as
Test session. For final stage of initiator, B generates a ran-
dom session key, Klsid. Compute the signature and en-
crypt these two with public key of responder and send it
to A.
• Reveal(sid): B will give away the session key, Klsid to A.
• Corrupt(sid): Except for party other than B (essentially in-
volve in Test query), B will give away the encryption &
signature keys.
Let B is a t-time adversary who plays the IND-CCA game.
AdvIND?CCA(B) = Pr[GBIND?CCA = 1] 6 12 + ?
Pr[GBIND?CCA = 1] depends on following conditions.
• A distinguishes between real and random keys.
• A generates signature by itself.
Condition 1: A distinguishes between real and random keys
Condition 2: A generates signature by itself
Proof of Theorem 4.2. We have equation(1) as,
Pr[Break the ENC] = |Pr[BO
pi
k,b=1 = 1] ? Pr[BO
pi
k,b=0 = 1]|
+ |Pr[BO
pi
k,b=0 = 0] ? Pr[BO
pi
k,b=1 = 0]| ...from eq(1)
The first term & third of RHS is same as condition 1 stated above.
If A can distinguish real/random then B will output correct
result.
The second term and fourth term of RHS (absolute values) is
the probability that third message is send and received not by
parties (by the adversary), as it breaks the protocol rule. Let
total CS session are used by A to win the game and out of these
session A uses a session ST as test session, which is condition
2. From Lemma 4.3, we can substitute these two condition in
equation (1) as follows,
Pr[Break the ENC] = |Pr[BO
pi
k,b=1 = 1] + Pr[BO
pi
k,b=0 = 0]|
- |Pr[BO
pi
k,b=0 = 1] + Pr[BO
pi
k,b=1 = 0]|
Pr[Break the ENC] = Pr[A Win] - 1CNPr[Forge the SIG]
If winning of A is non-negligible then breaking of ENC is also
non-negligible.3.
contradicting(1). Hence Pr[A Win] < negl(k) 2
Also, by rearranging the terms,
3 negligible functions are associative
26 security analysis of ke(enc ,sig)
Pr[A Win] = Pr[Break the ENC] + 1CNPr[Forge the SIG]
Where CN is no of session initiate by the adversary.
4.2 uc security
4.2.1 K?E: KE with JUC side/effect
K?E is the joint state modification of KE(ENC,SIG) To overcome
the side-effect of joint state, KE(ENC,SIG) needs to be changed
to ?KE(ENC,SIG), we can do it by including process id of ITM
which runs the current session of protocol. We can do this for
parties A and B by
ENCPki{SIGNSikA(A,NA,B,NB), K}?
ENCPki{SIGNSikA(A,NA,B,NB,pid), K,pid}
The first one uses process id, pid in encryption only which is
quite sufficient to change the overall output of KE. Other wise
we can use the pid in both signature and encryption.
S
E
FKE
parties
A
parties
dummy
Real
Ideal
m
|m|
Cr
Figure 9: Execution model for UC Framework
Theorem 4.4 If KE(ENC,SIG) is secure in Games it is also UC se-
cure.
Disproof by long term corruption.
Sketch[Nie02]. Consider two parties Pi and Pj acting as re-
ceiver and initiator respectively. Consider the environment E
which activates Pj with an arbitrary session key sk, assume to-
tal length of encrypted message is lm(k), where lm(k) is some
polynomial. Consider the adversary A does not corrupts any
party but just waits for Pi and Pj to finish the first two stage
and for Pj to send a message c at final stage of the protocol to
Pi. The adversary outputs c to the environment and then cor-
rupts Pi before c arrives to party. The adversary outputs to the
4.2 uc security 27
environment the value of private keys (Siki, Pki) of Pi by this
information gain. As message with sk is committed to the pri-
vate key of Pi (ENC is semantically secure). If the environment
runs the code of Pi from private keys and with input c to ver-
ify, then c will decrypt to earlier message created with sk with
overwhelming probability. We assumed KE(ENC,SIG) is UC Se-
cure so by the definition of UC secure protocol, there should
exist a simulator S such that S simulates A in idealised world
with trusted third party F in presence of the same environment
E which interact with A earlier for the long-term key corrup-
tion. If E detects an output distinguishable from these two ad-
versary. But in the ideal-world abstraction of secure communi-
cation given by FKE(ENC,SIG), the simulator, S does only know
length of message with sk during the execution as long as both
parties are uncorrupted. The simulator must therefore generate
c on its own by just knowing the length. On the corruption of
Pi, the simulator knows the message and calculates Pki to give
to the environment. E running Pi with key Piki will open ear-
lier message given c with non-negligible probability. Nielson
shows that it is more than frac12.
Since ENC is a trapdoor permutation, c will decrypt to only
one value except than negligible probability. Hence we can con-
struct an injective map such that,
m1,Pki1 = c
m2,Pki2 = c
m3,Pki3 = c
...................
mn,Pkin = c
Intuitively this means that the length of Pki must be at least
l(m), length of the message itself. Pi is a Probabilistic Polyno-
mial Time (PPT) Interactive Turing Machine (ITM) and it can
send message in polynomial length of security parameter k
during the entire execution. For a polynomial size l(m), length
of Pki must be super-polynomial. Which contradicts earlier as-
sumption of Pi to be a PPT ITM. Hence E can distinguish the
random output for the final step produced by S from actual
one. That proves KE(ENC,SIG) is not UC secure.

5
E VA L U AT I O N
5.1 main results
1. UC framework fails to provide security guaranty of the
protocol Key Exchange (KE) due to it’s requirement of
freshly generated long term key (shared state) for differ-
ent session in presence of adaptive adversary. Even we
assumed a global session identifier for UC which is not a
practical case for real protocol1 like SSL/TLS.
2. We needed to add JUC theorem patch to universally com-
posable theorem proposed by Canetti[Can01] to address
long term key sharing with multiple session of the party.
This modification changes initial protocol a bit, which is
used as a single copy.
3. We found that cryptographic games is simple to construct
but if reduction needs nested games, it is hard to formal-
ize. To overcome this issue we calculated conditional prob-
ability than separate reduction of Signature scheme and
mix two games later.
4. The above simplification does not affect security guaranty
though and KE is proven secure in cryptographic games.
We got even a stronger result which we were hoping for,
the results shows the adaptive adversary cannot guess key
for any fresh session with matching conversation (we re-
quired it for only one test session, St).
Theorem 5.1 [Gamepisecure 6? UCpi
?
secure]: If a protocol pi is secure
in game based model than there exist a protocol pi? which is secure
in UC model for non-adaptive adversary but which is not secure in
presence of adaptive adversary.
Remarks on Protocol KE(ENC,SIG).
• KE(ENC,SIG) is not Efficient: Our protocol uses ENC and
SIG for maintaining secrecy and authenticity. Overall KE
is not very efficient as it is using both public key encryp-
tion and public key signature. What we want for our anal-
ysis is a simple and easy to analyse protocol which falls
1 UC demands session identifier to be globally i,e; say n parties running m
session locally needs to maintaion nxm collision free session identifiers
29
30 evaluation
just in the boundary between cryptographic games and
simulation based models so that we can see how these
models bereaves.
• Only responder is secure: The security definition allows all
queries from adversary to initiator. We only provide se-
curity analysis for receiver and never discuss for initia-
tor. Key design of the KE(ENC,SIG) is to use any security
primitive in final stage only. Random nonce is exchanged
in earlier stages along with party’s identifier but it flows
in clear. Due to this fact no extra information can be ob-
tained from initiator before starting final communication
flow. Intuitively, if adversary tries to mangle with either
of the values, it cannot lead him to finish the protocol as
responder will detect it on arrival of the final message.
Hence, we did not analyse it in detail and left it as an
exercise.
• Analysed ? is not pi given: Applying JUC theorem in hybrid
model2 changes the actual protocol and security guaran-
tee came for ? instead of pi. This is a side effect of UC with
joint state and [CR03] argued that pi is also secure. If one
is still suspicious (which is a good thing), either needs to
wait for some straight implementation of joint state in UC
theorem or use some alternative like GNUC.[HS11] Au-
thors use hierarchical implementation for the common re-
source in GNUC. A quick analogy will be running several
virtual machines inside a single operating system.
• Anonymous user can join: It is good to make model extend-
able. Anonymous user can join the system after initial-
ization(after distributing public keys). This can be mod-
elled via considering special party process with id P0. This
party can be an honest/dishonest or an adversary itself.
Other parties at least need to know the public keys. In
practice, certificates expire and redistributed so this is a
possible case. P0 is just for giving idea as to how to accom-
modate more parties and it can be extended to include
more. However, the security guarantee is only for the par-
ties who join at the beginning, we are arguing that even
an anonymous user can join and the system will remain
secure.
• Corrupted party’s partner or partner session security is not
guaranteed: We have shown here two party key ex-
change protocol . If one of the parties is under adversarial
control (Adaptive adversary), there is no longer honest
2 parties in real model has secure access to ideal functionality
5.2 moving relationship to separation 31
majority in the protocol . There is no known general pro-
tocol which is adaptively secure for honest minority in
public channel in both the models. In case of reveled part-
ner session or corrupted party, the adversary knows the
session key3, which is the prime goal of security. Hence
there is no point of maintaining security if session key
itself is exposed to adversary.
5.2 moving relationship to separation
Real world problem. Real-world execution in simulation based
model uses asynchronous communication between parties, ad-
versary and the environment.A enjoys this non-interactive com-
munication property to send new message before delivering
the earlier ones. And this is not limited to parties but E as
well. Due to this A convinces E(decisional entity) that he knows
the secret for any party Pi by adaptively corrupting and pro-
viding transcript of (cipher text, secret key) list. On the other
hand cryptographic games corruption operation is atomic i.e;
the Game(decisional entity) knows and update its internal state
once adversary asks to corrupt a party.
This is a generic property of simulation based model and
provides very strong security. But due to this "too strong" secu-
rity, no semantically secure generic encryption scheme can be
proven secure in presence of adaptive adversary.
The dichotomy problem of Simulator. Ideal world process ex-
ecution is magically secure. This magical security comes from
information theory and to make this model useful, adversarial
powers are worth to know. Simulations define power of S the
same as E which restricts S to gain extra advantage.
The impossibility task of simulator is to guess the message
by just knowing the length of a message. Which arguably pro-
vides strong construction to ideal functionality.4 The adaptive-
ness of A creates this dichotomy and to overcome this S either
needs more power than E or an assistance setup. The first open
path of more powerful simulator than environment hurts the
security definition. But there is significant work done with the
additional setup.
The demanding change. The quest of stronger security guaran-
tee than standard Games comes at price so far. The simulation
based models demand to pre-distribute global session identifier
3 KE(ENC,SIG) does not provide perfect forward security
4 argued secrecy in ideal world is same as perfect encryption scheme e.g; One-
Time Pad.
32 evaluation
for modelling. If the protocol has joint state (which is practically
true) the security guarantee is provided to a slightly modified
protocol.5
FINAL NOTE. Cryptographic games evolve over time since Gold-
wasser and Micali used provable security for modelling security
guarantee of encryption scheme.[GM84] It is popularly used by
the cryptographer due to its simplicity and adaptiveness to new
tool. But due to this adaptiveness, there is no strong abstract
framework known for Games. Cryptographic tools are getting
much more complex day by day and it demands comprehen-
sive security modeling technique like the current simulation
models are offering. To move forward in the discussion needs
an abstract modeling technique in Games, which also provides
practical requirement like composition or modularity.
5 joint state implementation is to provide modularity otherwise classic UC
can also model security without joint state but inefficiently.
5.2 moving relationship to separation 33
ï»¿

6
C O N C L U S I O N
Notion of security models as Cryptographic games and Simu-
lation based model, especially UC framework is not new but we
present a new and interesting concept from previous work. It
is discussed earlier that UC security model is stronger than the
cryptographic games but we found it is not true at least for the
case of Key exchange protocol . We have presented a simple two
party key exchange protocol and shown it to be secure in clas-
sic cryptographic game based model presented by Bellare Rog-
away (BR Model). Then we have shown the same protocol is not
secure in Universal Composable framework, a standard simu-
lation based framework. Then we commented out the problem
with generic simulation and we support the argument that it
is the case for all common simulation based framework which
uses ideal and real world dichotomy. This draws a clear line of
separation between these two security models and to conclude
which one of these two models is stronger will require further
investigation.
6.1 possible future work
There is good research motive to find the "Holy Grail" of secu-
rity modelling, a formal relationship to demonstrate which one
of these two is Stronger in the same provable sense. We put the
stepping stone for key exchange protocols and one could find
easier to start from key exchange then hoping for a generalisa-
tion of the relationship to make final comment on two models
discussed. We also find it interesting not having any generic
standard abstract model for games. This is not related to the
work we carried so far but one could further investigate this
open problem.
35

A
A P P E N D I X
a.1 random oracle model
Random oracle model remains one of the most controver-
sial security modelling technique. In brief history, Bellare and
Rogaway uses random oracles for practical security modelling.
The security proof in this model is simpler because of the con-
struction of a fully random oracle. Authors suggests to show se-
cure a cryptographic tool in random oracle model and later re-
place it with ongoing secure enough actual hash function (like
MD5 or SHA1). Bellare, Boldyreva and Palacio presented an
asymmetric encryption scheme, which is secure in ROM but
unsecured in standard games. Later, the results is analysed by
Koblits and Menezes and shown that previous analysis break a
fundamental rule in construction of uninstantiable encryption
scheme. They further provides evidence to support the model
but these discussion is out of the scope of current work.
Random oracle O : {0, 1}? ? {0, 1}k, where k ? M chosen
independently and uniformly by selecting O(m) ? {0, 1}k for
m ? {0, 1}?. The random oracle model uses this oracle to pro-
vide any randomness. This a very strong assumption about
randomness as the only way to get a collision is to send same
message twice to random oracle. Further the construction of
the model uses a map of input and out put valuse follows,
• if input value is queried for the first time, select r ? {0, 1}
randomly and add into the map for later compararision
of input quries.
• if input value is quried before, return the value from map
which is preveously choosen randomly.
The oracle is accessed by all the parties including adver-
sary and environment. In this model, protocol pi uses random
oracles to implement some functionality F. If pi is proven secure
in the model then in real world all random oracle is replaced
by practical function who mimic the random oracle, mainly a
hash function.
a.2 probability of B guesses test session correctly
Here we present a independent result to the main proof. It
gives a weak relation between static and adaptive adversary
37
38 appendix
for KE(ENC,SIG).
A chooses Test session not statically so B is not able to know it
in advance. It could be any random session for B hence proba-
bility of guessing is,
Pr[BSTGuess] =
1
total no of session
But the IND-CCA game played by B needs to guess party only
to match the long term key use for the Test session ST. The real
catch is if A ask to corrupt the guessed party then it will look
like a fake experiment to A. In presence of adaptive adversary
we can at most say that two parties will not be corrupted (Par-
ties involve in session ST) and either of them will be owner of
last step of the protocol , hence
Pr[BSTGuess] =
2
total no of parties .
1
2 =
1
n
Proposition A.1 Let there is an adaptive adversary A and Protocol
KE(ENC,SIG) is at least as secure as adversary A is non-adaptive.
AdvIND?CCAAdaptive (B) 6 knAdv
IND?CCA
Static (B) 2 < k 6 n
Current proof can be easily leads to the statement. We argue
that if A is not adaptive than session which are corrupted,
known in the beginning of the game. In that case,
Pr[BSTGuess] =
total no of non?corrupt parties
total no of parties =
1
n
which is greater than current case if static adversary does not
corrupt all parties except parties involve in ST.
B I B L I O G R A P H Y
[BFWW11] Christina Brzuska, Marc Fischlin, Bogdan Warin-
schi, and Stephen C. Williams. Composability of
bellare-rogaway key exchange protocols. In Yan
Chen, George Danezis, and Vitaly Shmatikov, edi-
tors, ACM Conference on Computer and Communica-
tions Security, pages 51–62. ACM, 2011.
[BR94] Mihir Bellare and Phillip Rogaway. Entity authen-
tication and key distribution. In Douglas Stinson,
editor, Advances in Cryptology CRYPTO 93, volume
773 of Lecture Notes in Computer Science, pages 232–
249. Springer Berlin / Heidelberg, 1994.
[Can01] Ran Canetti. Universally composable security: A
new paradigm for cryptographic protocols. In
FOCS, pages 136–145. IEEE Computer Society,
2001.
[CK02] Ran Canetti and Hugo Krawczyk. Universally com-
posable notions of key exchange and secure chan-
nels. In Lars R. Knudsen, editor, EUROCRYPT, vol-
ume 2332 of Lecture Notes in Computer Science, pages
337–351. Springer, 2002.
[CR03] Ran Canetti and Tal Rabin. Universal composition
with joint state. In Dan Boneh, editor, CRYPTO,
volume 2729 of Lecture Notes in Computer Science,
pages 265–281. Springer, 2003.
[GM84] Shafi Goldwasser and Silvio Micali. Probabilistic
encryption. Journal of Computer and System Sciences,
28(2):270 – 299, 1984.
[HS11] Dennis Hofheinz and Victor Shoup. Gnuc: A new
universal composability framework. IACR Cryptol-
ogy ePrint Archive, 2011:303, 2011.
[Knu74] Donald E. Knuth. Computer Programming as an
Art. Communications of the ACM, 17(12):667–673, De-
cember 1974.
[KT08] Ralf Kusters and Max Tuengerthal. Joint state the-
orems for public-key encryption and digital signa-
ture functionalities with local computation. 2012
39
40 bibliography
IEEE 25th Computer Security Foundations Symposium,
0:270–284, 2008.
[MvOV96] Alfred Menezes, Paul C. van Oorschot, and Scott A.
Vanstone. Key establishment protocols. In Hand-
book of Applied Cryptography, pages 489–541. CRC
Press, 1996.
[Nie02] JesperBuus Nielsen. Separating random oracle
proofs from complexity theoretic proofs: The non-
committing encryption case. In Moti Yung, editor,
Advances in Cryptology, CRYPTO 2002, volume 2442
of Lecture Notes in Computer Science, pages 111–126.
Springer Berlin Heidelberg, 2002.
G L O S S A RY
adversary a attacker who wants to break the security. 4
flow a peice of information transmitted over commu-
nication channel between parties. 6
IND-CCA Indistinguishability under Chosen Ciphertext At-
tack. 22–24, 38
MD5 Message Digest Five. 37
protocol a multi-party sequential algorithm which runs in
asynchronous steps to commonly achieve a goal.
1, 29
SHA1 secure hash algorithm 1. 37
SK Session Key. 4
SSL Secure Socket Layer. 29
ST Test Session. 38
TLS Transport Layer Security. 29
TM Turing Machine: a finite state machine with infi-
nite long working tape to read or write one at a
time. 11
UF-CMA Unforgeability under Chosen Message Attack. 22
41

Acknowledgements 
 
Upon the accomplishment of this thesis, I would like to express my sincere 
thanks to those who offered me help, advice, guidance, and criticism during the 
progress of my work.  
    I'd like to extend my heartfelt gratitude to all those who have offered me kind 
help and valuable comments on the writing of my thesis. I'm particularly thankful to 
my academic supervisor, Dr. Bogdan Warinschi, who proposed scholarly guidance 
and extensive criticisms on the manuscript of this thesis. I am also thankful to my 
friend, Georgios Kafanas, who gave me his comments throughout the thesis.  
Profound thanks and sincere appreciation are also extended to those who have 
taught me and given me valuable suggestions with their profound knowledge and 
experience during postgraduate study, from whose advice and lectures I have earned a 
lot.  
Finally, I would like to thank to my beloved family and friends who never fail to 
give me great help, suggestions and encouragement. 
 
Abstract 
 
There are two frameworks for defining security in modern cryptography. One is based 
on notion of simulation which uses ideal functionalities. We refer it to as Universal 
Composability (UC). Another one is based on the notion of cryptographic games. 
There has been a lot of work on comparing these two different definitional styles 
recently. Some interesting negative results about the existence of the ideal 
functionalities are proved. We call these results the impossibility result. The goal of 
this thesis is to relate the game specifications to the ideal functionalities and to prove 
a more general form of the impossibility result. More specifically, we have the 
following things: 
 
 
Ó Review the UC-security framework and the cryptographic games. 
 
Ó Give the canonical form of the ideal functionality. 
 
Ó Give a precise definition about the game satisfaction and the descriptions of the 
general hiding game and the general binding game. 
 
Ó Prove two theorems which relate the game conditions to the ideal functionalities: 
 
® If the ideal functionality is syntactically hiding a variable, then the 
functionality satisfies the general hiding game. 
 
® If the ideal functionality is syntactically binding a variable, then the 
functionality satisfies the general binding game. 
 
Ó Prove a more general impossibility result: the functionalities for the general 
hiding and general binding game are not realizable. 
 
On the Limits of Realizability of Ideal Functionality
Defined Through Games
Tianxiang Cui
September 11, 2011
Contents
1 Introduction 3
1.1 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2 Our contribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3 The structure of the rest of this work . . . . . . . . . . . . . . . . . . . . . 4
2 Universal Composition 5
2.1 Cryptographic primitives and the ideal functionality . . . . . . . . . . . . . 5
2.2 The Universal Composition (UC)-security framework . . . . . . . . . . . . 6
2.3 The Universal Composition theorem . . . . . . . . . . . . . . . . . . . . . . 11
2.4 Extending the original Universal Composition-security framework . . . . . 13
2.4.1 The canonical ideal functionalities . . . . . . . . . . . . . . . . . . . 13
2.4.2 Inexhaustible interactive Turing machines . . . . . . . . . . . . . . 14
3 Cryptographic games 15
3.1 General cryptographic games . . . . . . . . . . . . . . . . . . . . . . . . . 15
3.2 The commitment games . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3.2.1 The commitment scheme . . . . . . . . . . . . . . . . . . . . . . . . 16
3.2.2 The commitment games . . . . . . . . . . . . . . . . . . . . . . . . 18
4 Cryptographic games and Universal Composition 21
4.1 The commitment functionalities . . . . . . . . . . . . . . . . . . . . . . . . 21
4.1.1 The common reference string (CRS) model . . . . . . . . . . . . . . 21
1
4.1.2 The ideal functionality for a single commitment . . . . . . . . . . . 22
4.1.3 The ideal functionality for multiple commitments . . . . . . . . . . 23
4.2 The Universal Composition commitment protocol . . . . . . . . . . . . . . 24
4.3 Derive the canonical ideal functionality from the cryptographic games . . . 24
4.3.1 The communication languages . . . . . . . . . . . . . . . . . . . . . 24
4.3.2 The canonical functionality of a given cryptographic task . . . . . . 26
4.4 The game satisfaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
4.5 The general hiding game and the general binding game . . . . . . . . . . . 29
4.5.1 Hiding a variable . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
4.5.2 Binding a variable . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
5 The impossibility 34
5.1 The impossibility of UC commitment in the plain model . . . . . . . . . . 34
5.2 The impossibility of the bit-commitment . . . . . . . . . . . . . . . . . . . 35
5.3 The impossibility of Universally Composable password-based key exchange 35
5.4 Our impossibility work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
6 Conclusion 42
Bibliography 43
2
1 Introduction
1.1 Background
The security conditions for the cryptographic primitives can be expressed in many ways.
The mostly common used ones are cryptographic games and ideal functionalities. Usually
cryptographic games describe the security conditions in a standalone manner. For instance
the adaptive chosen ciphertext attack (IND-CCA2) game of a semantically secure encryp-
tion scheme can be expressed as saying that the probability of any adversary winning a
certain game against a challenger is negligible [CHH+07, BBM00]. The definition of the
game specifies the actions and information available to the adversary and also the corre-
sponding winning conditions. However this definition does not consider the behaviour of
the protocols in the complex environment. Another way to express the security conditions
is to use the ideal functionalities [AG97, Can01, LMMS98]. Usually it refers to Univer-
sal Composability (UC)-security framework. The UC-security framework can capture the
unexpected interactions during the complex protocol execution and therefore it provides a
generic method for analyzing the security of protocols when they are composed. Informally
we say a primitive is secure if there exists no adversary which can make a distinction be-
tween the real protocol and the ideal functionalities under any environment. The advantage
of this is that the composable notions of security can be implied by the indistinguishability
of the ideal functionalities.
Recently, there have been a lot of work on comparing the game conditions and the
ideal functionalities [Can05, BDD+06]. Some interesting results about the realizability of
the ideal functionalities are explored under certain assumptions [Can05, BDD+06, Can01,
CHK+05, CKL06]. These results are called the impossibility results. Consider a concept
like the commitment scheme, Canetti et al [CF01] shows that a particular ideal functionality
for bit commitment is not realizable. Based on their work, Datta et al [BDD+06] shows
that no commitment functionalities are realizable. Canetti et al [CHK+05] also shows that
a particular functionality for the password-based key exchange protocol is not realizable.
1.2 Our contribution
Our main result is an even more general impossibility result based on the previous work
[CF01, BDD+06]. It says that given any ideal functionality which satisfies both the general
hiding game and general binding game, that ideal functionality is not realizable. It is more
3
general in the sense that [CF01] focus on a specific ideal functionality for the commitment
games and they show that specific ideal functionality is not realizable, [BDD+06] focus on
all the ideal functionalities for the specific games (the commitment games) and they show
all the ideal functionalities for that specific games are not realizable. Our work focus on all
the ideal functionalities for the class of the games and we show all the ideal functionalities
for that class of the games are not realizable.
Another contribution is that we give the precise definition of the game satisfaction and
the descriptions of the general hiding game and the general binding game. Intuitively, the
general hiding game is the game where the information of the communications between the
parties during the protocol execution can be erased and the general binding game is the
game where only specified traces of the communication between parties are allowed during
the protocol execution. Then we proved two theorems which relate those game conditions
to the ideal functionalities. The first theorem says that if the functionality is syntactically
hiding the message, then this functionality satisfies the hiding game. Similarly, the sec-
ond theorem says that if the functionality is syntactically binding the message, then this
functionality satisfies the binding game.
1.3 The structure of the rest of this work
In section 2 we review the Universal Composition framework and the main Universal
Composition theorem. In section 3 we review the general idea behind the cryptographic
games and we also review the commitment scheme along with its corresponding games. In
section 4 we review some ideal functionalities for the commitment scheme and we also derive
a canonical ideal functionality for this work. Then we give the precise definition of the
game satisfaction. At the end of the section 4, we give the description of the general hiding
game and the general binding game and then present our theorems which relate the game
conditions to the ideal functionalities. In section 5 we review some previous impossibility
work and then we present our impossibility result along with its corresponding proof. In
section 6 we give some possible further directions for the research. In appendix, we give
one form of the generalization of the games which can be potentially used for our work.
4
2 Universal Composition
2.1 Cryptographic primitives and the ideal functionality
Generally, the cryptographic primitives can be considered as the well-implemented low
level algorithms. They are usually used to build the security systems. For our work, we
take the idea from Datta et al [BDD+06] as the follows: the cryptographic primitives
are the interface and a set of correctness conditions or a set of security conditions which
can be expressed by using the interface. Then the interface can be defined as a list of
actions which are available to the primitives. It can be represented as a set of algorithms.
For instance, there are three probabilistic algorithms of the interface to an encryption
primitive: the key generation algorithm, the encryption algorithm and the decryption
algorithm [BDD+06]. The correctness condition says that it should give the origin message
back when running the decryption algorithm of an encrypted message under the correct key.
We can say that an encryption scheme is semantically secure if there exists no probabilistic
polynomial-time adversary that can tell which of the two messages has been encrypted with
probability significantly better than 0.5 (the probability of randomly guessing by tossing
a coin)[BDD+06]. This is called the security condition.
A protocol for a cryptographic primitive can be considered as a process which could
respond to the function calls and then provide the corresponding returns [BDD+06]. It
should not involve any additional private communication during the process. Apart from
supporting the interface as the protocol does, the functionality may also include some
private communication such as a trusted third party under certain restrictions. Since the
functionalities are unrealistic on the public network, the restrictions are used as an obstacle
of the abuse of the security in the private communication. On the other hand, there are
no restrictions on the functionalities about communicating or revealing information to the
adversary. One example presented in [Can04] shows that a functionality of a signature
scheme can allow the adversary choose bit-strings for signatures.
Recently it is very common to analysis the security of a protocol in terms of using a
trusted party paradigm. In this paradigm, the execution of the real protocol is compared
with an ideal process. All the inputs are visible to the trusted party and therefore it can
compute the outputs [GKZ10]. Informally we say that a protocol is secure if running the
protocol with a practical adversary is indistinguishable from running the protocol with the
ideal process (using some trusted parties). In the Universal Composability (UC)-security
framework, the programs run by the trusted party are referred to the ideal functionalities
5
[GKZ10]. More precisely, an ideal functionality is one which can satisfy both the correctness
condition and the security conditions at the same time, with the latter in a way that the
adversary with an infinite computing power can not win the corresponding game, which is
called the Òinformation-theoretic wayÓ in cryptography. [BDD+06].
2.2 The Universal Composition (UC)-security framework
In most previous study on the ideal functionality [Can01, PW01, PSW00, BPW04, DKMR05,
MRST01], although the protocol is a component of a polynomial bounded distributed sys-
tem, we can always find the existence of the security of the protocol [Kus06]. These works
attempt to analyze the protocols in a modular way. And one idea based on this method
was first presented in [GMW87]. The idea is as follows: with the purpose of determining
whether a given protocol is secure of a specific cryptographic task, firstly, we assume an
ideal process which can perform this cryptographic task in a secure way. Then the security
of a protocol can refer to an ideal process where all parties may forward their inputs to a
trusted party. The trusted party here is to perform some computations correspondingly
and to interact with the parties. Then it will return corresponding output to each party.
Therefore, this ideal process is considered to be the component which formally specifies
the necessary security conditions in a given cryptographic task. Informally, a protocol is
said to be secure if the protocol can emulate the ideal process in the sense that we can
convert every attack on the real protocol into an equivalent attack on the ideal protocol
[Kus06].
The standard UC-model of protocol execution is presented in [Can98]. This framework
is built on certain famous theoretical framework applied in the evaluation of function
based on certain common tasks [PW01, DM00, Can06, PW94, Bea91, GL91]. It provides
the evidence that is used to consider the security of the protocol in cryptographic tasks
practically and it is an example of secure multi-party computation (MPC). MPC is aiming
to enabling all parties to hand their inputs to the trusted party jointly while the trusted
party keeps the input of each party separately at the same time.
There are two main components of the standard UC model: one is the parties in the
protocol execution and the other one is the adversary. These components are modeled as
the interactive Turing Machines (ITMs). Formally we have the following definition for the
ITM in the UC-model:
Definition 2.1. The ITMs in the UC-model are probabilistic Turing Machines which are
parameterized with some externally written tapes. Generally there are three types of the
6
externally written tapes:
¥ The tapes with the security parameter and the identity of the party running ITM.
¥ The written input tapes when ITM is first used.
¥ The communication tapes where the output is written.
And we also have the following definition for the systems of ITMs:
Definition 2.2. The system of ITMs is a set of ITMs. In the UC-model, the execution
of the protocol proceeds from one configuration to the other configuration. In each con-
figuration a single ITM I is activated and the output of I addresses to some other ITM
I ?. When the output of I is written on some appropriate communication tape, I ? will be
activated.
The parties running the protocol are represented as a system of ITMs while the adver-
sary is represented as a single ITM. During the execution of the protocol, a proportion of
the parties can be selected to be controlled by the adversary. Further, the adversary also
exerts an influence on the information transfer process, ensuring the communication to be
synchronous. The adversary and the selected parties may have some interaction in a set
of inputs, and then the parties may produce their separate local outputs. In [Can05], the
concatenation of each partyÕs local outputs and the adversaryÕs are termed as the Òglobal
outputsÓ. In order to evaluate some function f , each party transfer the inputs to a trusted
party in the ideal process. The trusted party here is used to compute the functions and
send the results to the specified parties. It is noteworthy that there is a limitation in the
interaction between the adversary and the trusted party: the adversary can only interact
with the trusted party with a form of the corrupted parties. [Can05].
Both the execution of the real protocol and the execution of the ideal process can be
considered as probability distributions. First we want to given the definition of probability
ensembles and the notion of indistinguishability. Originally it is presented in [Can05].
Definition 2.3. A distribution ensemble X = {X(k, a)}k?N,a?{0,1}? . The distribution
{X(k, a)} is associated with a ? {0, 1}? where in the UC-framework, k is the security
parameter and a is the input.
Definition 2.4. Two ensembles X and Y are called indistinguishable (denoted by ?=), if
?c, d, ?k0 ? N such that ?k > k0 and ?a ? ??²kd{0,1}? , the following equation holds:
|Pr(X(k, a) = 1)Pr(Y (k, a) = 1)|< k?c
7
Now we can say that it is secure for a protocol to evaluate a function if it is unable to
distinguish the real protocol execution from the execution of using an ideal functionality
(see figure 1).
Figure 1: The execution of the real protocol and adversary A is indistinguishable from
the execution of the ideal functionality and adversary S.
More precisely, we have the following definition [Can05]:
Definition 2.5. Protocol pi securely evaluates a function f if for any adversary A which
interacts with the protocol there exists an ideal process adversary S such that for any set
of inputs to the parties, the global output of running pi with A is indistinguishable from
the global output of the ideal process for f with adversary S.
More precisely, we can say that if protocol pi securely evaluates the function f , then the
outputs generated by the parties running pi are guaranteed to be indistinguishable from the
outputs of f on the same set of the inputs. This means any information collected by the
adversary which has an interaction with protocol pi can be also collected by the adversary
which can only get the inputs and outputs from the function f .
This definition is used to ensure the security under the non-concurrent composition
situation[Can05]. If the instances of the protocols run concurrently, this definition no
longer holds [Can05].
The Universal Composition(UC)-security framework captures the whole picture of the
fundamental framework. Based on that, there is a new emergence of an algorithm entity.
We call this entity the environment machine. Informally we can consider the environment
machine as anything external to the current execution of the protocol. For instance it
might be the executions of the other protocols, human users and so on. There are two
8
interactions between the environment machine and the execution of the protocol. The first
one is that the environment machine selects certain random inputs and then transfers them
to the adversary and the parties. The second one is that the environment machine then
gets the outputs back from the adversary and the parties. At the end of the execution,
the environment machine produces the output of a single bit, which can be used to deter-
mine whether it is the real protocol or the ideal process that the environment machine is
considered to have interacted with.
Using the idea in the standard UC-model, similarly we can also infer that a protocol
can make secure evaluation for a function if no environment machine can tell whether it
has interacted with the real protocol or with the ideal functionality (see figure 2).
Figure 2: The environment machine can not tell whether it has interacted with the
real protocol and the corresponding adversary A or with the ideal functionality and the
corresponding adversary S.
Before we proceed, we want to review a common definition in cryptography: the
negligible function, informally we say a function is negligible if it decreases than the inverse
of any polynomial function. More precisely we have the definition as follows:
Definition 2.6. The function f is called negligible if:
(?p) (?np ? N) (?n ³ np) we have f(n) ²
1
p(n)
where p(n) is any polynomial function.
9
Now we can present the following definition for function emulation [Can05]:
Definition 2.7. Protocol pi securely evaluates a function f if for any adversary A which
interacts with the protocol there exists an ideal process adversary S such that there exist
no environment machine Z which can tell whether it has interacted with pi and A or has
interacted with the ideal process and S with non-negligible probability.
In the Universal Composition-security framework, it is allowed for the adversary and the
environment machine to have the unrestricted interaction in the execution. Particularly,
the information between the adversary and the environment machine is exchangeable after
the parties which run the protocol have generated the messages or the outputs. We call this
kind of environment machine the interactive environment machine [Can05]. The following
definition is for the notion ÒUC-realizeÓ [Can05]:
Definition 2.8. If protocol pi securely realizes function f with respect to the interactive
environment machine, then protocol pi UC-realizes function f .
We can apply the same idea to a more general notion, we call it the protocol emulation.
Informally, we can assume there are two protocols: protocol pi and protocol ?. We say that
protocol pi emulates protocol ? if for any environment machine Z, Z considers protocol pi
to be the same as the protocol ?. It means that the interaction between protocol pi and
the adversary A can not be distinguished from the interaction between the protocol ? and
another adversary S [Can05]. The following definition will give a more precise explanation
for protocol emulation [Can05]:
Definition 2.9. Protocol pi UC-emulates protocol ? if for any adversary A there exists
an adversary S such that for any environment Z, the difference between the probability
of Z outputting 1 after interacting with A and parties running pi on any inputs and the
probability of Z outputting 1 after interacting with S and ? on the same set of inputs
should be negligible.
The adversary S is often called the simulator. Informally, we can say protocol pi securely
evaluates a functionality F if there is always a simulator S for any adversaryA which makes
any environment machine Z unable to differentiate whether it has interacted with protocol
pi and the corresponding adversary A or it has interacted with the ideal functionality F
and the corresponding simulator S. The idea of realizing an ideal functionality can be
defined as follows [Can05]:
10
Definition 2.10. Protocol pi UC-realizes an ideal functionality F if pi emulates IDEALF
where IDEALF is the ideal protocol for F .
As it is showed in many work such as [Can98], if protocol pi UC-realizes an ideal func-
tionality F , then it is guaranteed that for the same set of the inputs, the outputs generated
by the parties running pi are indistinguishable from the outputs generated by the ideal func-
tionality F . That is to say, any information which is revealed by the adversary interacting
with protocol pi is revealed by the adversary interacting with the ideal functionality F as
well.
2.3 The Universal Composition theorem
One major finding in the Universal Composition-security framework is called the Universal
Composition theorem highlighted by Canetti [Can05]. First of all, according to his theorem,
a protocol composition is required. Then we may constitute a combined protocol composed
of two protocols in a way as follows: using the above definition, we consider a protocol ?
such that ? UC-realizes an ideal functionality F . Then, consider the arbitrary protocol
pi as a high level protocol. The parties running protocol pi ideally call various instances
of F as well as the normal interactions. Therefore protocol pi is considered as a hybrid
protocol which consists of the forms of various instances of the ideal functionality F and
the normal communications. Thus we call protocol pi F -hybrid protocol. There is no global
coordination of the execution of different instances of F at the same time. Protocol pi may
generate some special session identifiers in order to distinguish the different instances of F
[Can05].
We can then build the composed protocol pi? using protocol pi as follows: we replace
the calls made to new instances of F with the calls to the new instances of ?. In this way,
we can also replace the inputs to the current instance of F with a given message of the
corresponding instance of F . Therefore the output value of the instances of protocol ?
could be considered as the inputs received from the corresponding instances of the ideal
functionality F . It is worth mentioning that a variety of instances of F can be unrestrict-
edly used by the protocol pi simultaneously, as a result, a variety of instances of ? can run
on those relevant messages of protocol pi? concurrently at the same time. Informally, the
Universal Composition theorem says that to run the protocol pi? without accessing to the
ideal functionality F is of no difference from running the F -hybrid protocol pi[Can05].
Formally, the composition process can be defined by using an operator on protocols.
We call this operator the universal composition operator UC(). We have the following
11
definition for UC() [Can05].
Definition 2.11. Given a protocol ?, a protocol pi which makes subroutine calls to ? and
a protocol ? which UC-emulates ?. The composed protocol pi?/? = UC(pi, ?, ?) is identical
to protocol pi. There are two possible modifications:
1. If the protocol pi contains an instruction to pass input x to an ITI (an instance of
ITM (interactive Turing Machine)) which is running ? with identity (sid, pid), then
the composed protoco pi?/? contains another instruction to pass input x to an ITI
which is running ? with identity (sid, pid).
2. If the composed protocol pi?/? receives an output which is passed from ?(sid,pid?) (an
ITI running ? with identity (sid, pid?)), then it proceeds as the protocol pi proceeds
when it receives an output passed from ?(sid,pid?).
One special case of the above definition is that if the protocol ? is the ideal protocol
IDEALF for some ideal functionality F , then the resulting composed protocol can be
represented as pi?/F [Can05].
Now we can state the Universal Composition theorem formally [Can05]. It says if
protocol ? UC-emulates protocol ?, then the composed protocol pi?/? UC-emulates protocol
pi for any protocol pi.
Theorem 2.1. Let pi, ?, ? be Probabilistic Polynomial Time multi-party protocols such
that ? UC-emulates ? and both ? and ? are subroutines. Then protocol pi?/? UC-emulates
protocol pi. There are two special cases:
¥ Let pi, ? be Probabilistic Polynomial Time protocols such that ? UC-realizes a Prob-
abilistic Polynomial Time ideal functionality F and both ? and ? are subroutines.
Then protocol pi?/F UC-emulates protocol pi.
¥ Let F , G be the ideal functionalities such that F is Probabilistic Polynomial Time. Let
pi be a subroutine respecting protocol UC-realizes G, let ? be a subroutine respecting
protocol that securely realizes F . Then the composed protocol pi?/F securely realizes
G.
The Universal Composition theorem highlighted that for any adversary A it is guaran-
teed to have the corresponding adversary AF such that for any environment machine Z,
Z can only distinguish whether it has interacted with parties which run protocol pi? and
12
adversary A or it has interacted with parties which run protocol pi and adversary AF with
negligible probability [Can05].
The UC theorem is helpful as it ensures the security of protocols when being composed
with the use of other protocols. This is a strong guarantee since it holds regardless of the
environment machine and the interactions between the main protocol and its subroutines.
Also, protocols which satisfy the Universal Composition definition are guaranteed to be
secure in other protocol environment. This guarantee can be applied in the area where
the protocols run in a complicated and unpredictable situations such as the contemporary
network communication. Furthermore, it allows for the modular design of protocols since
we can always divide the security tasks into some subtasks and then design the sub protocols
to perform such tasks.
2.4 Extending the original Universal Composition-security frame-
work
There are some problems of the ideal functionalities because of their general nature. Re-
cent work on the relationship between cryptographic games and UC-security framework
[GKZ10] shows that it is cumbersome to define the ideal functionalities and also it is not
possible for the ideal functionalities to specific the desired security property of a given
cryptographic task every time. Therefore several extensions are proposed [GKZ10, Kus06]
in order to fix the weakness of the ideal functionalities.
2.4.1 The canonical ideal functionalities
In the original Universal Composition-security framework [Can05], the ideal functionalities
are not structured in a consistent way. The disadvantage of this is that there are multiple
ideal functionalities with the same property for a given cryptographic task. As showed in
some work on digital signatures [BH03, Can04], it can make the analysis of the crypto-
graphic task complex and error prone. Also as presented in one recent work [GKZ10], the
ideal functionalities are used as a single component for specifying the security requirements
of a given cryptographic task therefore they are unstable since the whole ideal process can
be effected by a single small change. On the same work [GKZ10] they propose a class of
the ideal functionalities called the canonical ideal functionalities. It provides some simple
rules which can easily structure the ideal functionalities and by adding some restrictions
we can get a unique ideal functionality for any given cryptographic task. Without the loss
13
of generality, we are going to use the canonical ideal functionalities for our proof in this
work.
2.4.2 Inexhaustible interactive Turing machines
Another work [Kus06] present a simpler protocol execution framework. The order of the
executions of the parties (which are represented as the interactive Turing machines) are
provided in a more structured way. In the original Universal Composition-security frame-
work [Can05], a centralized mapping controls the order of the execution of the parties
while in this model, the order of the execution of the parties only depends on the code
of the parties. More precisely, in this model, the last activated party determines which
party is going to be activated next. This is not always the case in the original Universal
Composition-security framework [Kus06]. The advantage of this is that it can simplifies
the proof of the security of the protocols.
14
3 Cryptographic games
3.1 General cryptographic games
Usually, the security of some cryptographic primitives can be represented in terms of
using an attack game. There are usually two players of the game: the adversary and the
challenger [BR04]. The basic model is presented in [BR04] and the idea is as follows: we
represent the attack game G as a set of programs where each program can be written in
different programming languages. There is also a common set of static variables and global
variables for each program. Consider the following game G with the adversary A: A can
run game G by calling out to the provided programs (see figure 3)
Figure 3: A simple cryptographic game G with the adversary A. Source:[BR04]
The game G in the above figure is represented by the box which surrounds A. G consists
of several programs such as Initialize, P1,    , Pn and Finalize. A then receives an input
from the game. It produces the output after interacting with its oracle P1,    , Pn. The
result of the game is determined by the Finalize program.
Usually, the cryptographic game is formulated as a probability space because both
the adversary and the challenger are the probabilistic processes which can interact with
each other [Sho04]. Usually the definition of the security is represented in terms of some
particular event E . A cryptographic primitive is then considered to be secure if for any
efficient adversary (means the adversary runs in polynomial time), the probability that the
event E happens is negligibly close to certain target probability. Usually it is 0 or 0.5, or
the probability of some other event T such that the same adversary is playing some other
attack game with a different challenger [Sho04].
15
3.2 The commitment games
Many recent work [CF01, BDD+06] on the impossibility are based on the commitment
scheme. Therefore we are going to talk about the commitment scheme in general first and
the corresponding hiding game and binding game.
3.2.1 The commitment scheme
One of the most commonly used cryptographic primitives is the commitment scheme. It
is the useful construction block in many cryptographic protocols like the Zero-Knowledge
protocols, electronic commerce, etc [Dam99, GMW91, BCC88, Dam90]. The idea behind
it is as the follows: a digital equivalent of a sealed envelope which contains a value x is
provided by a party called the committer. The committer then sends this envelope to
another party called the receiver. After the envelope is sent, the value inside can not be
changed by the committer. The receiver can not get any information about x from the
envelope until the committer asks the receiver to open the envelope. The value x can be
recovered fully when both two parties agree with each other [CF01]. Informally we say
that a good commitment scheme should have the following two properties [Dam99]:
¥ The commitment can not reveal any information about the original message.
¥ The decommitment can be verified in order to determine the relationship between
the commitment and the original message.
We refer the first property to the hiding property and the second property to the binding
property. We will discuss them later.
We use a simple model presented in [Dam99] to describe the syntax of a two-party
commitment protocol. The two parties are P and V . There are the following three steps
corresponding to the protocol execution.
1. P chooses a message m and then writes down m on a piece of paper. After that he
puts the paper into a sealed envelope.
2. P then sends the envelope to V .
3. P can provide V with a method to open the envelope whenever he wants.
More precisely, we say that the commitment scheme can be divided into two phases,
the commit phase and the decommit phase:
16
¥ The commit phase:
Ð The sender selects a message m and then run some algorithm on m to produce
a commitment on m: c and its decommit information: d.
Ð The sender may send this tuple (c, d,m) to the receiver afterwards.
¥ The decommit phase:
Ð The decommitment is achieved by releasing the decommitment value d.
Ð The receiver then can verify if the message m matches the commitment c by
using a verification process: ? = verify(c, d,m):
? If the commitment c matches the message m then output ? = 1.
? If the commitment c does not match the message m then output ? = 0 .
As we described above, there should be two properties for a good commitment scheme.
More precisely, using our simple protocol model above, we can have the following descrip-
tions for the two properties [Dam99]:
¥ There is no way for V to tell about what is inside the envelope before P provides
a method to open it. This property is called hiding property. In other words, we
say that it is impossible to determine the committed message m until decommit it.
There are two types of the hiding property:
Ð computational hiding : meaning V is polynomially bounded and it is impossible
for V to determine the message inside the envelope. In other words, there is no
efficient way to determine the message.
Ð perfectly hiding : meaning V has an infinite computing power and it is still not
possible for V to determine the message inside the envelope. More formally, it
requires the distributions of the commitment on all the messages to be the same
and therefore the commitment reveals no information about the message.
¥ After sending out the envelope, P can not change anything inside it. Therefore, we
can know that what is recovered is actually the message which P chose at the first
time after the envelope is opened. This property is called binding property. In other
words, we say that it is impossible to have two different messages with the same
commitment c. Similarly, there are two types of the binding property:
17
Ð computational binding : meaning P is polynomially bounded and it is impossible
for P to change the committed value after sending it away. In other words, the
chance of having the two different messages with the same commitment value
is small.
Ð perfectly binding : meaning P has an infinite computing power and it is still
impossible for P to change the committed value after sending it away. In other
words, the probability of having the two different messages with the same com-
mitment value is exactly 0.
General, there are two distinct basic flavors of commitment scheme have been formal-
ized. One is called the unconditionally secret commitment protocols and another one is
called the unconditionally binding commitment protocols [CF01]. However, it turns out
that it is inadequate to have the basic definitions in some situations while there are some
stronger variants which can allow the secure composition of the commitment protocols
in a way both calling the protocol and using other invocations of the protocol. The ex-
amples are the chameleon commitments [BCC88], the trapdoor commitments [FS90], the
equivocable commitments [Bea96] and non-malleable commitments [DDN91].
3.2.2 The commitment games
We are now going to present two games of the commitment scheme, corresponding to its
hiding property and binding property. These two games follow the standard description of
the commitment scheme like [Dam99, BCC88, Nao89]. We are going to present the more
general hiding game and binding game in the later section.
The hiding game for commitment scheme We give a hinding game for the commit-
ment scheme as follows (see figure 4): there are two parties here: the adversary A and
the challenger C. The challenger C has the access to the commit oracle. The adversary A
sends two messages (m0,m1) to the challenger C first. Then C will select a bit b from {0, 1}
in random and then send mb to the commit oracle. The oracle will commit the message
mb and send the commitment of message c along with the decommitment information d
to C. Then C will parse the pair (c, d) to A and then A will output b?. The adversary A
wins the game if the probability of its output b? = b is significantly better than 0.5 (the
probability of randomly guessing by tossing a coin).
18
A C
-
ff
(c, d)
-
?
-
ff
(c, d)
commit
(m0,m1)
(b?)
b
R
?? {0, 1} (c, d)? commit(mb)
(mb)
[b = b?]
Figure 4: The hinding game for commitment scheme.
A C
-
-
(c, d?,m?)
?
-
ff
-
ff
(c, d?,m?)
verify
(c, d,m)
(c, d,m)
?? decommit(c, d,m)
?? ? decommit(c, d?,m?)
?
[m 6= m? ? ? = ?? = 1]
??
Figure 5: The binding game for commitment scheme.
19
The binding game for commitment scheme We give a binding game for the commit-
ment scheme as follows (see figure 5): similarly there are two parties here, the adversary
A and the challenger C. This time the challenger C has the access to the verify ora-
cle to check if the message matches the commitment. The adversary A sends two tuple
including two messages m and m? and their corresponding commitment and decommit-
ment messages (c, d) and (c?, d?) to the challenger C. Then C will use the verify oracle to
check the commitment and decommitment information. The adversary A wins the game if
[m 6= m? ? ? = ?? = 1]. In other words, adversary A produces two different valid messages
with the same commitment value.
20
4 Cryptographic games and Universal Composition
Both the Universal Composition-security framework and the cryptographic games can pro-
vide the methods to define the cryptographic task of certain properties in a way that com-
plement each other. The UC approach is useful since the composable notions of security
can be implied by the indistinguishability property of an ideal functionality. However the
complexity of the analysis may increase. On the other hand, the game based definition
is simpler and easier to analyze in terms of the computational complexity arguments.
The problem is that if there is a paradigm which can satisfy one game specification,
it is not clear what the response of such a paradigm to the unexpected interactions of
that game is. There are many work on the relationship between these two approaches
[CF01, BDD+06, CHK+05]. We are going to introduce a work on the commitment scheme
[CF01]. Then we will use a methodology presented in [GKZ10] to show how to derive the
canonical ideal functionalities from the games. After that we may introduce our work on
the general hiding game and general binding game.
4.1 The commitment functionalities
We pick three typical examples presented in [CF01].
4.1.1 The common reference string (CRS) model
There is a high security requirement for the commitment scheme protocol [CF01]. Canetti
et al [CF01] proved that there exists no Universal Composition commitment protocol which
only has the committer and the receiver in the standard computational model (without
using setup assumptions). However, things are much better in the common reference string
(CRS) model. The common reference string (CRS) model is a general form of the common
random string (CRT) model. In CRS model, there is a common string crs which is chosen
according to some distribution D ahead of time. crs should be available to all parties
involved in the protocol execution before any interactions start.
The CRS model can be referred as a composition model, which has ideal access to a
functionality FCRS. FCRS can be parameterized by a distribution D (see figure 6) [CF01]
.
The following two properties of the CRS model using this formalization are presented
in [CF01]:
21
Functionality FCRS
FCRS is parameterized by a distribution D and it proceeds as follows:
1. When activated on input (value, sid) for the first time, a value d
R
?? D is chosen and
d is sent back to the activating party. In each other activation, d is returned to the
activating party.
Figure 6: The CRS functionality. Source: [CF01]
1. The parties have access to a common public string which is chosen in advance ac-
cording to some distribution D in the real life model of computation. D is is specified
by the parties running the protocol.
2. The random string is not used anywhere in the ideal process for some functionality.
Therefore an adversary which play the role of FCRS may be simulated in order to run
the ideal process adversary. In other words, the ideal process adversary can chose
whatever common string it likes.
4.1.2 The ideal functionality for a single commitment
Functionality FCOM
FCOM is running with parties P1, . . . , Pn and an adversary S and it proceeds as follows:
1. Upon receiving a value (commit, sid, Pi, Pj, b) from Pi. Record the value b and send
the message (recepit, sid, Pi, Pj) to Pj and S. Ignore any subsequent commit mes-
sages.
2. Upon receiving a value (open, sid, Pi, Pj) from Pi proceeds as follows:
¥ If some value b was previously recorded, send the message (open, sid, Pi, Pj, b)
to Pj and S. Halt.
¥ Halt otherwise.
Figure 7: The ideal functionality for a single commitment. Source: [CF01]
We present a functionality FCOM which can manage a single commitment and decom-
mitment process [CF01]. As shown in figure 7, the commitment phase can be modeled as
follows: FCOM receives the value (commit, sid, Pi, Pj, b) from the committer Pi where sid
is the session identifier utilized to differentiate different versions of FCOM , Pj represents
22
the receiver and b is the value which is committed to. Then FCOM delivers the message
(receipt, sid, Pi, Pj) to the receiver Pj and the adversary S in order to tell Pj and S that
a value has been committed to with the session identifier sid by the committer Pi. Then
the committer Pi may send a value (open, sid, Pi, Pj) to FCOM in order to initiate the
decommitment phase. FCOM may send the (open, sid, Pi, Pj, b) to the receiver Pj and the
adversary S in response [CF01].
4.1.3 The ideal functionality for multiple commitments
Functionality FMCOM
FMCOM is running with parties P1, . . . , Pn and an adversary S and it proceeds as follows:
1. Upon receiving a value (commit, sid, cid, Pi, Pj, b) from Pi. Record the tuple
(cid, Pi, Pj, b) and send the message (recepit, sid, cid, Pi, Pj) to Pj and S. Ignore
any subsequent (commit, sid, cid, Pi, Pj, . . .) values.
2. Upon receiving a value (open, sid, cid, Pi, Pj) from Pi proceeds as follows:
¥ If the tuple (cid, Pi, Pj, b) was previously recorded, send the message
(open, sid, cid, Pi, Pj, b) to Pj and S.
¥ Do nothing otherwise.
Figure 8: The ideal functionality for multiple commitments. Source: [CF01]
We present a functionality FMCOM which handles multiple commitment and decommit-
ment processes [CF01]. As shown in figure 8, FMCOM follows the similar operation from
FCOM . FMCOM uses another identifier cid which represents the commitment ID as well as
using the session identifier sid. cid can help to identify different commitments which occur
in the same single run of FMCOM . Therefore, cid, the identifier of the committer Pi and
the identifier for the receiver Pj need to be recorded for a single commitment value. It is
not allowed for the two commitments with the same committer and receiver to have the
same cid. The requests commit and open can come with different orders (i.e. they do not
need to follow the specified order such as (commit, open)). Also for the same receiver, a
commitment is allowed to open many times by the committer [CF01].
23
4.2 The Universal Composition commitment protocol
The recent study [CF01] developed a new way to quantify the security of the commitment
protocols. It can guarantee the hiding property and the binding property of the com-
mitment protocols even when they are composed with an arbitrary set of protocols in a
concurrent way. We call these protocols the Universal Composition commitment protocol.
More precisely, we apply the Universal Composition-security framework to the commit-
ment protocols as follows: the functionality FCOM we described above should capture
any expected behavior of the ideal commitment service. Then the Universal Composi-
tion commitment protocol are the protocols that can make secure realization of the ideal
functionality FCOM . Therefore we can have the following definition [CF01].
Definition 4.1. A protocol is a universally composable (UC) commitment protocol if it
securely realizes functionality FCOM . If the protocol securely realizes the functionality
FMCOM then it is called a reusable-CRS UC commitment protocol.
Based on the Universal Composition theorem, we can see that no matter what tasks the
calling protocol is involved in, the run of a universally composable commitment protocol
pi is indistinguishable from its interaction with the similar quantity of copies of the ideal
functionality FCOM .
4.3 Derive the canonical ideal functionality from the crypto-
graphic games
We now use the methodology presented in [GKZ10] to derive the canonical ideal function-
alities from the game conditions.
4.3.1 The communication languages
We now present two communication languages for the ideal functionalities. One is called
party-functionality language and the other one is called the extended language of the func-
tionality. For the convenience of our presentation, we assume the functionality is only
able to perform a finite number of different actions. For each action there should be an
ordered list of the parties and some input. According to the way of how the functionality
is instructed (i.e. by the adversary or by the parties), the actions can be parameterized
and split into two distinct languages. The corruption of the parties by the adversary is not
considered here in order to simplify the results.
24
Party-functionality language
¥ A party can ask a functionality to perform an action using a tuple (ACTION,P, x)
where ACTION is the action like encryption, commit, etc, P is the list of parties
involved in the action and x is the input of the action.
¥ For each action the functionality will send a tuple (ACTIONRETURN,P, y) to
some parties in return where ACTIONRETURN is the return action of ACTION
like decryption, decommit, etc, P is the list of parties involved in the action and y
the output of the action.
¥ Therefore the I/O language of the functionality consists of the set of all possible
tuples of above two forms.
¥ We can denote the party-functionality language of a given task T by ?T .
The extended language of the functionality
¥ Each time when the ideal functionality receives s tuple (ACTION,P, x) from a
party, it will send another tuple (LEAKACTION,P, x?) to the adversary where
LEAKACTION is the action of the ideal functionality perform in order to notify
the ideal adversary for every ACTION, P is the list of parties involved in the action
and x? is dependent on x according to the program of the ideal functionality.
¥ Upon receiving such a tuple, an output tuple (INFLACTION,P?, y) will be gener-
ated and sent it back to the ideal functionality by the adversary where INFLACTION
is the communication occurs between the ideal functionality and the ideal adversary,
P? is the list of parties involved in the communication and y is the output value.
¥ Therefore the I/O language of the adversary-functionality language consists of the
set of all possible tuples exchanged during the communication between the adversary
and the ideal functionality.
¥ We call the union of the I/O language of the party-functionality and the I/O language
of the adversary-functionality the extended language of the functionality.
¥ We can denote the extended language of a given task T by ?extT .
25
4.3.2 The canonical functionality of a given cryptographic task
Now we present our canonical functionality of a given cryptographic task. First, we may
make some assumptions regarding the communication of the ideal functionality. There are
two assumptions:
1. For all input tuples (ACTION,P, x) of the functionality, the ideal adversary will be
notified by a tuple (LEAKACTION,P, x?).
2. The return action (ACTIONRETURN,P, y) of the tuple (ACTION,P, x) will be
performed only after the influence tuple (INFLACTION,P?, y) is returned by the
adversary.
There is a common algorithm procedure presented in [GKZ10] to derive the canonical
ideal functionalities. A set of predicates and functions is used to capture the different
operations of the functionalities in a given cryptographic task. The functionality will keep
a record of the messages exchanged with the parties during the protocol execution. It will
also keep a record of which party may be influenced by the adversary. There are two main
functions used in the canonical functionalities, one is called the suppress function and the
other one is called the validate function.
The suppress function
¥ For each input message tuple (ACTION,P, x) of the functionality, the simulator
will be notified by another tuple (LEAKACTION,P, x?) by the adversary.
¥ x? is dependent on the suppress function where x? is x with the symbols in the same
position replaced with Ò?Ó, no matter what value of x is. Ò?Ó is a special character
which does not occur anywhere else in the alphabet of x.
¥ The suppress functionality is independent from the history. It captures the hid-
ing property of a given cryptographic task since it can put the restrictions on the
information can be gained of each message by the adversary.
The validate function
¥ For each influence tuple (INFLACTION,P?, y) of the functionality, the output tuple
(ACTIONRETURN,P?, y?) will be generated and sent back to the corresponding
parties.
26
¥ The validate function will check the validity of the output at the time of its execution
for the functionality. More precisely, when a new message is added to the history of
the functionality, it can check if the resulting history is still valid in terms of some
restrictions.
¥ The valid function captures the binding property of a given cryptographic task since
it can guarantee some invalid events will not happen during the protocol execution.
Additional, three more functions are needed in order to let the functionality work
accurately. These three functions are The public output predicate (POt), The secret output
predicate (SOt) and The well formatness predicate (WFt).
The public output predicate It is used to make sure that the adversary can gain some
information about the internal state of the functionality in order to enable the informed
influence of the adversary.
The secret output predicate It is used to keep the output value which is not necessarily
known by the adversary.
The well formatness predicate It is used to check if the order of the actions is sensible
with respect to the ideal functionalities. The unexpected actions are simply ignored.
Now we are ready to present the canonical functionality F suppress,validateT (see figure 9).
4.4 The game satisfaction
A concept such as encryption, bit-commitment or digital signature can be defined using a
game condition. There might more than one possible ideal functionalities corresponding
to each game condition. By using the method describe above, we can get a canonical
functionality.
As an ideal functionality is supposed to be secure because of its construction, therefore
it has to meet the specific requirement of the given game in an information-theoretic way
(the adversary is unbounded) instead of in a computational complexity way (the adversary
is polynomial bounded). We introduce a new notion Ò|=Ó to represent the ÒsatisfyÓ here:
if a functionality F satisfy a game G, we can write it as F |= G. Intuitively, G can be
considered as a game machine which receives the action query from adversary and forward
27
Canonical functionality F suppress,validateT
1. Initially: history := ?, binding := ?.
2. Upon receiving: msg = (ACTION,P,m) from some party Pi:
x? ? suppress(msg),msg? ? (LEAKACTION,P, x?)
¥ if WFt(historyPi ,msg) = 1 then
Ð send (msg?,POt(history,msg)) to the simulator S
Ð history ? history?msg
Ð binding[|history|]? {Pi}
¥ else if WFt(historyPi ,msg) = 0 then ignore msg
3. Upon receiving: msg = (INFLACTION,P, y?) from the simulator S:
infer Pi from the list of parties P where Pi is the first party receives the output
y ? y??SOt(history,msg),msg
? ? (ACTIONRETURN,P, y)
¥ if WFt(historyPi ,msg
?) = 1 then
Ð if validate(history?msg?) = 1 then
? send msg? to Pi
? history ? history?msg?
? binding[k]? binding[k] ? {Pi} for all 1 ² k ² |history|
Ð else if validate(history?msg?) = 0 then send an error message to Pi and
halt
¥ else if WFt(historyPi ,msg
?) = 0 then ignore msg
Figure 9: Canonical functionality F suppress,validateT Source: [GKZ10]
it to the functionality. It may select the message sent by the adversary and send it to
the functionality or it may just forward all the messages sent by the adversary to the
functionality. After the functionality perform the required action, the return value will
be sent to G and G will forward it to the adversary. There might be several iterations of
such interactions during the game execution. At the end of the game, a predicate in G will
determine whether the adversary wins the game or not. The predicate will output 1 if the
adversary wins and 0 otherwise.
We have the following definition for the game satisfaction:
Definition 4.2. Given a game G and an ideal functionality F , we say that F |= G if ?
28
simulator S that F uses, the adversary A can not win the game G no matter what S does.
Note for the above definition, the probability of the adversary A winning the game G
is exactly 0. For instance consider the commitment games we described previously, the
probability of the adversary outputting the correct bit b is exactly 0.5 for the hiding game
and the probability of the adversary producing two different valid messages with the same
commitment is exactly 0 for the binding game.
4.5 The general hiding game and the general binding game
We give a description of protocols that during their operation it allows actions on the value
stored in a given variable. We assume that each variable is a single bit and that there are
countable many of them. We represent each variable with a position in the bit string inputs
of the parties. For instance if v is the input of a party pi then vj will be the value of the
jth variable.
We will use the framework presented in [GKZ10] and that is an extension of the UC-
framework [Can05]. Hiding information is expressed through a function suppress that
erases any information in the communications between parties that we want to hide from
the public view. And Binding properties are expressed in this framework through a pred-
icate validate that validates only specific traces of communication between parties. Note
we do not consider any setup assumptions for our work.
4.5.1 Hiding a variable
We first consider the hiding property of the value of a specific variable. The functionality
Fhiding(ACTION,j) that hides the j
th variable is defined as follows.
Definition 4.3. The functionality Fhiding(ACTION,j) uses two functions: the validate func-
tion and the suppress function.
¥ For the validate function it returns 1 for every message.
¥ For the suppress function we consider the messages of form msg = (ACTION,P, x).
Ð For every action of such messages, the suppress function returns x? where
x?i =
??
?
xi if i 6= j
(?) if i = j
29
The general hiding game looks as follows (see figure 10):
-
A
(ACTIONA,P, x0, x1)
G F
-
ff
(ACTIONA,P, xb)
(ACTIONRETURNA,P, y)
? ?
S
ff
(ACTIONRETURNA,P, y)
-
(b?)
b
R
?? {0, 1}
[b = b?]
Figure 10: The hiding game
The general hiding game has three parties, the adversary A, the game G and the
functionality F . In the beginning of the game, the adversary A sends a query ACTIONA
and two messages x0 and x1 to the game G along with the list of the parties P involved in
the action. Then G may send another query ACTIONA to the functionality F along with
a message xb where bit b is randomly selected from {0,1}. After that F will perform the
required action and give the return value y as the answer to the query back to G. G will
simply forward y to A. After A gets y, A will output a bit b?. The adversary A wins the
game if the probability of its output b? = b is different from 0.5.
The adversaryÕs goal for the general hiding game is to determine which of the two
messages has been used to perform the required action on. In our hiding game, if any
information about the message is leaked to the return value of the required action, then the
adversary can use that information to determine the message. Intuitively, our description
captures the security requirement of the general hiding game and therefore we say it is a
good hiding description.
Now we are ready to state our first theorem. It relates the ideal functionality to the
general hiding game.
Theorem 4.1. If F is syntactically hiding xj, then F |= G
(ACTION,j)
hiding .
30
Proof. According to the definition of the functionality Fhiding(ACTION,j) above, the informa-
tion about the jth variable is replaced with a special character which is not appeared in the
alphabet of x. This means the information is erased thus no information about the variable
is leaked to the ideal world adversary. Therefore F hides xj in a information-theoretic way.
As F hides xj in a information-theoretic way and no information about the variable
is leaked to the ideal world adversary, therefore no information about x is contained in
the return value y of the action ACTIONA and as G
(ACTION,j)
hiding forward y to A, A will
therefore get no information about x. Thus the probability of adversary A winning the
game G
(ACTION,j)
hiding is exactly 0.5 (it is the probability of the adversary A randomly guessing
a bit from {0,1}).
4.5.2 Binding a variable
We now consider the binding property of the value of a specific variable. A game binding
a variable would allow a party to perform the following actions in the specified order:
¥ Perform an action ACTION (for instance commit) on the value of the variable j at
a given message m.
¥ Perform the return action ACTIONRETURN (for instance decommit) in order to
reveal the value m?j and accept whenever m
?
j = mj.
We observe that the event where the contents of the jth variable is changed and the
message is accepted as valid is the event that breaks the security of the protocol.
Thus we derive the following bad language. The bad language corresponds to the event
which the adversary can win a given cryptographic game. In our case, it contains the
strings for which the functionality will accept and return 1.
Bbinding(xj) =
???????????
??????????
w
???????????????
w = (ACTIONA,P, sid, x)
(ACTIONRETURNA,P, sid, y)
(ACTIONB,P, sid, x
?, y?)
(ACTIONRETURNB,P, sid, ?)
such that
(xj 6= x
?
j) ? (yj = y
?
j) ? (? = 1)
???????????
??????????
The general binding game looks as follows (see figure 11):
Similarly, the binding game has three parties, the adversary A, the game G and the
functionality F . In the beginning of the game, the adversary A sends a query ACTIONA
31
-A
(ACTIONA,P, x)
-
(ACTIONB,P, x
?, y?) G F
-
ff
-
ff
(ACTIONA,P, x)
(ACTIONRETURNA,P, y)
?
[(x 6= x?) ? (y = y?) ? (? = 1)]
(ACTIONRETURNA,P, y)
ff
ff
(ACTIONRETURNB,P, ?)
(ACTIONB,P, x
?, y?)
(ACTIONRETURNB,P, ?)
?
S
Figure 11: The binding game
and one message x to the game G along with the list of the parties P involved in the
action. Then G will simply forward this query to the functionality F . F will perform
such an action ACTIONA and give the return value y of ACTIONA back to G. Then G
will forward y to A. After A gets y, it will send another query ACTIONB and another
message x? along with the corresponding return value y? to G. Again, G may also forward
this query to F . Then F will perform the action ACTIONB and check the validity of
the return value y?. If y? is valid, F will output 1, otherwise F will output 0. This result
is stored in a variable ? and F may send ? back to G. G simply forward ? to A. The
adversary A wins the game if the following conditions holds:[(x 6= x?)? (y = y?)? (? = 1)].
In other words, A produces two valid messages with the same return value.
The adversaryÕs goal for the general binding game is to produce two different messages
with the same return value for the required action. In our binding game, if the events:
¥ (ACTIONA,P, x)
¥ (ACTIONRETURNA,P, y)
¥ (ACTIONB,P, x, y)
¥ (ACTIONRETURNB,P, ?)
32
happen in a sequence, then it corresponds to the situation when the adversary can produce
such two messages. Intuitively, our description captures the security requirement of the
general binding game and therefore we say it is a good binding description.
In order to define the canonical functionality which can capture the general binding
game G
(ACTION,j)
Binding , we need to show that the bad language Bbinding(xj) described previ-
ously is polynomial-time decidable. Therefore, we can define our canonical function-
ality FBinding(ACTION,j) which captures G
(ACTION,j)
Binding by requiring the validate() function
validate(w) = 0 if and only if w ? Bbinding(xj) where the decider D for Bbinding(xj) is given.
In other words, the decider D can be simulated by using validate(), the functionality halts
when the decider D accepts.
More precisely, we have the following definition:
Definition 4.4. Consider the whole events [A1, A2, A3, . . . , AN ] during the execution of
the game G
(ACTION,j)
Binding . 6? i, j, k, l such that
¥ Ai = (ACTIONA,P, sid, x)
¥ Aj = (ACTIONRETURNA,P, sid, y)
¥ Ak = (ACTIONB,P, sid, x
?, y?)
¥ Al = (ACTIONRETURNB,P, sid, ?)
and the functionality accepts these events in order ?i < j < k < l.
Now we are ready to state our second theorem. It relates the ideal functionality to the
general binding game.
Theorem 4.2. If F is syntactically binding xj, then F |= G
(ACTION,j)
binding .
Proof. According to the definition above, the functionality F will not accept the four
events in order. Those four events are corresponding to the events in the bad language
Bbinding(xj). Therefore the functionality F will not accept any string which is in the bad
language Bbinding(xj). Thus, F binds xj in a information-theoretic way.
As the functionality F will not accept anything in Bbinding(xj), the adversary A can
not produce two messages such that [(x 6= x?) ? (y = y?) ? (? = 1)]. In other words, the
adversary A can not produce two valid messages with the same return value. Thus, the
probability of adversary A winning the game G
(ACTION,j)
binding is exactly 0.
33
5 The impossibility
Recently, there has been a lot of work on the negative results about realizing ideal func-
tionalities. We call these results the impossibility result. As we described previously, the
ideal functionalities of the commitment scheme are used as a common example. One basic
example is that Canetti and Fishlin shows that a particular commitment ideal function-
ality (FCOM) is not realizable [CF01]. Based on that, Datta et al [BDD
+06] proved no
commitment ideal functionality can be realizable. There are also other variants of the
impossibility result, for instance Canetti shows a set of ideal functionalities for ideal coin
tossing and zero knowledge are is not realizable [Can05]. And Canetti et al [CHK+05] also
shows a particular functionality for password-based key exchange protocol is not realizable.
Our work is based on the previous result [CF01, BDD+06]. It is a more general im-
possibility result. We are going to introduce some previous work first and then we may
introduce our result. Note we do not consider any setup assumptions (for instance using a
trusted third party) for the rest of the presentation.
5.1 The impossibility of UC commitment in the plain model
In recent work [CF01], it shows that there exists no Universally Composable commitment
protocol in the plain model (with no access to some ideal functionality). The following
definitions are presented in [CF01].
Definition 5.1. Protocol pi between n parties P1, . . . , Pn is a bilateral protocol if there are
only two parties interacting with each other and the rest parties stay idle.
Definition 5.2. A bilateral commitment protocol pi is a terminating protocol if the com-
mitment of the honest sender Pi can be accepted by the honest receiver Pj and Pj will
output (receipt, sid, Pi, Pj) with non-negligible probability. Moreover, if Pj receives a valid
decommitment for a given message m and sid from Pi, it will output (open, sid, Pi, Pj,m)
with non-negligible probability.
The following theorem is presented in [CF01].
Theorem 5.1. The bilateral, terminating protocol pi which can securely realize functionality
FCOM does not exist in the plain model. This holds even if the ideal-model adversary S is
allowed to depend on the environment machine Z.
We omit the proof here.
34
5.2 The impossibility of the bit-commitment
Datta et al [BDD+06] shows that there is no realizable ideal functionalities for bit-commitment.
This is a generalized version of the result we described above. The following theorem is
presented in [BDD+06]
Theorem 5.2. If F is an ideal functionality for bilateral bit commitment, then there exits
no terminating real protocol P which securely realizes F .
Another more general result is presented in the same paper [BDD+06], it says given a
functionality G and a protocol P which uses G to construct a perfectly hiding and perfectly
binding bit-commitment protocol, then G is not realizable.
Definition 5.3. Protocol P is a G-hybrid protocol for a primitive if it is an implementation
of the primitiveÕs interface without using any trusted third parties where G is a given
functionality. The exception is that P can make calls to the functionality GÕs interface
using the trusted third party.
Formally we have the following theorem presented in [BDD+06]:
Theorem 5.3. If G is a functionality and P is a terminating G-hybrid protocol for bit-
commitment. The protocol can provide perfectly hiding and perfectly binding with a very
high probability. Then G is not realizable.
It is not difficult to find that the ideal functionality F for bit-commitment consists of
the protocol P and the functionality G. Therefore, if G is realizable, F is also realizable.
Thus, all the primitives which can be used to construct a bit-commitment protocol are not
expected to be realizable as functionalities [BDD+06]. This is quite useful in the study of
the concepts like symmetric encryption [BP04] and group signatures [BMW03].
5.3 The impossibility of Universally Composable password-based
key exchange
Another impossibility result is stated in [CHK+05]. Generally, the protocols for password-
based key exchange can enable two parties to generate a high quality secret when the
adversary can take the complete control of their communication network [KV10, CHK+05].
In their work [CHK+05], they define an ideal functionality FpwKE for the password-based
key exchange protocol as follows (see figure 12):
35
The ideal functionality FpwKE
The functionality FpwKE is parameterized by using a security parameter k. The
interaction between FpwKE and the adversary S consists of the following three queries:
1. Upon receiving a query (newsession, sid, Pi, Pj, pw, role) from party Pi:
¥ Send (newsession, sid, Pi, Pj, role) to adversary S:
Ð If it is the first newsession query, then record (Pi, Pj, pw) and also label
the record fresh.
Ð If it is the second newsession query and also there is a previous record
(Pi, Pj, pw
?), then record (Pi, Pj, pw) and also label the record fresh.
2. Upon receiving a query (testpassword, sid, Pi, pw
?) from the adversary S:
¥ If there is a previous record (Pi, Pj, pw) and the record is fresh then:
Ð if pw = pw? then label the record compromised and output 1 to adversary
S.
Ð if pw 6= pw? then label the record interrupted and output 0 to adversary S.
3. Upon receiving a query (newkey, sid, Pi, sk) from the adversary S and |sk|=
k:
¥ If there is a previous record (Pi, Pj, pw) and it is the first newkey query for Pi
then:
Ð If the record is compromised or any of Pi and Pj is corrupted, then output
(sid, sk) to Pi.
Ð If the record is fresh and also there is a previous record (Pj, Pi, pw
?) with
pw = pw? and the secret key sk? sent to Pj and (Pj, Pi, pw) was fresh, then
output (sid, sk?) to Pi.
Ð Pick a new random secret key sk? of the length k and output (sid, sk?) to
Pi.
¥ Label the record completed.
Figure 12: The ideal functionality FpwKE for password-based key exchange protocol
36
In the work [CHK+05], it has been proved that the above ideal functionality for the
password-based key exchange protocol is not realizable. The following theorem is presented
in [CHK+05]:
Theorem 5.4. There exists no non-trivial protocol pi which securely realizes the FpwKE in
the plain model.
The idea behind their proof is proof by contradiction: they assume there is an envi-
ronment machine Z which can run the code of the honest parties internally. According to
the UC-security framework, for anything that the simulator S can do for the environment
machine Z, there exists another environment machine Z ? which can do the same thing to
the honest party in the real protocol. Particularly, the simulator S must set the session key
of the environment machine Z to be the same as the session key of the ideal functionality
in order to have a success simulation. In this case, the another environment machine Z ?
can also do the same thing which contradicts the security requirement for the protocol.
5.4 Our impossibility work
Now we are ready to state our main theorem. Before that, we may introduce two useful
lemmas presented in [BDD+06]. We will give the proof for the first lemma as it is not done
in the original work.
Lemma 5.5. There exits no terminating real protocol P which provides both perfectly
binding and perfectly hiding and is correct with a high probability.
Proof. Assume protocol P is a two-party terminating real protocol and it provides per-
fectly hiding. For any given message x we represent an unbounded adversary AÕs view as
V iew(A(x,R)) where R is some randomness A uses.
Therefore for any two messages x1 and x2 of the same length l, we should have
Prob[V iew(A(x1,R)) = vi] = Prob[V iew(A(x2,R)) = vi] where vi is a particular view
for the unbounded adversary A. In other words, given a view vi there are two different
messages corresponding to it.
Now consider the binding game. The unbounded adversary A first fixs the randomness
R and then chooses a view vj. According to the above arguments, A can find two different
messages since it has an infinite computing power. Both the two messages are legal and
therefore the adversary A wins the binding game. Thus, it is not possible to achieve
perfectly binding.
37
Lemma 5.6. If P is a terminating real protocol which securely realizes F , then P is correct
with a high probability.
The proof of this lemma is presented in [BDD+06] and we omit it here.
Now we can state our main theorem. It says that given a functionality which satisfies
both general hiding game and general binding game, this functionality is not realizable.
Recall that we do not consider any setup assumptions here.
Theorem 5.7. If F |= G
(ACTION,j)
hiding and F |= G
(ACTION,j)
binding , then F is not realizable.
Our proof is based on [BDD+06]. The main idea is proof by contradiction. It is also
the same idea as many other impossibility proofs: given a real protocol P which securely
realizes the ideal functionality F , we can construct another real protocol Q which is also a
correct implementation. On the other hand, principally, all the calls to Q can be handled
by using the copies of P . Because Q uses the ideal functionality F internally to perform
the requred actions and F satisfies both the general hiding game and the gereral binding
game, as a result, Q can provide both perfectly hiding and perfectly binding at the same
time and it contradicts the first lemma (lemma 5.5).
Proof. Assume protocol P is a terminating real protocol which securely realizes the ideal
functionality F . Therefore there exists a simulator S which can replace all the calls to P
with the calls to S associated with F for any configuration making use of P . The real
configuration should be indistinguishable from the ideal configuration.
Therefore we consider the real configuration as follows: the environment ?1 is the
honest responder. At the beginning, it chooses a message x and then sends a query (for
instance ACTIONA) along with x to the initiator. Then the initiator may use a copy
of the implementation PI in order to perform the required action. The adversary just
simply forwards the messages to ?1 in order to corrupt the responder. Then ?1 may use
a copy of the real implementation PR in order to play its role as the responder. At the
end of the action, ?1 may instruct the initiator to perform the return action (for instance
ACTIONRETURNA). Then ?1 will check if the return value of the action is valid.
To make it more clearly, we can have the following figure for the real configuration and
the ideal configuration (see figure 13).
The left hand side is the real configuration and the right hand side is the ideal con-
figuration. Consider the ideal configuration first, the initiator uses the ideal functionality
F while the environment ?1 uses the real implementation PR. There exists a simulator
S since it can translate the messages of the ideal functionalities in a way that the real
38
?1 ?1
PR PR
I1 I2PI F
S
?=
Figure 13: The first step of the configuration [BDD+06]
implementation PR can understand. S sit between the ideal functionality F and the real
implementation PR and it is connected to the ideal functionality F using two interfaces
of F . As we assumed before, protocol P securely realizes the ideal functionality F , there-
fore the real configuration should be indistinguishable from the ideal configuration. Since
adversary does nothing but only forwarding the messages, according to the second lemma
above (lemma 5.6), the real configuration is a correct implementation with a high proba-
bility. We denote the conjunction of the ideal functionality F and the simulator S by a
system Q and Q is a correct implementation.
Now we can consider another real configuration as shown in the following figure (see
figure 14).
This time the responder is honest but the initiator is corrupted. The initiator now acts
as a forwarder. After the initiator is corrupted, the adversary does not do anything. This
time the environment ?2 plays as the initiator directly and it chooses a message x at the
beginning. ?2 will use the system Q instead of using the protocol P in order to run as
the initiator. Then ?2 may send a query to the functionality along with the message x
to the functionality in order to perform some action (for instance ACTIONA). x can be
translated into some other form which is suitable for the copy of the real implementation
PR by the simulator S. After the action is performed, the responder should send a receipt
to ?2 before giving the return value (for instance ACTIONRETURNA) back. Then it
39
?2 ?2
F F
S S
PR R2 R2F
S ?
?=
Figure 14: The second step of the configuration [BDD+06]
should send the message it believe the initiator has performed the action on that to ?2. ?2
will check if the message is the same as the original one.
For the second part of the configuration, a simulator S ? should sit between the system
Q and the ideal functionality F . The system Q can be considered as the initiator running
the protocol P and according to the second lemma (lemma 5.6), we can know that this
real configuration is also a correct implementation with a high probability. We denote the
conjunction of the ideal functionality F and the simulator S ? by the system Q?. Therefore
Q? must play as the role of the responder running the protocol P correctly. In other words,
Q? is also a correct implementation.
In the ideal configuration, all the messages go through the two simulators S and S ?.
As a result, we have an implementation of a real protocol. System Q plays the role of
the initiator and system Q? plays the role of the responder. From the above arguments
we can see that Q|Q? is a correct implementation. Also, because of the way of using the
ideal functionality F , the implementation Q|Q? can provide both perfectly binding and
perfectly hiding at the same time with a high probability. Clearly it contradicts our first
lemma (lemma 5.5).
As we described previously, our result is more general than the result presented in
40
[CF01] and [BDD+06]. First, Canetti and Fischlin [CF01] focus on a specific ideal func-
tionality for the commitment games, they show that specific ideal functionality is not
realizable. Datta [BDD+06] obtain a more general result since they do not focus on the
specific ideal functionality but to look at all the ideal functionalities that specific for the
particular games (the commitment games), they show that all the ideal functionalities for
the commitment games are not realizable. Our result is more general because we do not
focus on the specific games but to look at the class of the games. The general hiding game
and the general binding game we consider do not stop the adversary from interacting with
the other parts of the functionality. We show that all the ideal functionalities for those
two classes of games are not realizable.
41
6 Conclusion
We first review a new framework for the specification of the cryptographic task: the Uni-
versal Composition-security framework and the cryptographic games. Then we give an
example of a common cryptographic game: the commitment game. Based on that, we
review the relationship between the game conditions and the ideal functionalities. We
give a precise definition about the game satisfaction and the descriptions of the general
hiding game and the general binding game. Based on that, we prove two theorems. The
first theorem says if the functionality is hiding the variable, then this functionality satis-
fies the general hiding game while the second theorem says if the functionality is binding
the variable, then this functionality satisfies the general binding game. Then we review
some recent impossibility work and based on that, we proved a more general result: the
functionality for the general hiding and general binding game is not realizable.
For this work, we do not consider the setup assumptions. The setup assumptions can
be the trusted third party, the random oracles, the common reference strings and so on.
Our theorem holds without using thee setup assumptions. However, as stated in some work
like [CF01], some ideal functionalities of the bit-commitment can be realized by using a
common reference string model. We hope we can develop our work by using some setup
assumptions in the future.
There are also some other modifications on providing some other forms of the compos-
ability. One possible direction is to have a more relax requirement of the ideal function-
alities. As presented in [Mau02], we can replace information-theoretic equivalence with
the indistinguishability of random systems. Another possible direction is a modification of
the original Universal Composition-security framework like [PS04, PS05]. Also as stated
in [BDD+06], it would be quite useful to develop some methods in order to prove some
conditional forms of composability.
42
References
[AG97] Mart«õn Abadi and Andrew D. Gordon. A calculus for cryptographic protocols:
the spi calculus. In Proceedings of the 4th ACM conference on Computer and
communications security, CCS Õ97, pages 36Ð47, New York, NY, USA, 1997.
ACM.
[BBM00] Mihir Bellare, Alexandra Boldyreva, and Silvio Micali. Public-key encryption
in a multi-user setting: security proofs and improvements. In Proceedings of the
19th international conference on Theory and application of cryptographic tech-
niques, EUROCRYPTÕ00, pages 259Ð274, Berlin, Heidelberg, 2000. Springer-
Verlag.
[BCC88] Gilles Brassard, David Chaum, and Claude Cre«peau. Minimum disclosure
proofs of knowledge. J. Comput. Syst. Sci., 37:156Ð189, October 1988.
[BDD+06] Michael Backes, Anupam Datta, Ante Derek, John C. Mitchell, Ajith Ra-
manathan, and Andre Scedrov. Games and the impossibility of realizable
ideal functionality. In In theory of cryptography, 3rd theory of cryptography
conference, tcc 2006, volume 3876 of lecture notes in computer science, pages
360Ð379. Springer, 2006.
[Bea91] Donald Beaver. Secure multiparty protocols and zero-knowledge proof sys-
tems tolerating a faulty minority. Journal of Cryptology, 4:75Ð122, 1991.
10.1007/BF00196771.
[Bea96] Donald Beaver. Adaptive zero knowledge and computational equivocation (ex-
tended abstract). In Proceedings of the twenty-eighth annual ACM symposium
on Theory of computing, STOC Õ96, pages 629Ð638, New York, NY, USA, 1996.
ACM.
[BH03] Michael Backes and Dennis Hofheinz. How to break and repair a universally
composable signature functionality. In In ISC 2004, pages 61Ð72. Springer,
2003.
[BMW03] Mihir Bellare, Daniele Micciancio, and Bogdan Warinschi. Foundations of
group signatures: Formal definitions, simplified requirements, and a construc-
tion based on general assumptions, 2003.
43
[BP04] Michael Backes and Birgit Pfitzmann. Symmetric encryption in a simulatable
dolev-yao style cryptographic library. In Proceedings of the 17th IEEE work-
shop on Computer Security Foundations, pages 204Ð, Washington, DC, USA,
2004. IEEE Computer Society.
[BPW04] Michael Backes, Birgit Pfitzmann, and Michael Waidner. A general composi-
tion theorem for secure reactive systems. In TCCÕ04, pages 336Ð354, 2004.
[BR04] M. Bellare and P. Rogaway. The game-playing technique, 2004.
[Can98] Ran Canetti. Security and composition of multi-party cryptographic protocols.
Journal of Cryptology, 13:2000, 1998.
[Can01] R. Canetti. Universally composable security: A new paradigm for crypto-
graphic protocols. In Proceedings of the 42nd IEEE symposium on Founda-
tions of Computer Science, FOCS Õ01, pages 136Ð, Washington, DC, USA,
2001. IEEE Computer Society.
[Can04] Ran Canetti. Universally composable signature, certification, and authentica-
tion. In Proceedings of the 17th IEEE workshop on Computer Security Foun-
dations, pages 219Ð, Washington, DC, USA, 2004. IEEE Computer Society.
[Can05] Ran Canetti. Universally Composable Security: A new paradigm for crypto-
graphic protocols. Technical report, December 2005.
[Can06] Ran Canetti. Security and composition of cryptographic protocols: a tutorial
(part i). SIGACT News, 37:67Ð92, September 2006.
[CF01] Ran Canetti and Marc Fischlin. Universally composable commitments. In Pro-
ceedings of the 21st Annual International Cryptology Conference on Advances
in Cryptology, CRYPTO Õ01, pages 19Ð40, London, UK, 2001. Springer-Verlag.
[CHH+07] Ronald Cramer, Goichiro Hanaoka, Dennis Hofheinz, Hideki Imai, Eike Kiltz,
Rafael Pass, Abhi Shelat, and Vinod Vaikuntanathan. Bounded cca2-secure
encryption. In Proceedings of the Advances in Crypotology 13th international
conference on Theory and application of cryptology and information security,
ASIACRYPTÕ07, pages 502Ð518, Berlin, Heidelberg, 2007. Springer-Verlag.
44
[CHK+05] Ran Canetti, Shai Halevi, Jonathan Katz, Yehuda Lindell, and Phil MacKen-
zie. Universally composable password-based key exchange. In Ronald Cramer,
editor, Advances in Cryptology EUROCRYPT 2005, volume 3494 of Lecture
Notes in Computer Science, pages 557Ð557. Springer Berlin / Heidelberg, 2005.
10.1007/11426639ú24.
[CKL06] Ran Canetti, Eyal Kushilevitz, and Yehuda Lindell. On the limitations of
universally composable two-party computation without set-up assumptions.
J. Cryptol., 19:135Ð167, April 2006.
[Dam90] Ivan Damgûard. On the existence of bit commitment schemes and zero-
knowledge proofs. In Proceedings of the 9th Annual International Cryptology
Conference on Advances in Cryptology, CRYPTO Õ89, pages 17Ð27, London,
UK, UK, 1990. Springer-Verlag.
[Dam99] Ivan Damgûard. Commitment schemes and zero-knowledge protocols. In Lec-
tures on Data Security, Modern Cryptology in Theory and Practice, Sum-
mer School, Aarhus, Denmark, July 1998, pages 63Ð86, London, UK, 1999.
Springer-Verlag.
[DDN91] Danny Dolev, Cynthia Dwork, and Moni Naor. Non-malleable cryptography.
In Proceedings of the twenty-third annual ACM symposium on Theory of com-
puting, STOC Õ91, pages 542Ð552, New York, NY, USA, 1991. ACM.
[DKMR05] Anupam Datta, Ralf Ksters, John Mitchell, and Ajith Ramanathan. On the re-
lationships between notions of simulation-based security. In Joe Kilian, editor,
Theory of Cryptography, volume 3378 of Lecture Notes in Computer Science,
pages 476Ð494. Springer Berlin / Heidelberg, 2005. 10.1007/978-3-540-30576-
7ú26.
[DM00] Yevgeniy Dodis and Silvio Micali. Parallel reducibility for information-
theoretically secure computation. In Proceedings of the 20th Annual Interna-
tional Cryptology Conference on Advances in Cryptology, CRYPTO Õ00, pages
74Ð92, London, UK, 2000. Springer-Verlag.
[FS90] U. Feige and A. Shamir. Witness indistinguishable and witness hiding proto-
cols. In Proceedings of the twenty-second annual ACM symposium on Theory
of computing, STOC Õ90, pages 416Ð426, New York, NY, USA, 1990. ACM.
45
[GKZ10] Juan A. Garay, Aggelos Kiayias, and Hong-Sheng Zhou. A framework for the
sound specification of cryptographic tasks. In Proceedings of the 2010 23rd
IEEE Computer Security Foundations Symposium, CSF Õ10, pages 277Ð289,
Washington, DC, USA, 2010. IEEE Computer Society.
[GL91] Shafi Goldwasser and Leonid A. Levin. Fair computation of general functions in
presence of immoral majority. In Proceedings of the 10th Annual International
Cryptology Conference on Advances in Cryptology, CRYPTO Õ90, pages 77Ð93,
London, UK, UK, 1991. Springer-Verlag.
[GMW87] O. Goldreich, S. Micali, and A. Wigderson. How to play any mental game. In
Proceedings of the nineteenth annual ACM symposium on Theory of computing,
STOC Õ87, pages 218Ð229, New York, NY, USA, 1987. ACM.
[GMW91] Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield nothing
but their validity or all languages in np have zero-knowledge proof systems. J.
ACM, 38:690Ð728, July 1991.
[Hoa78] C. A. R. Hoare. Communicating sequential processes. Commun. ACM, 21:666Ð
677, August 1978.
[Kus06] Ralf Kusters. Simulation-based security with inexhaustible interactive turing
machines. In Proceedings of the 19th IEEE workshop on Computer Security
Foundations, pages 309Ð320, Washington, DC, USA, 2006. IEEE Computer
Society.
[KV10] Jonathan Katz and Vinod Vaikuntanathan. One-round password-based au-
thenticated key exchange, 2010.
[LMMS98] P. Lincoln, J. Mitchell, M. Mitchell, and A. Scedrov. A probabilistic poly-time
framework for protocol analysis. In Proceedings of the 5th ACM conference on
Computer and communications security, CCS Õ98, pages 112Ð121, New York,
NY, USA, 1998. ACM.
[Mau02] Ueli M. Maurer. Indistinguishability of random systems. In Proceedings of
the International Conference on the Theory and Applications of Cryptographic
Techniques: Advances in Cryptology, EUROCRYPT Õ02, pages 110Ð132, Lon-
don, UK, UK, 2002. Springer-Verlag.
46
[MRST01] John C. Mitchell, Ajith Ramanathan, Andre Scedrov, and Vanessa Teague. A
probabilistic polynomial-time calculus for analysis of cryptographic protocols.
In Electronic Notes in Theoretical Computer Science, 2001.
[Nao89] Moni Naor. Bit commitment using pseudo-randomness (extended abstract).
In Proceedings on Advances in cryptology, CRYPTO Õ89, pages 128Ð136, New
York, NY, USA, 1989. Springer-Verlag New York, Inc.
[PS04] Manoj Prabhakaran and Amit Sahai. New notions of security: achieving uni-
versal composability without trusted setup. In Proceedings of the thirty-sixth
annual ACM symposium on Theory of computing, STOC Õ04, pages 242Ð251,
New York, NY, USA, 2004. ACM.
[PS05] Manoj Prabhakaran and Amit Sahai. Relaxing environmental security: Moni-
tored functionalities and client-server computation. In TCCÕ05, pages 104Ð127,
2005.
[PSW00] Birgit Pfitzmann, Matthias Schunter, and Michael Waidner. Secure reactive
systems, 2000.
[PW94] Birgit Pfitzmann and Michael Waidner. A general framework for formal no-
tions of ÓsecureÓ systems. In SYSTEM, HILDESHEIMER INFORMATIK-
BERICHTE 11/94, UNIVERSITAT, 1994.
[PW01] Birgit Pfitzmann and Michael Waidner. A model for asynchronous reactive
systems and its application to secure message transmission. In Proceedings of
the 2001 IEEE Symposium on Security and Privacy, pages 184Ð, Washington,
DC, USA, 2001. IEEE Computer Society.
[Sho04] Victor Shoup. Sequences of games: a tool for taming complexity in security
proofs. Cryptology ePrint Archive, Report 2004/332, 2004. http://eprint.
iacr.org/.
47

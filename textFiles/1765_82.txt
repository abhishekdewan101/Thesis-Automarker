Executive Summary
This dissertation is concentrated on the research of efficiency analysis of block-wise P-
signatures, and the objective of this project is to investigate possible techniques that can
be used to reduce the running time cost of block-wise P-signatures. Overall, this project
contains both theoretical investigation and practical implementation, as well as efficiency
analysis.
Block-wise P-signatures were recently proposed as a new primitive to achieve non-
interactive anonymous credentials with efficient attributes, which could be used in a vari-
ety of contexts such as e-Commerces and e-Voting systems. Nonetheless, the introduced
instantiation of block-wise P-signatures are based on symmetric pairings, which is re-
garded to be inefficient and impractical in implementation. Motivated by this observation
we engage in investigating possible techniques to enhance performance of block-wise P-
signatures.
We have received significant progress to improve the efficiency of block-wise P-signatures
both in theoretical algorithm design and in practical implementation. Our adopting tech-
niques mainly include reconstructing block-wise P-signatures based on asymmetric pair-
ings, as well as adopting pre-computation of pairing elements to speed up pairing compu-
tation. The major achievements are described as follows.
1. We firstly propose block-wise P-signatures based on asymmetric pairings, which can
be proven secure against forgery attacks, see pages 31-40.
2. Our proposed block-wise P-signatures are theoretically efficiency while comparing with
Izabache`ne et al.’s original construction, see pages 40-43.
3. We both implement block-wise P-signatures based on symmetric pairings and ones
based on asymmetric pairings using MIRACL Crypto. SDK, and our proposed
schemes achieve enormous efficiency improvement, see pages 43-46.
4. Based on our proposed schemes, we apply technique of pairing element alignment and
propose an optimized block-wise P-signature scheme, which is also proven secure
against forgery attacks. see pages 47-57.
5. We successfully speed up optimized block-wise P-signatures by adopting techniques
of pairing pre-computation and elements multiplication pre-computation, see pages
57-60.
6. We evaluate the performance of our proposed schemes on five pairing curves and give
a comprehensive comparison among them, see pages 61-66.
I
Contents
1 Introduction 1
1.1 Implementation of block-wise P-signatures . . . . . . . . . . . . . . . . . . . 3
1.2 Scope of this dissertation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2 Pairing-based Cryptography 5
2.1 Bilinear pairings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
2.2 Security assumption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.3 Practical issues of pairing implementations . . . . . . . . . . . . . . . . . . 8
2.4 Optimization of pairing-based cryptography . . . . . . . . . . . . . . . . . . 9
3 Review of P-signature Schemes 11
3.1 Groth-Sahai non-interactive proof systems . . . . . . . . . . . . . . . . . . . 11
3.1.1 Groth-Sahai commitment schemes . . . . . . . . . . . . . . . . . . . 13
3.1.2 Groth-Sahai pairing inner product equation and its proof . . . . . . 14
3.1.3 SXDH-based instantiation of Groth-Sahai proofs . . . . . . . . . . . 15
3.2 Single-block P-signature schemes . . . . . . . . . . . . . . . . . . . . . . . . 18
3.2.1 F-unforgeable signatures of single-block P-signatures . . . . . . . . . 18
3.2.2 Single-block P-signatures schemes . . . . . . . . . . . . . . . . . . . 19
3.3 Multi-block P-signature schemes . . . . . . . . . . . . . . . . . . . . . . . . 20
3.3.1 F-unforgeable signatures of multi-block P-signatures . . . . . . . . . 20
3.3.2 Multi-block P-signatures schemes . . . . . . . . . . . . . . . . . . . . 21
3.4 Block-wise P-signature schemes . . . . . . . . . . . . . . . . . . . . . . . . 23
3.4.1 Vector commitments of block-wise P-signatures . . . . . . . . . . . . 23
3.4.2 Block-wise P-signatures schemes . . . . . . . . . . . . . . . . . . . . 24
4 Asymmetric Pairing Based Block-wise P-signatures 31
4.1 Block-wise P-signatures based on asymmetric pairings . . . . . . . . . . . . 31
4.2 Security consideration of our proposed block-wise P-signatures . . . . . . . 38
4.3 Efficiency analysis of our proposed block-wise P-signatures . . . . . . . . . . 40
4.3.1 Theoretical analysis of proposed block-wise P-signatures . . . . . . . 41
4.3.2 Practical analysis of asymmetric block-wise P-signatures . . . . . . . 43
III
5 Optimization of Block-wise P-signatures 47
5.1 Optimization of our proposed block-wise P-signature . . . . . . . . . . . . . 47
5.1.1 Security consideration of optimized P-signatures . . . . . . . . . . . 56
5.2 Efficiency of optimized block-wise P-signatures . . . . . . . . . . . . . . . . 57
5.2.1 Pairing pre-computation in MIRACL library . . . . . . . . . . . . . 57
5.2.2 Experiment result. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
5.3 Other practical efficiency analysis of block P-signatures . . . . . . . . . . . 61
5.3.1 Efficiency analysis on different pairing curves . . . . . . . . . . . . . 61
5.3.2 Further efficiency analysis on BN curves . . . . . . . . . . . . . . . . 62
6 Conclusions 67
6.1 Future work of block-wise P-signatures . . . . . . . . . . . . . . . . . . . . . 68
A Experiment Results 74
A.1 Experiment result of Type-1 pairing based P-signatures . . . . . . . . . . . 74
A.2 Experiment result of Type-3 pairing based P-signatures . . . . . . . . . . . 76
A.3 Experiment result of Optimized P-signatures . . . . . . . . . . . . . . . . . 78
A.4 Experiment result of P-signatures on different curves . . . . . . . . . . . . . 80
IV
List of Figures
2.1 Suggested key size of different style of cryptographic primitives [1] . . . . . 8
2.2 Miller’s algorithm [2] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.1 Groth-Sahai proof system [3] . . . . . . . . . . . . . . . . . . . . . . . . . . 12
3.2 Group elements used in SXDH-based Groth-Sahai proof [3] . . . . . . . . . 17
3.3 Group elements used in DLIN-based Groth-Sahai proof [3] . . . . . . . . . . 18
4.1 Elements used in G1 and G2 of proposed block-wise P-signatures . . . . . . 38
4.2 Security reduction from symmetric pairings to asymmetric pairings . . . . . 39
4.3 The number of group elements used in Type-1 pairing-based and Type-3
pairing-based block-wise P-signatures – F-signature part . . . . . . . . . . . 41
4.4 The number of group elements used in Type-1 pairing-based block-wise
P-signatures – Signature proof part[4] . . . . . . . . . . . . . . . . . . . . . 42
4.5 The number of group elements used in Type-3 pairing-based block-wise
P-signatures – Signature proof part . . . . . . . . . . . . . . . . . . . . . . . 42
4.6 Efficiency comparison between DLIN-based and SXDH-based signature proof
generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
4.7 Efficiency comparison between Type-1 pairing based and Type-3 pairing
based block-wise P-signatures (using pairing curves BN-128) . . . . . . . . . 45
5.1 Optimization example – Signature verification of block-wise P-signatures
before/after optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
5.2 Elements used inG1 andG2 of our proposed optimized block-wise P-signatures 54
5.3 Collection of repeated pairing forms in block-wise P-signatures before/after
optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
5.4 Security reduction from asymmetric pairings P-signatures to optimized P-
signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.5 Comparison of used group elements before/after optimization – F-signature
part . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
5.6 Efficiency comparison of block-wise P-signatures without/with optimization
(using pairing curve BN-128) . . . . . . . . . . . . . . . . . . . . . . . . . . 59
5.7 Efficiency comparison among different pairing curves - F-signatures part . . 62
5.8 Detailed data of efficiency comparison among different pairing curves - F-
signatures part . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
V
5.9 Efficiency comparison of block-wise P-signature without/with optimization
(using pairing curve BN-192) . . . . . . . . . . . . . . . . . . . . . . . . . . 64
5.10 Performance comparison of block-wise P-signatures on pairing curves BN-
128 and BN-196 - F-signatures part (please refer x-axis to the ID shows in
Figure 5.9) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
5.11 Performance comparison of block-wise P-signatures on pairing curves BN-
128 and BN-196 - whole part (please refer x-axis to the ID shows in Figure
5.9) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
5.12 Comparison of efficiency enhancement between block-wise P-signatures in
pairing curves BN-128 and BN-196 (please refer x-axis to the ID shows in
Figure 5.9) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
6.1 Number of pairings computation per proof verification, where n and m stand
for the number of different types of variables. [5] . . . . . . . . . . . . . . . 68
A.1 Type-1 pairings - case R = REQ . . . . . . . . . . . . . . . . . . . . . . . . 74
A.2 Type-1 pairings - case R = REQ . . . . . . . . . . . . . . . . . . . . . . . . 75
A.3 Type-1 pairings - case R = RIP . . . . . . . . . . . . . . . . . . . . . . . . . 75
A.4 Type-1 pairings - case R = RIP . . . . . . . . . . . . . . . . . . . . . . . . . 75
A.5 Type-3 pairings - case R = REQ . . . . . . . . . . . . . . . . . . . . . . . . 76
A.6 Type-3 pairings - case R = REQ . . . . . . . . . . . . . . . . . . . . . . . . 76
A.7 Type-3 pairings - case R = RIP . . . . . . . . . . . . . . . . . . . . . . . . . 77
A.8 Type-3 pairings - case R = RIP . . . . . . . . . . . . . . . . . . . . . . . . . 77
A.9 Optimized Type-3 pairings - case R = REQ . . . . . . . . . . . . . . . . . . 78
A.10 Optimized Type-3 pairings - case R = REQ . . . . . . . . . . . . . . . . . . 78
A.11 Optimized Type-3 pairings - case R = RIP . . . . . . . . . . . . . . . . . . 79
A.12 Optimized Type-3 pairings - case R = RIP . . . . . . . . . . . . . . . . . . 79
A.13 CP-80 - case R = REQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
A.14 MNT-80 - case R = REQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
A.15 BN-128 - case R = REQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
A.16 KSS-192 - case R = REQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
A.17 BLS-256 - case R = REQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
VI
Chapter 1
Introduction
Credential systems play important roles in modern society for people to demonstrate the
validity of requested activities. Nowadays an variety of paper-based credentials have been
used in our daily life, such as drivers’ licences, passports, and even tickets for entering
galleries. In electronic world, digital credentials such as national identification cards and
Oyster cards have also been the essential tools that people use everyday. To apply for
credentials, in general, people are required to register themselves to trusted organizations,
then credentials will be issued if applicants are qualified. Credentials which issued by
organizations explicitly shows the applicants’ personal information such as name, birth-
date or home address, as well as the statement of allowed activities. With the issued
credentials, people are allowed to do some activities identified in the credentials.
Traditionally a simple digital credential system can be constructed on digital signa-
tures. Without loss of generality, suppose an applicant has registered to a credential issuer
and both two parties use public-key system. Firstly one applicant sends a digital signa-
ture containing a message to be authorized to one credential issuer. While receiving the
application, the credential issuer checks validity of the applicant’s message by verifying
the received digital signature and then produces a new digital signature which contains
the applicant’s public key information and the applied message. The new digital signature
signed by the credential issuer is then sent back to the applicant. Afterwards, the appli-
cant can present the issued digital signature to a third party and claim the ownership and
the validity of underlying message by verifying the digital signature.
In digital world the above context of digital credential system shows two evident secu-
rity flaws. Firstly it is clear that both in the credential applying stage and in the credential
proving stage, the message is required to presented in a plaintext form, which is not desir-
able if the underlying message contains private information. Secondly, digital credentials
are replicatable hence a malicious attacker can easily get a replication of one valid digital
credential and play as an imposter on the Internet. Moreover, some further applications
of digital credentials, such as e-cash and digital transactions, can also concern the linkage
issue and the reuse issue of credential proofs. Motivated by the issues of privacy and
anonymity, digital credential systems need to be further reconsidered.
1
2 CHAPTER 1. Introduction
Anonymous credentials
Anonymous credentials system is one of many solutions to address privacy and anonymity
issues of digital credentials. Anonymous credentials, which are firstly introduced by
Chaum [6], have been widely investigated by cryptographers and received a significant
progress [7, 8, 9, 10, 11, 12, 13, 14, 15, 4]. The introduced anonymous credentials systems
are essentially constructed on a variety of digital signatures with two protocols. The first
protocol is designed to proceed users’ credential requests in an anonymous manner while
users try to submit both their secret keys and commitments on requested messages to
credential issuers. After operating the first protocol, users can get credentials and reveal
neither key information nor requested messages to other protocol participants nor mali-
cious eavesdroppers. In terms of the second protocol, it is designed for users to prove the
knowledge of ownership on credentials to third parties. For example, assume an user pos-
sesses a credential containing a signature (m,?), he can firstly reveal a commitment c on
the message m and then demonstrate his possession of (c, ?) using zero-knowledge proofs
[16], so that third parties cannot learn any information about the message m. Further-
more, anonymous credential systems also provide the property of credential-unlinkability,
which means that eavesdroppers learn nothing even multiple proofs are connected to the
same credential.
Anonymous credentials are theoretically feasible, however, the majority of instanti-
ations are impractical due to the inefficiency of interactive zero-knowledge proofs [16].
Traditional interactive zero-knowledge proofs are significantly constructed on NP-complete
problems such as graph isomorphism problems or circuit satisfiability problems. To achieve
sufficient security degree, NP-reduction mechanism may take an enormous amount of in-
teractions between provers and verifiers, which is not practical for deployment in real appli-
cations. Although interactive zero-knowledge proofs can be replaced with non-interactive
ones using Fiat-Shamir paradigm [17] and Random Oracle Model [18]; however, this ap-
proach may probably show security flaws while replacing random oracle with real hash
functions [19, 20].
P-signatures
In 2008, Groth and Sahai [3] suggested a new non-interactive zero-knowledge proof system
(NIZK), which firstly provides an effective proof mechanism to address the efficiency issue
of zero-knowledge proofs. Not like NP-reduction methodologies, Groth-Sahai NIZK proofs
adopt idea of group-dependent language, which is to to conceal the elements of one cyclic
group by transferring them into another group, and then provide a mathematical relation
to prove the connectivity of these two cyclic groups. Although the new NIZK proofs can
be only used in pairing-based cryptographic primitives, Groth-Sahai NIZK proofs have
provided an opportunity for constructing practical anonymous credential systems.
With the help of Groth-Sahai proofs, P-signatures are introduced to provide solutions
to construct anonymous credentials. P-signatures, which stands for signatures with effi-
cient Protocols, are firstly introduced by Belenkiy et al. [13] in 2008 and further extended
1.1. IMPLEMENTATION OF BLOCK-WISE P-SIGNATURES 3
to support multi-block messages [14]. P-signatures can be easily and practically extended
to implement a variety of anonymous credential systems. In general, one P-signature
scheme comprises a F-unforgeable signature scheme, a perfect hiding commitment scheme,
and three protocols:
1. An interactive protocol for users to request signatures on commitments of messages
from signature signers.
2. A non-interactive proof for users to prove the validity of signatures without revealing
the underlying messages.
3. A non-interactive protocol for users to prove the equality of two proofs on the same
commitments with different opening values.
1.1 Implementation of block-wise P-signatures
General P-signatures schemes have made a significant achievement in providing efficient
non-interactive protocol to anonymous credentials; but, their designs can be only deployed
in general applications based on public-key-centric system. Traditional public-key-centric
systems assume users maintain unique secret keys to represent their digital identities.
However, in real life some emerging web technologies including cloud applications, have
turned to describe web resources or network elements in an attribute-based methodology,
such as eXtensible Markup Language (XML). Not like general messages, it is evident
that the representation of XML is well-structured and can be further processed to fit in
with different applications. Cryptographers [12, 21] have tried to construct attribute-
based anonymous credential systems, but their constructions could not provide efficient
non-interactive proof. To address this issue, there are three critical points P-signatures
should be considered. It is obvious that the first point is to construct attribute-based
P-signatures. The second consideration is to make attributes in P-signatures be capable
of doing some simple logic calculation; for example, deciding if some set of attributes are
contained in the signatures. And the last point is to keep the availability of non-interactive
proofs of P-signatures.
In 2011, Izabache`ne et al. [4] proposed a powerful cryptographic primitive called
block-wise P-signatures, to be the response to the above three considerations. Block-
wise P-signatures not only further improve the efficiency of NIZK proofs of general P-
signatures; more importantly, block-wise P-signatures can support anonymous credentials
with efficient attributes. Therefore, block-wise P-signatures may hold high potential to
be the building blocks of cloud credential applications in the future. Due to the impor-
tance of block-wise P-signatures, in our project, we concentrate on the implementation
issue of block-wise P-signatures. An observation on the implementations of block-wise
P-signatures is that they heavily rely on bilinear-pairings computation. Bilinear-pairings
computation may show inefficient and impractical consequence if the underlying pairings
computation is not treated well. Motivated by this issue, in this dissertation, we concen-
trate on improving the efficiency of block-wise P-signatures.
4 CHAPTER 1. Introduction
1.2 Scope of this dissertation
This dissertation aims to comprehensively analyze the efficiency of block-wise P-signatures.
The objective of our works is not only on reviewing and discussing the efficiency of block-
wise P-signatures; more importantly, we concentrate on improving the performance of
block-wise P-signatures with possible optimization techniques. In Chapter 2, we introduce
the essential mathematical knowledge and security assumptions of bilinear pairings that
will be used in this dissertation. In addition, we also review several optimization techniques
that could be used to enhance the efficiency of pairing-based cryptographic schemes. Then
in Chapter 3, we review three introduced P-signature schemes, which are single-block P-
signatures, multi-block P-signatures, and most importantly, block-wise P-signatures. In
Chapter 4, we propose a new block-wise P-signature scheme based on asymmetric pairings
and analyze both the theoretical performance and the practical performance between our
proposed scheme and Izabache`ne et al.’s construction. In Chapter 5, we apply optimization
techniques into our scheme, and an optimized block-wise P-signature scheme is proposed.
Moreover, the further efficiency analysis of applying optimization techniques in block-wise
P-signatures is also given in this chapter. Lastly in chapter 6, we evaluate our works
and suggest some future works that could further increase the performance of block-wise
P-signatures.
Chapter 2
Pairing-based Cryptography
Bilinear pairings have been one of most important research topics in modern cryptography
since they can be used for constructing a variety of cryptographic primitives that cannot be
effectively solved in general public-key system. Bilinear pairings are essentially constructed
on elliptic curves and define functions that map a pair of elliptic curve points to a finite
field. In the past decade cryptographers utilized bilinear pairings to construct a variety
of cryptographic primitives and protocols. In this chapter we introduce the essential
knowledge of bilinear pairings, as well as some important security assumptions adopted
by P-signatures schemes.
2.1 Bilinear pairings
Without loss of generality, let p be a prime integer. Suppose G1, G2, GT be cyclic groups
of order p and can be expressed in multiplicative notation with identity element 1. A
bilinear map from G1 ?G2 to GT can be defined as a function
e : G1 ?G2 ?? GT
with three properties.
1. Bilinearity: For all u ? G1, v ? G2, and x, y ? Z, e(u
x, vy) = e(u, v)xy
2. Non-degeneracy: For all g1 ? G1, g2 ? G2 be the generators of G1 and G2, e(g1, g2)
generates GT .
3. Computability: There exits an probabilistic polynomial time algorithm to generate
bilinear map (p,G1,G2,GT , e, g1, g2), and for any u ? G1, v ? G2, it is efficient to
compute e(u, v).
Types of pairing implementations
From the bilinear map function e : G1 ? G2 ?? GT , it describes the pair association of
elements in G1 and G2 with elements in GT ; hence this technique is called bilinear pairings
5
6 CHAPTER 2. Pairing-based Cryptography
or pairings for short. In general, according to the constructions of bilinear maps, there
are three types of pairing implementations on elliptic curves, which are:
Type-1 pairings: It describes a special form of bilinear maps where G1 = G2, so the
pairing expression can be written as e : G?G ?? GT . Such the symmetric pairing
constructions are widely used in constructing pairing-based cryptographic schemes
because of their concise expressions.
Type-2 pairings: This type of pairing constructions e : G1?G2 ?? GT illustrate that
there exits an efficiently computable homomorphism ? from G2 to G1.
Type-3 pairings: This kind of pairing constructions define e : G1 ? G2 ?? GT where
G1 6= G2 and there exits no efficiently computable homomorphisms between G1 and
G2.
In fact, even in Type-3 pairings, it is evident that there exists homomorphisms between
G1 and G2 since G1 and G2 are inherently cyclic groups of the same order. However,
computing these homomorphisms may be computationally infeasible. This is the major
difference between Type-2 pairings and Type-3 pairings, and up to now there is few im-
plementation of Type-2 pairings. Among theses three types of pairings, the research of
Galbraith et al. [1] shows Type-1 pairings and Type-3 pairings may be the most common
and practical pairing implementations. Moreover, The research of Scott [2] further sug-
gests that Type-3 pairings can show more flexibility and efficiency than Type-1 pairings.
In this dissertation, we use the terms symmetric pairings and asymmetric pairings to
respectively describe Type-1 pairings and Type-3 pairings, which can clearly distinguish
these two types of pairings from the view of construction difference.
2.2 Security assumption
In modern cryptography, in order to theoretically measure the security degree of crypto-
graphic schemes, it is a common methodology to reduce one cryptographic scheme to one
known hard problem, such as factoring problem, square root problem, or discrete-logarithm
problem. Based on these hard problems, cryptographers have built a variety of security
models for measuring the security of proposed schemes. In terms of pairing-based cryptog-
raphy, the majority of proposed schemes are based on well-know Diffie-Hellman problem.
Here we introduce the essential security assumptions of pairings that will be used in this
dissertation.
Group-related security assumptions.
Definition 2.1. Computational Diffie-Hellman Problem (CDH)
Let G be a group of prime order p and g ? G be the generator of G. Given a = gx and
b = gy where x, y ? Z?p, computer c ? G such that c = g
xy.
2.2. SECURITY ASSUMPTION 7
Definition 2.2. Decisional Diffie-Hellman Problem (DDH)
Let G be a group of prime order p and g ? G be the generator of G. Given a = gx, b = gy
and c = gz where x, y, z ? Z?p, determine if z = xy.
Definition 2.3. Decisional Linear Problem (DLIN) [22]
Let G be a group of prime order p and g ? G be the generator of G. Given (g, gx, gy, grx, gsy, gr+s)
and (g, gx, gy, grx, gsy, gz) where x, y, r, s, z ? Z?p, determine if g
z = gr+s.
Definition 2.4. q-Hidden Strong Diffie-Hellman Problem (q-HSDH) [24]
Let G be a group of prime order p and g ? G be the generator of G. Given g, u, gx ? G,
and {g1/(x+ci), gci , uci}i=1...q where x, c1, ..., cq ? Z
?
p, output a new tuple (g
1/(x+c), gc, uc).
Definition 2.5. Flexible Diffie-Hellman Problem (FlexDH) [4]
Let G be a group of prime order p and g ? G be the generator of G. Given (g, gx, gy)
where x, y ? Z?p, find a triple (g
µ, gµx, gµxy) such that µ 6= 0.
Definition 2.6. n-Diffie-Hellman Exponent Problem (n-DHE) [25]
Let G be a group of prime order p and g ? G be the generator of G. Given (g, g1, ..., gn, gn+2, ..., g2n)
such that gi = g
(?i) where ? ? Z?p and i ? [1, 2n]\{n+1}, compute element gn+1 = g
(?n+1).
Definition 2.7. Flexible n-Diffie-Hellman Exponent Problem (n-FlexDHE) [4]
Let G be a group of prime order p and g ? G be the generator of G. Given (g, g1, ..., gn, gn+2, ..., g2n)
such that gi = g
(?i) where ? ? Z?p and i ? [1, 2n] \ {n+1}, compute a triple (g
µ, gµn+1, g
µ
2n)
where µ ? Z?p and gn+1 = g
?n+1 .
Symmetric pairings-related security assumptions.
Definition 2.8. Bilinear Diffie-Hellman Problem (BDH)
BDH problem is defined in Type-1 pairings. Let bilinear map e : G?G ?? GT and g ? G
be the generator of G. Given a = gx, b = gy and c = gz where where x, y, z ? Z?p, compute
e(g, g)xyz .
Asymmetric pairings-related security assumptions.
Definition 2.9. Symmetric External Diffie-Hellman Problem (SXDH) [23]
SXDH problem is defined in Type-3 pairings. Let bilinear map e : G1?G2 ?? GT , SXDH
problem assumes DDH problem is hard both in G1 and G2.
Definition 2.10. Triple Diffie-Hellman Problem (TDH) [13]
TDH problem is defined in Type-3 pairings. Let G1, G2, and GT be cyclic groups of order
p and define bilinear map e : G1 ? G2 ?? GT . Given g1, g
x
1 , g
y
1 ? G1, g2, g
x
2 ? G2,
and {ci, g
1/(x+ci)
1 }i=1...q where x, y, c1, ..., cq ? Z
?
p , output a tuple (g
µx
2 , g
µy
1 , g
µxy
1 ) for some
µ ? Zp.
8 CHAPTER 2. Pairing-based Cryptography
Figure 2.1: Suggested key size of different style of cryptographic primitives [1]
Author ? ECC-style RSA-style
NIST[26] 80 160 1024
128 256 3072
256 512 15360
Lenstra[27] 80 160 1329
128 256 4440
256 512 26268
ECRYPT[28] 80 160 1248
128 256 4440
256 512 15424
2.3 Practical issues of pairing implementations
Bilinear pairings have been utilized to construct a variety of applications that traditional
public-key system cannot provide; however, the majority of proposed pairing-based cryp-
tographic schemes concentrate on theoretical investigation rather than considering the
practical issue of pairing implementations. In reality, implementations of bilinear pairings
are significantly restricted since it is unfortunately evident that a few of elliptic curves
can be used for constructing bilinear pairings. Moreover, even one pairing-based scheme
can be successfully constructed, the computational cost may be extremely high and hence
cannot be practically deployed. Seeing this problem, in this section, it is necessary to
discuss the feasibility of implementing different types of pairing constructions, as well as
the techniques that we can used to improve the efficiency of pairing-based schemes.
The implementation of bilinear pairings contains complex point computation on elliptic
curves. Let e: G1 ? G2 ?? GT be a bilinear map where G1, G2 and GT are cyclic groups
of order p, and let e(P,Q) where P ? G1 and Q ? G2 be the expression of pairing
computations. In general, G1 is constructed as a subgroup of E(Fq) where E is a elliptic
curve and q is the field size of one field F. Similarly, G2 is constructed as a subgroup of
E(Fqk), which is k-th extension of finite field Fq and k is also called embedding degree.
Lastly GT is a subgroup of E(F
?
qk
).
Galbraith et al. [1] comprehensively discuss the implementation issue of bilinear pair-
ings. Here we review several points that are critical for designing pairing-based schemes.
Firstly it is pivotal to realize that the efficiency of bilinear pairings are more like tradi-
tional public-key system, rather than elliptic curves. Please refer to Table 2.1, which is the
suggested key size of ECC-style and RSA-style for achieving security degree ? by NIST
[26], Lenstra [27], and ECRYPT [28]. Suppose we want to construct a bilinear pairing
satisfying security degree ? = 256 of NIST, we can choose E(Fq) of ECC-style 512 as
the cyclic group G1, and set the size of G2 = E(Fqk) at lease greater than 15360 bits. It
is clear the bottleneck of this bilinear pairing function is on the computation of E(Fqk),
2.4. OPTIMIZATION OF PAIRING-BASED CRYPTOGRAPHY 9
which is like RSA-style system, rather than efficient elliptic curves. This fact illustrates
why the majority of proposed pairing-based schemes may show inefficiency in practical
implementations.
Secondly, it is not always true for pairing-based schemes to find suitable elliptic curves.
Please continue the above example, if we want to choose E(Fqk) of group size p, given q be
512 bits, the embedding degree k will be 15360/512 = 30. However, currently we still have
no way to construct such elliptic curves with embedding degree 30. This fact significantly
shorten the feasibility of implementing some pairing-based schemes.
According to the collection and analysis of known bilinear pairings in [1], up to now
only Type-1 pairings and Type-3 pairings can be practically implemented. Basically Type-
3 pairings can provide flexible choice for implementing pairing-based schemes without
any limitation. Type-1 pairings, G1 ? G1 ?? GT , however, are usually constructed on
elliptic curves over Fp, F2d and F3d with embedding degree 2 ,4 and 6. The significant
feature of Type-1 pairings is that group elements are commutable, e.g. e(P,Q)=e(Q,P ),
which simplify the design of pairing-based schemes. However, Type-1 pairings show two
shortcomings. Firstly to defend Pollard-rho attack on elliptic curve fields, the group size
of elliptic curves should be set to larger than 256 bits, which is equivalent to ? = 128.
Fortunately Type-1 pairings can find suitable elliptic curves for satisfying this security
degree; however, in terms of higher security degree of ? = 192 or ? = 256, Type-1 pairings
show no efficient implementations. Secondly, while doing one pairing calculation, Type-1
pairings take more group elements and more group operations than Type-3 pairings take.
Therefore, on the consideration of flexibility and efficiency of bilinear pairings, Type-3
pairings show more advantage than Type-1 pairings.
2.4 Optimization of pairing-based cryptography
Despite flexibility of Type-3 pairings, computational cost of bilinear pairing is still high. To
address this issue, cryptographers make great efforts on optimizing pairing computation.
Scott [2] concludes two techniques that could be used for pairing optimizations.
The first technique is called fixed argument optimization, firstly introduced in [29]
and further discussed in [30], which discusses the advantage of fixed argument in pairing
calculation. If both P and G are fixed arguments, the pairing calculation e(P,Q) can
be precomputed and stored. And if Q ? G2 = E(Fqk) is fixed, then the possible value
of Qx can be precomputed for further use. However, fixed argument P ? G1 = E(Fq)
cannot bring any advantage for pairing optimization. Fixed argument optimization can
be deployed both in Type-1 pairings and in Type-3 pairings.
The second technique aims to accelerate the calculation of products of pairings.
t =
n∏
i=1
e(Pi, Qi)
Products of pairings is common in pairing-based cryptographic schemes and the optimiza-
tion technique is firstly introduced by Scott [29] and further enhanced by Granger and
10 CHAPTER 2. Pairing-based Cryptography
Smart [31]. This optimization focus on sharing the same variable m and final exponenti-
ation in Miller’s algorithm (Figure 2.2). However, pairing product computation may not
always appear in pairing-based schemes; hence the deployment of this technique is limited.
Figure 2.2: Miller’s algorithm [2]
Chapter 3
Review of P-signature Schemes
P-signatures, which stand for signatures with efficient protocols, are firstly introduced
by Belenkiy et al. [13] in 2008 and are regarded as important building blocks for many
applications in modern cryptography. Generally A P-signature scheme comprises:
1. A commitment scheme for users to hide their messages to be signed.
2. A signature scheme for signature signers to sign received commitments.
3. An interactive protocol for users to acquire signatures from signature signers.
4. A non-interactive proof for users to prove the validity of signatures to third parties
without revealing the underlying messages.
5. A non-interactive proof for users to prove two different commitments are commitments
to the same message.
In this chapter, we will review three P-signature schemes, which are single-block P-
signature schemes [13], multi-block P-signature schemes [14], and block-wise P-signature
schemes [4] respectively. Moreover, we also review Groth-Sahai proof systems [3], which
are the essential tool for all P-signatures to construct non-interactive proofs.
3.1 Groth-Sahai non-interactive proof systems
Traditionally interactive zero-knowledge proofs are constructed on well-known NP-problems
such as circuit satisfiability, which take enormous time to complete a proof of knowledge.
Although interactive zero-knowledge proof can be transferred to non-interactive proof by
applying Fiat-Shamir paradigm [17] and random oracle model [18], this methodology may
lead proofs to be insecure [19, 20] while replacing random oracle with a real hash function.
Recently Groth and Sahai [3] found an extraordinary idea to construct non-interactive
system based on group-dependent language and common reference string (CRS), which
provides a secure and efficient way to construct non-interactive proof systems. Basically,
Groth-Sahai non-interactive proof systems possess witness indistinguishability and can be
11
12 CHAPTER 3. Review of P-Signatures
further transferred to zero-knowledge proofs. In fact, the construction of P-signatures
heavily rely on Groth-Sahai commitment schemes and proof systems; therefore, to better
understand P-signatures it is necessary to review these two parts of Groth-Sahai proof sys-
tems. The original Groth-Sahai non-interactive proof systems can be either implemented
on Type-1 Pairings or Type-3 Pairings; in this section, we will focus on the version of
Type-3 pairings.
Figure 3.1: Groth-Sahai proof system [3]
Essentially Groth-Sahai proofs utilize group-dependent language to construct proofs.
Please refer to Figure 3.1, Groth-Sahai proofs define two bilinear pairings functions f :
A1 ? A2 ?? AT and F : B1 ? B2 ?? BT , a function ? : B ?? B and a trapdoor one-way
function ? : B ?? A, so that computation is efficient in ? but not trivial in ?. The defined
map should satisfy the following two properties:
?x ? A1,?y ? A2 : F (?1(x), ?2(y)) = ?T (f(x, y)), (3.1)
?X ? B1,?Y ? B2 : f(?1(X ), ?2(Y)) = ?T (F (X ,Y)),
To make a Groth-Sahai proof, common reference string (CRS) is required to be set
up. In general, CRS is a set of elements defined in Bi and the variable setting is different
in different type of pairings. In general we denote CRS by U = (U1, U2), which U1 = U
1
1 ,
..., Um11 ? B1 and U2 = U
1
2 , ..., U
m2
2 ? B2. To commit to an element x ? Ai, one selects
random vectors ??r = (r1, ..., rmi) ? F
mi
q and computes
commi(x) = ?i(x) +
mi∑
j=1
[rj]U
j
i (3.2)
= ?i(x) +
??r  Ui
Then suppose we want to construct a NIWI proof for the equation
a  y + x  b+ x  ?y = t (3.3)
where f(x, y) = x  y, we firstly make commitments for x and y with Groth-Sahai
commitment scheme.
c = ?i(x) +RU1 (3.4)
d = ?i(y) + SU2
3.1. GROTH-SAHAI NON-INTERACTIVE PROOF SYSTEMS 13
where R,S are random vectors. Next one can pick a ? Am1 , b ? A
n
2 , and H ? Matm2?m1
an computes
pi = RT ?2(b) +R
T??2(y) +R
T?SU2 ?H
TU2 (3.5)
? = ST ?1(a) + S
T?T ?1(x) +H
TU1
The verification of this NIWI proof can be verified by checking whether the following
equation holds
?1(a) • d+ c • ?2(b) + c • ?d = ?T (t) + U1 • pi + ? • U2 (3.6)
Here X • Y represents the computation of F (X ,Y).
Depending on different setting of group A1 and A2, there are four possible instantiations
for constructing Groth-Sahai proofs.1
1. A1 = G1, A2 = G2, f(P,Q) = e(P,Q): This setting is named pairing-product equa-
tion.
2. A1 = G1, A2 = Fq, f(P, y) = [y]P : This setting is named multi-scalar multiplication
in G1.
3. A1 = Fq, A2 = G2, f(x,Q) = [x]Q: This setting is named multi-scalar multiplication
in G2.
4. A1 = Fq, A2 = Fq, f(x, y) = x  y: This setting is named quadratic equation in Fq.
3.1.1 Groth-Sahai commitment schemes
Groth-Sahai commitment schemes consist of three functions, which are GSComSetup(.),
GSCom(.) and GSOpen(.) respectively.
GSComSetup(p,G1,G2, g). Taken groups G1 and G2 generated by generator g of prime
order p, GSComSetup(.) outputs common reference string paramscom.
GSCom(paramscom,m, open). Taken common reference paramscom, a message m ? Gi
to be committed, chosen a random value open, GSCom(.) produces commitment
comm. To commit to an exponent e ? Zp of a base b ? Gi, GSCom(.) can be
extended to GSExpCom(paramscom, b, e, open) where comm = GSCom(paramscom,
be, open).
GSOpen(paramscom, comm,m, open). Taken common reference paramscom, the com-
mitment comm to be verified, the message m ? Gi, and the random value open,
GSOpen(.) accepts if comm is the commitment of m. Opening comm gener-
ated by GSExpCom(paramscom, b, exp, open) can also be similarly done by checking
GSOpen(paramscom, comm, b
exp, open).
1In DLIN assumption of Type-1 pairings, there are three possible instantiations for Groth-Sahai proofs
since case 2 and case 3 are the same.
14 CHAPTER 3. Review of P-Signatures
Groth-Sahai commitment schemes can be constructed based on SXDH problem where
G1 6= G2 or DLIN problem where G1 = G2 and the achievement is turn out to be perfect
binding, computational hiding and extractable, one can get the detailed introduction in
[3].
3.1.2 Groth-Sahai pairing inner product equation and its proof
Groth-Sahai proofs [3] construct f-extractable non-interactive proof of knowledge (NIPK)
by providing inner product equation of bilinear maps. In Type-3 pairings, assume we
have bilinear maps (p,G1,G2,GT , e, g1, g2) where G1,G2,GT are cyclic groups of prime
order p, g1 and g2 are generators of G1 and G2, e : G1 ? G2 ?? GT is the bilinear map
function. Also we define params1 and params2 be the system parameters for G1 and
G2 to construct Groth-Sahai commitments.
2 To construct NIPK proof Groth and Sahai
introduce inner product equation for commitments of {ci}i=1...m in G1 and {dj}i=1...n in
G2.
NIPK{((c1 : x1), ..., (cm : xm), (d1 : y1), ..., (dn : yn)):
n∏
j=1
e(aj , yj)
m∏
i=1
e(xi, bi)
m∏
i=1
n∏
j=1
e(xi, yj)
rij = t} (3.7)
where {a1, ..., an} ? G1, {b1, ..., bm} ? G2, t ? GT , and {rij}i=1...m,j=1...n ? Zp.
Groth-Sahai witness-indistinguishable proofs
With the help of Groth-Sahai pairing inner product, a Groth-Sahai witness-indistinguishable
proof can be constructed as follows.
GSSetup(paramsBM). Taken security parameter of bilinear maps paramsBM , GSSetup(.)
generates all necessary parameters paramsGS used in Groth-Sahai proofs, including
params1 for constructing G1, params2 for constructing G1, and paramspi for con-
structing proofs.
GSProve(paramsGS , s, ({xi}1,...,m, {yj}1,...,n, opens)). Taken system parameters paramsGS,
statements s={(c1, ..., cm, d1, ..., dn), equations }, witnesses { xi }1,...,m, { yj }1,...,n,
and opening values opens, output a proof pi.
GSVerify(paramsGS, pi). Taken a proof pi, GSVerify(.) accepts if pi is a valid proof.
GSExtractSetup(paramsBM). Taken security parameter of bilinear maps paramsBM ,
GSExtractSetup(.) outputs a pair of auxiliary values (av1, av2) which is used for
extract the contents of commitments.
GSExtract(paramsGS, av1, av2, pi). GSExtract(.) extracts X= x1, ..., xm ? G1 and Y =
y1, ..., yn ? G2 such that (X, Y ) satisfies inner product equations and commitments.
2In Type-1 pairings, G1 = G2 and params1 = params2
3.1. GROTH-SAHAI NON-INTERACTIVE PROOF SYSTEMS 15
proofs of equality of committed exponents
To prove equality of commitment on exponents, Groth and Sahai provide the following
proving methods for exponents in different groups. .
Committed exponents in different groups. Let g1 ? G1 and g2 ? G2, to construct
a proof NIPK { ((c : G?1 ),(d : G
?
2 )): ?=? }, we can conduct Groth-Sahai equation
proof NIPK { ((c : g?1 ),(d : g
?
2 )): e(g
?
1 , g2)e(g
?1
1 , g
?
2 )=1 }.
Committed exponents in the same group. Let g1, u ? G1 and g2 ? G2, to construct
a proof NIPK { ((c1 : g
?
1 ),(c2 : u
?)): ?=? }, we can conduct Groth-Sahai equation
proof NIPK { ((c1 : g
?
1 ), (c2 : u
?), (d : g?2 )): ? = ? ? ? = ? }.
Zero-knowledge proofs. Let g1 ? G1 and g2 ? G2, to construct a zero-knowledge proof
NIZK { ((c1 : g
?
1 ),(c2 : g
?
1 )): ?=? }, we can conduct Groth-Sahai equation proof
NIZK { ((c1 : g
?
1 ),(c2 : g
?
1 ), (d : g
?
2 )): 1 ? e(g1, g
?
2 )e(g
?1
1 , g2)=1 }.
3.1.3 SXDH-based instantiation of Groth-Sahai proofs
After grasping the general idea of Groth-Sahai proof system, here we provide a specific
instantiation based on Type-3 pairings, which will be used in the reviewing P-signature
schemes except for block-wise P-signatures. 3 In Type-3 pairings, Groth-Sahai proofs
are constructed based on SXDH assumption. Here we follow the notion of Groth-Sahai
proof provided by Ghadafi et al. [32], which can provide more clear understanding of
SXDH-based instantiation.
CRS Setup. without loss of generality, let B1 = G
2
1, B2 = G
2
2 and BT = G
4
T , we define
F =
{
B1 ? B2 ?? BT
(X1, Y1), (X2, Y2) ?? (e(X1, Y1), e(X1, Y2), e(X2, Y1), e(X2, Y2))
In terms of CRS setting, for i = 1, 2, ai, ti ? F
?
q, we prepare
Qi = [ai]Pi, Ui = [ti]Pi, Vi = [ti]Qi
and set
U1i = (Pi, Qi) ? Bi
g(x, y)U2i =
{
[ti]U
1
i = (Ui, Vi) Binding case
[ti]U
1
i ? (O, Pi) = (Ui, Vi ? Pi)) Hiding case
The CRS is {U1,U2} where U1 = {U
1
1 ,U
2
1 } and U2 = {U
1
2 ,U
2
2}. We also define Wi =
U2i + (O,Pi) = (Wi,1, Wi,2) ? Bi.
3Block-wise P-signatures use DLIN-based instantiation of Groth-Sahai proofs due to the adoption of
Type-1 pairings construction. Here we will not discuss DLIN-based instantiation of Groth-Sahai proof.
Please refer to original paper [3] to see the detail setting DLIN-based instantiation.
16 CHAPTER 3. Review of P-Signatures
?i, ?i and commi. Here we define the maps ?i: Ai ?? Bi, ?i: Bi ?? Ai, and commitment
scheme. There are two cases to be considered.
While Ai = Fq, the maps are defined as
?i :
{
Fq ?? Bi
x ?? [x]Wi
?i :
{
Bi ?? Fq
X = ([c1]Pi, [c2]Pi) ?? c2 ? aic1
Observing ?i function, the underlying computation forms an ElGamal encryption.
And computing ?i function requires one to hold the secrets c1 and c2; otherwise, one
need to solve discrete logarithms. To commit to x ? Fq, the commitment scheme is
defined as
commi :
{
Fq ? Fq ?? Bi
(x, r) ?? ?i(x) + [r]U
1
i
While Ai = Gi, the maps are defined as
?i :
{
Gi ?? Bi
X ?? (O,X)
?i :
{
Bi ?? Gi
X = (C1, C2) ?? C2 ? [ai]C1
The same, ?i function also forms an ElGamal encryption. And computing ?i function
requires one to hold the secrets a1; otherwise, one need to solve discrete logarithms.
To commit to x ? Gi, the commitment scheme is defined as
commi :
{
Gi ? Fq ? Fq ?? Bi
(X, r1, r2) ?? ?i(X) + [r1]U
1
i + [r2]U
2
i
?T and ?T . Here we define maps maps ?T : AT ?? BT and ?T : BT ?? AT . Depending
on different equation we want to prove, there are four cases to define ?t and ?T .
For pairing product equation
?T :
{
GT ?? BT
Z ?? (1, 1, 1, Z)
?T :
{
BT ?? GT
(Z1,1, Z1,2, Z2,1, Z2,2) ?? Z2,2Z
?a1
1,2 (Z2,1Z
?a1
1,1 )
?a2
For multi-scalar multiplication equation in G1 and G2, ?T is respectively defined as
?T :
{
G1 ?? BT
X ?? (1, 1, e(X,W2,1), e(X,W2,2))
?T :
{
G1 ?? BT
X ?? (1, e(X,W2,1), 1, e(X,W2,2))
And ?T is defined as
?T :
{
BT ?? Gi
(Zs1 , Zs2 , Zs3 , Zs4) ?? s4 ? a1s2 ? a2s3 + a1a2s1Pi
3.1. GROTH-SAHAI NON-INTERACTIVE PROOF SYSTEMS 17
where Z = e(P1, P2).
For quadratic equation in Fq, we define Z = e(P1, P2) and then
?T :
{
Fq ?? BT
z ?? F (W1,W2)
z
?T :
{
BT ?? Fq
(Zs1 , Zs2 , Zs3 , Zs4) ?? s4 ? a1s2 ? a2s3 + a1a2s1
Figure 3.2: Group elements used in SXDH-based Groth-Sahai proof [3]
Assumption: SXDH G1 G2 Zp
Variable x ? Zp, X ? G1 2 0 0
Variable y ? Zp, Y ? G2 0 2 0
Pairing product equations 4 4 0
- Linear equation:
??
A 
??
Y = tT 2 0 0
- Linear equation:
??
X 
??
B = tT 0 2 0
Multi-scalar multiplication equation in G1 2 4 0
- Linear equation:
??
A  ??y = T1 1 0 0
- Linear equation:
??
X 
??
b = T1 0 0 2
Multi-scalar multiplication equation in G2 4 2 0
- Linear equation: ??a 
??
Y = T1 0 0 2
- Linear equation: ??x 
??
B = T2 0 1 0
Quadratic equation in Zp 2 2 0
- Linear equation: ??a  ??y = t 0 0 1
- Linear equation: ??x 
??
b = t 0 0 1
Cost of Groth-Sahai proofs.
Depending on different type of equations of different pairing environment, Groth-Sahai
proofs require different group elements involved in computation. Please refer to 3.2 and 3.3
that shows required group elements in SXDH setting and DLIN setting. Overall Groth-
Sahai proofs cost less in SXDH setting than in DLIN setting. For the cost of making
commitments, SXDH setting only need two group elements, but it costs three in DLIN
setting. Moreover, in pairing product equation for example, SXDH setting costs 8 group
elements in G1 and G2 while DLIN setting costs 9 group elements in G. The difference
of used group elements between these two pairing settings significantly shows that SXDH
setting take advantage in proofs computation.
18 CHAPTER 3. Review of P-Signatures
Figure 3.3: Group elements used in DLIN-based Groth-Sahai proof [3]
Assumption: DLIN G Zp
Variable x ? Zp, Y ? G 3 0
Pairing product equations 9 0
- Linear equation:
??
A 
??
Y = tT 3 0
Multi-scalar multiplication equation in G 9 0
- Linear equation: ??a 
??
Y = T 0 3
- Linear equation: ??x 
??
B = T 2 0
Quadratic equation in Zp 6 0
- Linear equation: ??x 
??
b = t 0 2
3.2 Single-block P-signature schemes
In 2008 Belenkiy et al. [13] introduced the first P-signature scheme with efficient non-
interactive proof and the achievement can be directly deployed for anonymous credentials.
Despite single block construction that might be only suitable for single message, this paper
defines the essential properties and security models of P-signatures, which can be regarded
as the preliminary of P-signatures.
3.2.1 F-unforgeable signatures of single-block P-signatures
Single-block P-signatures take F-unforgeable signatures as building blocks. F-unforgeable
signatures are firstly formalized by Belenkiy et al. [13] and the idea comes from the fact
that Groth-Sahai proofs cannot completely prevent attackers from making forgeries while
seeing (m, ?). Instead, if attackers are capable of compromising one way function F ,
they can produce a forgery (F (m), ?) that can pass the verification procedure. Basically
F-unforgeable signatures is inspired by the Boneh-Boyen signature scheme [33] and can be
illustrated as follows.
FSigSetup(1k). Taken security parameter k, output parameters params = (p,G1,G2,
GT , e, g, h) for bilinear maps e : G1 ?G2 ?? GT where G1 = ?g? and G2 = ?h? are
cyclic groups of prime order p. Moreover, we define t = e(g, h).
FKeyGen(params). The signer chooses secret-key sk = (?, ?) where ?, ? ? Zp and
computes public-key pk = (v,w, v¯, w¯) where v = h?, w = h? , v¯ = g?, w¯ = g?. The
generated public key pk can be verified by checking e(g, v) = e(v¯, h) and e(g,w) =
e(w¯, h).
FSign(params, (?, ?),m). The signer signs message m by randomly choosing r ? Zp ?
{(??m)/?} and then computing signature ? = (C1, C2, C2) whereC1 = g
1/(?+m+?r),
C2 = w
r, C3 = u
r.
3.2. SINGLE-BLOCK P-SIGNATURE SCHEMES 19
FVerify(params, (v,w, v¯, w¯),m, ?). The signature ? = (C1, C2.C2) is valid if the public
key is valid by checking by checking e(g, v) = e(v¯, h) and also the signature is valid
by checking e(g,w) = e(w¯, h) and e(C1, vh
mC2) = t, e(u,C2) = e(C3, w).
The above F-unforgeable signatures is proven secure based on HSDH problem and
TDH problem. The full proof can be found in [13].
3.2.2 Single-block P-signatures schemes
With the help of F-unforgeable signatures, the algorithms of single-block P-signatures are
described as follows.
SBPSigSetup(1k). Taken security parameter k, this function generates paramsBM =
(p,G1,G2,GT , e, g, h) for bilinear maps, paramsGS = (paramsBM , params1,
params2, paramspi) for Groth-Sahai commitments and proofs. Moreover, this func-
tion randomly chooses u ? G1 and sets t = e(g, h), finally outputs params =
(paramsGS, u).
SBPKeyGen(params). This function operates FKEYGen(paramsBM ) and generates
public key pair (sk, pk) = ((?, ?), (v,w, v¯, w¯)).
SBPSign(params, sk,m). Given secret-key sk and messagem, a signature ? = (C1, C2, C3)
is generated by operating FSign(params, sk,m); that is, C1 = g
1/(?+m+?r), C2 = w
r,
and C3 = u
r.
SBPVerify(params, pk,m, ?). Given public-key and a signature sigma, the signature is
valid if it passes FVerify(params, pk = (v,w, v¯, w¯),m, ?).
SBPCom(params,m, open). Given a message m and a random value open, a commit-
ment comm is generated by operating GSCom(params2, h
m, open).
SBPSigObtain(params, pk, comm, open) ?? SBPSigIssue(params, sk, comm). Single
block P-signatures define a interactive protocol for one user to obtain a signature
from an issuer. The protocol is described as follows.
1. The user randomly picks ?1, rho2 ? Zp and the issuer randomly picks z ? Zp.
2. The user exchanges secret variables with the issuer in a secure two-party com-
putation protocol. After exchange, the user gets z and the issuer acquires
?1, rho2.
3. The user operatesg GSCom(params,m, open) and generates a commitment
comm to a message m and send comm to the issuer.
4. The issuer verify the validity of comm, if valid, the issuer computes x = (? +
m+??1r)?2 and generates a tuple (C
?
1, C
?
2, C
?
3) where C
?
1 = g
1/x, C ?2 = w
z, and
C ?3 = u
z, and then sends back to the user.
20 CHAPTER 3. Review of P-Signatures
5. The user computes signature ? = (C1, C2, C3) where C1 = C
??2
1 , C2 = C
??1
2 , and
C3 = C
??1
3 , and verifies if ? is a valid signature.
SBPProve(params, pk,m, ?). The user computes commitments R1 = GSCom(params1,
C1, open1), R2 = GSCom(params1, C2, open2), R3 = GSCom(params1, C3, open3),
R4 = GSCom(params2, h
m, open4), R5 = GSCom(params1, u
m, open5), then the
user constructs Groth-Sahai proof
pi = NIPK{(R1 : C1), (R2 : C2), (R3 : C3), (R4 : h
?)m(R5, u
?) :
e(C1, vh
?C2) = t ? e(u,C2) = e(C3, w) ? ? = ?} (3.8)
and outputs comm = R4 and pi.
SBPProveVerify(params, pk, comm,pi). One verifier accepts the statement of relation
of m and ? if both public-key pk and Groth-Sahai pi pass the verification.
SBPEqCommProve(params,m, open, open?). Taken two opens open and open?, two
commitments comm and comm? can be respectively computed by GSCom(params2,
hm, open) and GSCom(params2, h
m, open?). Then a non-interactive zero-knowledge
proof can be constructed as
pi ?? NIZK{(comm : g?2 ), (comm
? : g?2 ) : ? = ?} (3.9)
SBPEqCommVerify(params, comm, comm?, pi). A verifier accepts pi if the inner prod-
uct equation of pi is valid.
Single-block p-signatures can only support one block of message and the security is
based on HSDH problem and THD problem that are inherently given by F-unforgeable
signatures, as well as SXDH problem that is ensured by Groth-Sahai proof system. Please
refer the corresponding proofs in the original paper [13].
3.3 Multi-block P-signature schemes
Motivated by the applications of e-cash that contains a bunch of messages, Belenkiy et al.
[14] extend single-block P-signature to support multiple blocks of messages. The invention
of multi-block P-signatures can not only significantly diversify the possible applications of
anonymous credentials, but also help to strengthen other cryptographic primitives, such
as strongly simulatable verifiable random functions (sVRFs). In this section, we review
the significant improvement of multi-block P-signatures.
3.3.1 F-unforgeable signatures of multi-block P-signatures
F-unforgeable signatures of multi-block P-signatures are extended from the F-unforgeable
signatures of single-block P-signatures. The major enhancement is that the exponent
calculation of C1 of signature ? supports multi-block message m = (m1, ..., mn). The
detail algorithm of F-secure signatures is described as follows.
3.3. MULTI-BLOCK P-SIGNATURE SCHEMES 21
MFSigSetup(1k). Taken security parameter k, output parameters params = (p,G1,G2,
GT , e, g, h) for bilinear maps e : G1 ?G2 ?? GT where G1 = ?g? and G2 = ?h? are
cyclic groups of prime order p. Moreover, we define t = e(g, h).
MFKeyGen(params). The signer chooses secret-key sk = (?, ? = (?1, ..., ?n)) where
?, ? ? Zp and computes public-key pk = (v,w, v¯, w¯) where v = h
?, v¯ = g?, wi = h
?i ,
, w¯i = g
?i . The generated public key pk can be verified by checking e(g, v) = e(v¯, h)
and e(g,wi) = e(w¯i, h) where i = 1, ..., n.
MFSign(params, (?, ?),m). The signer signs messagem = (m1,m2, ...,mn) by randomly
choosing r ? Zp ? {?(? + ?1m1 + ... + ?nmn)} and then computing a signature
? = (C1, C2, C2) where C1 = g
1/(?+r+?1m1+...+?nmnr), C2 = h
r, C3 = u
r.
MFVerify(params, (v,w, v¯, w¯),m, ?). The signature ? = (C1, C2.C2) is valid if the pub-
lic key is valid by checking by checking e(g, v) = e(v¯, h) and also the signature is valid
by checking e(g,w) = e(w¯, h) and e(C1, vC2
∏n
i=1w
mi
i ) = t, e(u,C2) = e(C3, h).
From the construction of above algorithm, it is evident the modification of F-unforgeable
signatures of multi-block P-signatures is slight. In fact, the modified signature scheme is
also proven secure based on HSDH problem and TDH problem, which is exactly the same
as F-unforgeable signatures introduced in Section 3.2.1. The full proof can be found in
the original paper [14].
3.3.2 Multi-block P-signatures schemes
With the help of modified F-unforgeable signatures, multi-block P-signatures can be con-
structed as follows.
MBPSigSetup(1k). Taken security parameter k, this function generates paramsBM =
(p,G1,G2,GT , e, g, h) for bilinear maps, paramsGS = (paramsBM , params1, params2,
paramspi) for Groth-Sahai commitments and proofs. Moreover, this function ran-
domly chooses u ? G1 and sets t=e(g, h), finally outputs params = (paramsGS,
u).
MBPKeyGen(params). This function operates MFKEYGen(paramsBM ) and gener-
ates public key pair (sk, pk)= ((?, ?),(v,w,v¯,w¯)) where ?=(?1, ..., ?n), w=(w1, ...,
wn), and w¯=(w¯1, ..., w¯n).
MBPSign(params, sk,m). Given secret-key sk and message m = (m1, ...,mn), a sig-
nature ? = (C1, C2, C3) is generated by operating MFSign(params, sk,m); that is,
C1 = g
1/(?+r+?1m1+...+?nmnr), C2 = h
r, and C3 = u
r
MBPVerify(params, pk,m, ?). Given public-key pk, message m=(m1, ..., mn) and a
signature sigma, the signature is valid if it passes MFVerify(params, pk=( v, w, v¯,
w¯), m, ? ).
22 CHAPTER 3. Review of P-Signatures
MBPCom(params,m, open). Given a messagem=(m1, ..., mn) and random values open
= (open1, ..., openn), a commitment comm=(comm1, ..., commn) where each commi
consisting of a pair (Hi, Ui) generated by operating (GSCom(params1, h
mi , openi,1),
GSCom(params1, u
mi , openi,2)).
MBPSigObtain(params, pk, comm, open) ?? MBPSigIssue(params, sk, comm). In
this protocol, multi-block P-signatures define a interactive protocol for one user to
obtain a signature from an issuer. The protocol is the same with Single block P-
signatures and described as follows.
1. The user randomly picks ?1, ?2 ? Zp and the issuer randomly picks z ? Zp.
2. The user exchanges secret variables with the issuer in a secure two-party com-
putation protocol. After exchange, the user gets z and the issuer acquires
?1, ?2.
3. The user operatesg GSCom(params,m, open) and generates a commitment
comm to a message m and send comm to the issuer.
4. The issuer verify the validity of comm, if valid, the issuer computes x = (? +
m+??1r)?2 and generates a tuple (C
?
1, C
?
2, C
?
3) where C
?
1 = g
1/x, C ?2 = w
z, and
C ?3 = u
z, and then sends back to the user.
5. The user computes signature ? = (C1, C2, C3) where C1 = C
??2
1 , C2 = C
??1
2 , and
C3 = C
??1
3 , and verifies if ? is a valid signature.
MBPProve(params, pk,m, ?). The user computes commitments R1 =GSCom(params1,
C1, open1), R2 = GSCom(params1, C2, open2), R3 = GSCom(params1, C3, open3),
comm=(comm1, ..., commn), by operating MBPCom(params,m, opencomm) then
the user constructs Groth-Sahai proof
pi = NIPK[hm1 ? H1, u
m1 ? U1, ..., h
mn ? Hn, u
mn ? Un]{ (3.10)
(hm1 , um1 , wm11 , ..., h
mn , umn , wmn1 , C1, C2, C3) :
e(C1, vC2
n∏
i=1
wmii ) = t ? e(u,C2)e(C3, h
?1) = 1 ?
{e(w¯i, h
mi)e(g?1, wmii ) = 1}
n
i=1}
MBPProveVerify(params, pk, comm,pi). One verifier accepts the statement of relation
of m and ? if both public-key pk and Groth-Sahai pi pass the verification.
MBPEqCommProve(params,m, open, open?). Taken two opens open and open?, two
commitments comm and comm? can be respectively computed by GSCom(params2,
hm, open) and GSCom(params2, h
m, open?). Then a non-interactive zero-knowledge
proof can be constructed as
pi ?? NIZK{(comm : g?2 ), (comm
? : g?2 ) : ? = ?} (3.11)
3.4. BLOCK-WISE P-SIGNATURE SCHEMES 23
MBPEqCommVerify(params, comm, comm?, pi). A verifier accepts pi if the inner prod-
uct equation of pi is valid.
From the construction of multi-block signatures introduced above, even though the
underlying signature is slightly modified, the corresponding proof algorithms are significant
different. In order to prove the validity of P-signatures, users should generate commitments
for each block of messages of P-signatures. Such construction will inevitably lead to large
size of proof while the amount of blocks of messages is large. Therefore, we can conclude
the efficiency of proof of multi-block P-signatures will decline as the size of message is
increasing. And in terms of security, similar to single-block P-signatures, multi-block P-
signatures is secure provided the hardness of HSDH problem, TDH problem and SXDH
problem.
3.4 Block-wise P-signature schemes
Motivated by the emerging investigation on attribute-based cryptography, predicated-based
cryptography, Izabache`ne et al. [4] proposed block-wise P-signatures. Essentially the
message m=(m1,...,mn) in block-wise P-signatures represents user attributes, which is
significantly different from the definition of message in traditional P-signatures. More-
over, the commitments to the blocks of messages are required to be verifiable for some
predicates that represent the logical relation of different combinations of message blocks.
Therefore, block-wise P-signatures can provide a variety of functionalities that traditional
P-signatures cannot provide.
The proposed construction of block-wise P-signatures is based on symmetric pairings;
hence, in this section we will use the notion of Type-1 pairings. Let G, GT be cyclic groups
of prime order p and define e: G?G be the bilinear map.
3.4.1 Vector commitments of block-wise P-signatures
Different from the traditional P-signatures, block-wise P-signatures design a new commit-
ment scheme. Given a commitment key (g, g1, ..., gn, gn+2, ..., g2n), vector commitments
consist of two functions.
VecCom(m, r). Given message m = (m1, ...,mn), choose r ? Zp and compute commit-
ment V
V = gr 
n∏
j=1
g
mj
n+1?j (3.12)
Moreover, to commit to a specific block of message, said mi, we can compute a
witness
Wi = g
r
i 
n∏
j=1,j 6=i
g
mj
n+1?j+i (3.13)
24 CHAPTER 3. Review of P-Signatures
VecOpen(m, r, V ). a commitment V is valid if V = gr 
∏n
j=1 g
mj
n+1?j. Moreover, to verify
a witness Wi, we can check if
e(gi, V ) = e(g,Wi)e(g1, gn)
mi (3.14)
3.4.2 Block-wise P-signatures schemes
With the help of vector commitments, block-wise P-signatures, consisting F-unforgeable
signatures and all proof algorithms, are described as follows.
BWPSigSetup(1k). Taken security parameter k, this function generates params = (n,
G, GT , g, e, f) where G is a cyclic group of prime order p and generated by generator
g, e: G?G ?? GT is a bilinear map and f=(f1, f2, f3) is common reference string
(CRS) for Groth-Sahai proof.
BWPKeyGen(params). Choosing ?, ?, ?, ? ? Zp, u,U0 ? G, computing ? = g
? ,
? = g? , U1 = g
? , and gi = g
(?i) for i ? [1, ..., n, n + 2, ...2n]. The secret-key sk =
(?, ?, ?) and public-key pk = (u, ?, ?, U0, U1, {gi}i?[1,2n]/{n+1}).
BWPSign(params, sk,m). Taken message m = (m1, ...,mn), the signer firstly chooses
r ? Zp and computes V = g
r 
∏n
j=1 g
mj
n+1?j=g
m1
n    g
mn
1  g
r. Secondly the signer
chooses c ? Zp and computes ? = (?1, ?2, ?3, ?4, ?5, ?6, r) where
?1 = g
?/?+c, (3.15)
?2 = g
c,
?3 = u
c,
?4 = (U0V
?)c,
?5 = V
c,
?6 = V
BWPVerify(params, pk,m, ?). Receiving message m = (m1, ...,mn) and ? = (?1, ?2,
?3, ?4, ?5, ?6, r), the verifier accepts the signature if ?6 = g
r 
∏n
j=1 g
mj
n+1?j and
e(A, g) = e(?1,?, ?2), (3.16)
e(u, ?2) = e(?3, g),
e(g, ?4) = e(U0, ?2)e(U1, ?5),
e(g, ?5) = e(?6, ?2),
BWPWitGen(params,R, i,m,X, ?). Taken relation R, index i, m = (m1, ...,mn), X =
(x1, ..., xn) and ? = (?1, ?2 ,?3, ?4, ?5, ?6, r),
1. If R = REQ and mi = xi where i ? [1, n], compute the witness
W = gri 
n∏
j=1,j 6=i
g
mj
n+1?j+i
3.4. BLOCK-WISE P-SIGNATURE SCHEMES 25
2. If R = REQ and mi 6= xi, where i ? [1, n], compute the witness W = (W0, W1,
W2, W3, W4) where
W0 = g
1/(mi?xi), (3.17)
W1 = g
(mi?xi)
1 ,
W2 = g
(mi?xi),
W3 = g
(mi?xi)
2n
W4 = g
r
i 
n∏
j=1,j 6=i
g
mj
n+1?j+i
3. If R = RIP , i = 0, and , m X = 0, compute the witness
W =
n∏
i=1
W xii for each (3.18)
Wi = g
r
i 
n∏
j=1,j 6=i
g
mj
n+1?j+i
4. If R = RIP , i = 0, and , m X 6= 0, compute the witness W = (W0, W1, W2,
W3, W4) where
W0 = g
1/(mi?xi), (3.19)
W1 = g
(mi?xi)
1 ,
W2 = g
(mi?xi),
W3 = g
(mi?xi)
2n
W4 =
n∏
i=1
W xi4,i for each
W4,i = g
r
i 
n∏
j=1,j 6=i
g
mj
n+1?j+i
BWPWitVerify(params, pk, i,X,W, ?). Taken public-key pk, index i, X = (x1, ..., xn),
witness W and a valid signature ? = (?1, ?2, ?3, ?4, ?5, ?6, r),
1. If R = REQ and i ? [1, n], output 1 if
e(gi, ?6) = e(g1, gn)
xi  e(g,W ) (3.20)
26 CHAPTER 3. Review of P-Signatures
2. If R = REQ and i ? [1, n], parse W = (W0, W1, W2, W3, W4) and check if the
following equations hold.
e(gi, ?  g
?xi
n+1?i) = e(W1, gn)  e(g,W4) (3.21)
e(W0,W1) = e(g, g1),
e(W1, g) = e(g1,W2),
e(W1, g2n) = e(g1,W3),
3. If R = RIP and i = 0, output 1 if
e(g,W ) = e(
n∏
i=1
gxii , ?6) (3.22)
4. If R = RIP and i = 0, parse W = (W0, W1, W2, W3, W4) and check if the
following equations hold.
e(
n∏
i=1
gxii , ?6) = e(W1, gn)e(g,W4) (3.23)
e(W0,W1) = e(g, g1),
e(W1, g) = e(g1,W2),
e(W1, g2n) = e(g1,W3),
BWPSigObtain(pk,Mpart1, openpart1) ?? MBPSigIssue(sk, Vpart1,Mpart2). this in-
teractive protocol provides users to acquire signatures from some organizations.
1. the user chooses rpart1 ? Zp and computes a commitment Vpart1 = g
rpart1 ∏n1
j=1 g
mj
n+1?j for message Mpart1=(m1, ..., mn1). The the user sets openpart1 =
Mpart1=(m1, ..., mn1 , r
?) and computes a witness-indistinguishable proof for
knowledge of Mpart1 such that Vpart1 = g
rpart1 
∏n1
j=1 g
mj
n+1?j .
2. the signature issuer chooses rpart2, c ? Zp and computes
V = Vpart1 
n∏
j=n+1
g
mj
n+1?j (3.24)
?1 = g
?/(?+c),
?2 = g
c,
?3 = u
c,
?4 = (U0(V  g
rpart2)?)c,
?5 = (V  g
rpart2)c, ?6 = V  g
rpart2
and return ?¯ = (?1, ?2, ?3, ?4, ?5, ?6, rpart2).
3.4. BLOCK-WISE P-SIGNATURE SCHEMES 27
3. the user outputs ? = (?1, ?2, ?3, ?4, ?5, ?6, r) where r = rpart1 + rpart2.
BWPProve1(params, pk, i, S = {i},m,X, ?). Taken m = (m1, ...,mn), X = (x1, ..., xn)
and ? = (?1,?2,?3, ?4,?5,?6,r). Firstly this proof needs to compute { CXt,j =
GSCom(Xt,j , openxt,j) }t?S,j?{1,2,3} where {(Xt,1,Xt,2,Xt,2) = (g
xt
1 , g
xt , gxt2n)}t?S . Sec-
ondly this proof computes commitments for {C?j = GSCom(?j , open?j )}j=1...6.
Thirdly this proof chooses ?7 ? G and ? ? Zp, computes C?7 = GSCom(?7, open?7)
and C?? = GSCom(??, open??), and then constructs a proof pitheta proving the fol-
lowing equations.
e(?7, g) = e(?1,?  ?2) ? (3.25)
e(u, ?2) = e(?3, g) ?
e(g, ?4) = e(U0, ?2)e(U1, ?5) ?
e(g, ?5) = e(?6, ?2) ?
? = 1 ?
e(?/?7, g
?) = 1
There are two cases for this proof
- If R = REQ, this proof computes commitment CW = GSCom(W , openW )
whereW=BWWitGen(pk,REQ,i,m,X,?) and then computes proofs pixi , {piXt,j}t?S,j=1,2
such that
e(gi, ?6) = e(Xi,1, gn)e(g,W ) ? (3.26)
e(Xi,2, g1) = e(Xi,1, g) ?
e(Xi,2, g2n) = e(Xi,3, g)
The proof is pi = ({Cxt,j}t?S,j=1,2,3, {C?j}j=1,...,7, CW , C?, pi?, pixi , {pixt,j}t?S,j=1,2, ).
- If R = REQ, this proof computes commitments {CWj}j=0,...,4 to (W0, W1, W2,
W3, W4) and generates proofs pixi , piW satisfying
e(gi, ?6)  e(Xi,1, gn)
?1 = e(W1, gn)  e(g,W4) ? (3.27)
e(W0,W1) = e(g, g1) ?
e(W1, g) = e(g1,W2) ?
e(W1, g2n) = e(g1,W3)
and also generates proof {piXt,j}t?S,j=1,2. The final proof is pi=( {Cxt,j}t?S,j=1,2,3,
{C?j}j=1,...,7, {CWj}j=0,...,4, C?,pi?, pixi , {pixt,j}t?S,j=1,2 ).
BWPProve2(params, pk,R, i,m, ,X, ?). Similar to BWPProve1, firstly this proof com-
putes commitments {C?j}j=1,...,7, C?, as well as proofs pi? and pixi . Then there are
four cases in this proof.
28 CHAPTER 3. Review of P-Signatures
- If R = RIP , compute a commitment CW = GSCom(W,openW ) where W =
BWPWitGen(pk, RIP , 0, m, X, ?) and compute a proof piX such that
e(
n∏
j=1
g
xj
j , ?6) = e(g,W )
Finally, the proof pi = ( {C?j}j=1,...,7, CW , C?,pi?, piX ).
- If R = RIP , compute Cg = GSCom(g, openg), {CWj}j=0,...,4 where Wj =
BWPWitGen( pk, RIP , 0, m, X, ?), and compute a proof piX such that
e(W0,W1) = e(g, g1) ? (3.28)
e(W1, g) = e(g1,W2) ?
e(W1, g2n) = e(g1,W3) ?
e(g/g, g?) = 1 ?
e(
n∏
j=1
g
xj
j , ?6) = e(g,W4)  e(W1, gn)
Finally, the proof pi = ( {C?j}j=1,...,7, {CWj}j=0,...,4, C?,pi?, piX ).
- If R = REQ compute a commitment CW = GSCom(W,openW ) where W =
BWPWitGen(pk, REQ, i, m, X, ?), CXi = GSCom(Xi, openXi) where Xi =
gxi1 , and compute proofs piW and piX such that
e(gi, ?6) = e(Xi, gn)e(g,W ) ? e(Xi/g
xi
1 , g
?)
Finally, the proof pi = ( {C?j}j=1,...,7, CW , CXi , C?,pi?, piW ,piX ).
- If R = REQ, compute { CWj }j=0,...,4 where Wj = BWPWitGen(pk, R
EQ,
0, m,X, ?), CXi = GSCom(Xi, openXi) where Xi = g
xi
1 , and compute proofs
piXi,W , {piWj}j=1,...,3 piXi , pig such that
e(gi, ?6)e(Xi, gn)
?1 = e(W1, gn)e(g,W ) ? (3.29)
e(W0,W1) = e(g, g1) ?
e(W1, g) = e(g1,W2) ?
e(W1, g2n) = e(g1,W3) ?
e(Xi/g
xi
1 , g
?) = e(g/g, g?) = 1
Finally, the proof pi = ( {C?j}j=1,...,7, {CWj}j=0,...,4, CXi ,C?, pi?, piXi,W , {piWj}j=1,...,3,
pi? ).
BWPEqCommProve(params,m, open, open?). Taken two opens open and open?, two
commitments comm and comm? can be respectively computed by C=GSCom(X,
3.4. BLOCK-WISE P-SIGNATURE SCHEMES 29
open) and C ?=GSCom(X ?, open?). Then a non-interactive zero-knowledge proof can
be constructed with f1 = (f1, 1, g), f2 = (1, f2, g), f3 = (f31, f32, f33) and prove
the tuple (?1, ?2, ?3) such that
C  C ? = (f?11 f
?3
31 f
?2
2 f
?3
32 , f
?3
33 )
Efficiency is an attractive point of block-wise P-signatures. Observing the non-interactive
proof algorithm of block-wise P-signatures, it is remarkable that the size of proof will not
grow as the amount of message blocks increases. Therefore we can conclude that con-
struction block-wise p-signatures is more efficient than the construction of multi-block
P-signatures.
Provable security of block-wise P-signatures
Block-wise P-signatures consider three kinds of forgeries in security proof. For the later
requirements of considering security of our revision on block-wise P-signatures, it is nec-
essary to review the attack model of it.
- Type-I F-forgeries show that an adversary outputs a forgery ?? = (??1 , ?
?
2 , ?
?
3 , ?
?
4, ?
?
5 ,
??6, r
?
i ), such that the triple (?
?
1 , ?
?
2, ?
?
3) is not queried before.
- Type-II F-forgeries show that an adversary outputs a forgery ?? = (??1 , ?
?
2 , ?
?
3 , ?
?
4 , ?
?
5 ,
??6, r
?
i ), such that the tuple (?
?
1 , ?
?
2 , ?
?
3) can be taken from j
?th queried. However,
??6 is different from ?j,6.
- Type-III F-forgeries show that an adversary outputs a forgery ?? = (??1 , ?
?
2 , ?
?
3, ?
?
4 ,
??5, ?
?
6, r
?
i ), such that the tuple (?
?
1 , ?
?
2 , ?
?
3 , ?
?
6) can be taken from j
?th queried
and the tuple can pass the signature verification. However, the adversary is capable
of generating a valid signature witness proof that passes the witness verification
procedure. This attack can be further discussed into four cases.
• Type-III-A attacks describe the adversary generates a predicate of the form (REQ,
i, F (x?t )) for some i ? 1, ..., n, and some random vector X
? = (x?1, ..., x
?
n) such
that x?i is not queried before and the forged witness W
? satisfies Witness-
Verify(pk, REQ, i, X?, W ?, ?) = 1.
• Type-III-B attacks describe the adversary generates a predicate of the form (REQ,
i, F (x?t )) for some i ? 1, ..., n, and some random vector X
? = (x?1, ..., x
?
n) such
that x?i is not queried before and the forged witness W
? satisfies Witness-
Verify(pk, REQ, i, X?, W ?, ?) = 1.
• Type-III-C attacks describe the adversary generates a predicate of the form (RIP ,
0, X?) for X? ? Znp , and the forged witness W
? satisfies Witness-Verify(pk,
RIP , i, X?, W ?, ?) = 1.
30 CHAPTER 3. Review of P-Signatures
• Type-III-D attacks describe the adversary generates a predicate of the form (RIP ,
0, X?) for X? ? Znp , and the forged witness W
? satisfies Witness-Verify(pk,
RIP , i, X?, W ?, ?) = 1.
Responding to the attack model described above, block-wise P-signatures are proved
secure on the hardness of HSDH problem, FlexDH problem and n-FlexDHE. To be more
specific, Type-I forgeries are proved secure on the security assumption of q-HSDH problem
while Type-II forgeries are proved secure on the assumption of FlexDH problem. Moreover,
all four different cases of Type-III forgeries are proved secure on the security assumption
of n-FlexDHE problem. Please see the full proofs in the original paper [4].
Chapter 4
Asymmetric Pairing Based
Block-wise P-signatures
The original block-wise P-signatures which is based on symmetric pairings are practically
inflexible and inefficient in implementation. For the choice of symmetric pairings in dif-
ferent security degree, up to now there are only two known curves which can be used to
implement symmetric pairings satisfying security requirements of AES-80 and AES-128;
therefore, block-wise P-signatures based on symmetric pairings are highly restricted to ap-
plied in different security context. Moreover, symmetric pairings take more time in pairing
computation than their asymmetric counterparts; therefore, block-wise P-signatures based
on symmetric pairings are practically inefficient. Motivated by the above two critical con-
siderations on efficiency issue, it is necessary to revise original block-wise P-signatures to
asymmetric pairings. In this chapter, we firstly propose a block-wise P-signatures based
on asymmetric pairings which are provably secure and computationally efficient.
4.1 Block-wise P-signatures based on asymmetric pairings
Our new block-wise P-signatures are modified based on the original block-wise P-signatures.
To achieve this goal, there are two critical points we need to carefully deal with in our
design. Firstly, the working environment is on asymmetric pairings, which do not provide
elements commutable property between groups G1 and G2. Therefore, it is necessary to
identify each equation containing appearance of swapping group elements in the origi-
nal block-wise P-signature scheme and try to design around for fitting the property of
asymmetric pairings. The second critical point is that the revised block-wise P-signature
scheme should be also provably secure against forgery attacks; otherwise, the revision
cannot be used in practical applications. With these two design principles, we propose a
new block-wise P-signatures based on Type-3 pairings and the algorithms are illustrated
as follows.
31
32 CHAPTER 4. Asymmetric pairing based block-wise P-signatures
Modification summary.
Pairing computation in original block-wise P-signatures significantly heavily rely on the
group elements commutation in verification procedure and this situation can be found in
the majority of pairing equations of block-wise P-signatures; fortunately, all of them can be
designed around. To solve this problem, we mainly adopt two techniques. Firstly, instead
of {gi}i?[1,2n]/{n+1} ? G in the public key setting, we extend it into two set of elements:
{gi}i?[1,2n]/{n+1} ? G1 and {hi}i?[1,2n]/{n+1} ? G2. This public key extension setting
can possess the advantage of preventing the original design from dramatical modification
and untwist most cases of group element commutation. Moreover, this technique will
not increase extra verification equation, which means the efficiency can be maintained.
Secondly, instead of ?2 = g
c ? G where c ? Z?p, we extend it into two parts, which are
?21 = g
c ? G1 and ?22 = h
c ? G2. This modification helps to solve the problem of
single element being used both in G1 and G2; However, this extension will result in one
extra unverified group element in signature ?22. Therefore, we have to increase another
verifying equation e(?21, ?
?1
22 )= 1GT in the signature verification to ensure the security of
signature. Using the above two techniques we successfully port block-wise P-signatures
into asymmetric pairings.
Our proposed block-wise P-signatures.
BWPSigSetup(1k). Taken security parameter k, this function generates params = (n,
G1, G2, GT , g1, h, e, f) where G1 and G2 are cyclic groups of prime order p
and generated by generators g1 and g2, e: G1 ? G2 ?? GT is a bilinear map and
U=(U1,U2) is common reference string (CRS) for SXDH-based Groth-Sahai proof.
BWPKeyGen(params). Choosing ?, ?, ?, ? ? Zp, u ? G2, U0 ? G1, computing
? = g?, ? = g? , U1 = h
?, gi = g
(?i) for i ? [1, ..., n, n + 2, ...2n] and hi = h
(?i) for
i ? [1, ..., n, n + 2, ...2n]. The secret-key sk = (?, ?, ?) and public-key pk = (u, ?,
?, U0, U1, {gi}i?[1,2n]/{n+1}, {hi}i?[1,2n]/{n+1}).
BWPSign(params, sk,m). Taken message m = (m1, ...,mn), the signer firstly chooses
r ? Zp and computes V = g
r 
∏n
j=1 g
mj
n+1?j=g
m1
n    g
mn
1  g
r. Secondly the signer
chooses c ? Zp and computes ? = (?1, ?21, ?22, ?3, ?4, ?5, ?6, r) where
?1 = h
?/?+c, (4.1)
?21 = g
c,
?22 = h
c,
?3 = u
c,
?4 = (U0 ? V
?)c,
?5 = V
c,
?6 = V
4.1. BLOCK-WISE P-SIGNATURES BASED ON ASYMMETRIC PAIRINGS 33
BWPVerify(params, pk,m, ?). Receiving message m = (m1, ...,mn) and ? = (?1, ?21,
?21, ?3, ?4, ?5, ?6, r), the verifier accepts the signature if ?6 = g
r 
∏n
j=1 g
mj
n+1?j and
e(?, h) = e(? ? ?21, ?1), (4.2)
e(?21, u) = e(g, ?3),
e(?4, h) = e(U0, ?22)e(?5, U1),
e(?5, h) = e(?6, ?22),
e(?21, ?
?1
22 ) = 1GT ,
BWPWitGen(params,R, i,m,X, ?). Taken relation R, index i, m = (m1, ...,mn), X =
(x1, ..., xn) and ? = (?1, ?2,?3,?4,?5,?6,r),
1. If R = REQ and mi = xi where i ? [1, n], compute the witness
W = gri 
n∏
j=1,j 6=i
g
mj
n+1?j+i. (4.3)
2. If R = REQ and mi 6= xi, where i ? [1, n], compute the witness W = (W0, W1,
W2,W3,W4) where
W0 = h
1/(mi?xi), (4.4)
W1 = g
(mi?xi)
1 ,
W2 = g
(mi?xi),
W3 = g
(mi?xi)
2n
W4 = g
r
i 
n∏
j=1,j 6=i
g
mj
n+1?j+i
3. If R = RIP , i = 0, and , m X = 0, compute the witness
W =
n∏
i=1
W xii for each (4.5)
Wi = g
r
i 
n∏
j=1,j 6=i
g
mj
n+1?j+i
4. If R = RIP , i = 0, and , m  X 6= 0, compute the witness W = (W0, W1,
34 CHAPTER 4. Asymmetric pairing based block-wise P-signatures
W2,W3,W4) where
W0 = g
1/(mi?xi), (4.6)
W1 = g
(mi?xi)
1 ,
W2 = g
(mi?xi),
W3 = g
(mi?xi)
2n
W4 =
n∏
i=1
W xi4,i for each
W4,i = g
r
i 
n∏
j=1,j 6=i
g
mj
n+1?j+i
BWPWitVerify(params, pk, i,X,W, ?). Taken public-key pk, index i, X = (x1, ..., xn),
witness W and a valid signature ? = (?1, ?21, ?22, ?3, ?4, ?5, ?6,r),
1. If R = REQ and i ? [1, n], output 1 if
e(?6, hi) = e(g1, hn)
xi  e(W,h) (4.7)
2. If R = REQ and i ? [1, n], parse W = (W0, W1, W2, W3, W4) and check if the
following equations hold.
e(?6  g
?xi
n+1?i, hi) = e(W1, hn)  e(W4, h) (4.8)
e(W1,W0) = e(g1, h),
e(W1, h) = e(W2, h1),
e(W1, h2n) = e(W3, h1),
3. If R = RIP and i = 0, output 1 if
e(W,h) = e(?6,
n∏
i=1
hxii ) (4.9)
4. If R = RIP and i = 0, parse W = (W0, W1, W2, W3, W4) and check if the
following equations hold.
e(?6,
n∏
i=1
hxii ) = e(W1, hn)  e(W4, h) (4.10)
e(W1,W0) = e(g1, h),
e(W1, h) = e(W2, h1),
e(W1, h2n) = e(W3, h1),
4.1. BLOCK-WISE P-SIGNATURES BASED ON ASYMMETRIC PAIRINGS 35
BWPSigObtain(pk,Mpart1, openpart1) ?? MBPSigIssue(sk, Vpart1,Mpart2). this in-
teractive protocol provides users to acquire signatures from some organizations.
1. the user chooses rpart1 ? Zp and computes a commitment Vpart1 = g
rpart1 ∏n1
j=1 g
mj
n+1?j for message Mpart1=(m1, ..., mn1). The the user sets openpart1 =
Mpart1=(m1, ..., mn1 , r
?) and computes a witness-indistinguishable proof for
knowledge of Mpart1 such that Vpart1 = g
rpart1 
∏n1
j=1 g
mj
n+1?j .
2. the signature issuer chooses rpart2, c ? Zp and computes
V = Vpart1 
n∏
j=n+1
g
mj
n+1?j (4.11)
?1 = h
?/(?+c),
?21 = g
c,
?22 = h
c,
?3 = u
c,
?4 = (U0(V  g
rpart2)?)c,
?5 = (V  g
rpart2)c,
?6 = V  g
rpart2
and return ?¯ = (?1, ?21, ?22, ?3, ?4, ?5, ?6, rpart2).
3. the user outputs ? = (?1, ?21, ?22, ?3, ?4, ?5, ?6, r) where r = rpart1 + rpart2.
BWPProve1(params, pk, i, S = {i},m,X, ?). Taken m = (m1, ...,mn), X = (x1, ..., xn)
and ? = (?1, ?21, ?22, ?3, ?4, ?5, ?6, r). Firstly this proof needs to compute { CXt,j
= GSCom(Xt,j , openxt,j) }t?S,j?{1,2,3} where {(Xt,1,Xt,2,Xt,2) = (g
xt
1 , g
xt , gxt2n)}t?S .
Secondly this proof computes commitments for {C?j = GSCom(?j , open?j )}j=1...7.
Thirdly this proof chooses ?7 ? G and ? ? Zp, computes C?7 = GSCom(?7, open?7)
and C?? = GSCom(??, open??), and then constructs a NIZK proof pitheta proving
the following equations.
e(?, h) = e(?? ?21, ?1) ? (4.12)
e(?21, u) = e(g, ?3) ?
e(?4, h) = e(U0, ?22)e(?5, U1) ?
e(?5, h) = e(?6, ?22) ?
e(?21, ?
?1
22 ) = 1GT ?
? = 1 ?
e(g?,?/?7) = 1GT
There are two cases for this proof.
36 CHAPTER 4. Asymmetric pairing based block-wise P-signatures
- If R = REQ, this proof computes commitment CW = GSCom(W , openW )
where W=BWWitGen(pk, REQ, i, m, X, ?) and then computes proofs pixi ,
{piXt,j}t?S,j=1,2 such that
e(?6, hi) = e(Xi,1, hn)  e(W,h) ? (4.13)
e(Xi,2, h1)  e(Xi,1, h) ?
e(Xi,2, h2n)  e(Xi,3, h)
The proof is pi = ({Cxt,j}t?S,j=1,2,3, {C?j}j=1,...,8, CW , C?, pi?, pixi , {pixt,j}t?S,j=1,2, ).
- If R = REQ, this proof computes commitments {CWj}j=0,...,4 to (W0, W1, W2,
W3, W4) and generates proofs pixi , piW satisfying
e(?6, hi)  e(Xi,1, hn)
?1 = e(W1, hn)  e(W4, h) ? (4.14)
e(W1,W0) = e(g1, h) ?
e(W1, h)  e(W2, h1) ?
e(W1, h2n) = e(W3, h1)
and also generates proof {piXt,j}t?S,j=1,2. The final proof is pi=( {Cxt,j}t?S,j=1,2,3,
{C?j}j=1,...,8, {CWj}j=0,...,4, C?,pi?, pixi , {pixt,j}t?S,j=1,2 ).
BWPProve2(params, pk,R, i,m, ,X, ?). Similar to BWPProve1, firstly this proof com-
putes commitments {C?j}j=1,...,8, C?, as well as proofs pi? and pixi . Then there are
four cases in this proof.
- If R = RIP , compute a commitment CW = GSCom(W,openW ) where W =
BWPWitGen(pk,RIP ,0,m,X,?) and compute a proof piX such that
e(?6,
n∏
j=1
h
xj
j ) = e(W,h) (4.15)
Finally, the proof pi = ( {C?j}j=1,...,8, CW , C?,pi?, piX ).
- If R = RIP , compute Cg = GSCom(g, openg), {CWj}j=0,...,4 where Wj =
BWPWitGen(pk, RIP , 0, m, X, ?), and select T ? mathbbG2 and compute a
proof piX such that
e(W1,W0) = e(g1, T ) ? (4.16)
e(W1, h) = e(W2, h1) ?
e(W1, h2n) = e(W3, h1) ?
e(g?, T/h) = 1GT ?
e(?6,
n∏
j=1
h
xj
j ) = e(W1, hn)  e(W4, h)
Finally, the proof pi = ( {C?j}j=1,...,8, {CWj}j=0,...,4, C?,pi?, piX ).
4.1. BLOCK-WISE P-SIGNATURES BASED ON ASYMMETRIC PAIRINGS 37
- If R = REQ compute a commitment CW = GSCom(W,openW ) where W =
BWPWitGen(pk,REQ,i,m,X,?), CXi = GSCom(Xi, openXi) where Xi = h
xi
1 ,
and compute proofs piW and piX such that
e(?6, hi) = e(gn,Xi)  e(W,h) ? (4.17)
e(g?,Xi/h
xi
1 ) = 1GT
Finally, the proof pi = ( {C?j}j=1,...,8, CW , CXi , C?,pi?, piW ,piX ).
- If R = REQ, compute { CWj }j=0,...,4 where Wj = BWPWitGen(pk, R
EQ, 0,
m, X, ?), CXi = GSCom(Xi, openXi) where Xi = g
xi
1 , and compute proofs
piXi,W , {piWj}j=1,...,3 piXi , pig such that
e(?6, hi)  e(Xi, hn)
?1 = e(W1, hn)  e(W4, h) ? (4.18)
e(W1,W0) = e(g1, h) ?
e(W1, h) = e(W2, h1) ?
e(W1, h2n) = e(W3, h1) ?
e(g? ,Xi/h
xi
1 , ) = 1GT ?
e(g? , T/h) = 1GT
Finally, the proof pi = ( {C?j}j=1,...,8, {CWj}j=0,...,4, CXi ,C?, pi?, piXi,W , {piWj}j=1,...,3,
pi? ).
BWPEqCommProve(params,m, open, open?). Taken two opens openX and openY , two
commitments CX and CY can be respectively computed by CX=GSCom(X, openX)
and CY=GSCom(Y , openY ). To prove X = Y , we can construct an non-interactive
zero-knowledge proof CX  CY = 1GT based on SXDH assumption.
Result of our modification on block-wise P-signatures.
Essentially our proposed block-wise P-signatures are based on Izabache`ne et al.’s idea
and extend the public key set with hi = h
(?i) for i ? [1, ..., n, n + 2, ...2n]. In this way
we successfully untwist the commutable property of Type-1 pairings and make block-wise
P-signature be constructed on Type-3 pairings. Figure 4.1 describes group elements used
in G1 and G2. From the table it is clear that group elements of public key set pk = (u,
?, ?, U0, U1, {gi}i?[1,2n]/{n+1}, {hi}i?[1,2n]/{n+1}), signature set ? = (?1, ?21, ?22, ?3, ?4,
?5, ?6) and witness set W = (W0, W1, W2, W3, W4) are now working in two different
groups G1 and G2 of asymmetric pairings, instead of working in a single group G of
symmetric pairings. From the view point of used group elements, our proposed block-wise
P-signatures use more group elements than Izabache`ne et al.’s construction. However,
from the view point of Type-3 pairing implementation, elements in group G1 is operated
on E(Fq) and elements in group G2 is operated on E(Fqk); hence our modification can get
benefit from the elements working on relatively small field E(Fq). The detailed efficiency
comparison will be discussed in Section 4.3.
38 CHAPTER 4. Asymmetric pairing based block-wise P-signatures
Figure 4.1: Elements used in G1 and G2 of proposed block-wise P-signatures
Function elements used in G1 elements used in G2
F ? signatures
KeyGen g h
Sign g, U0, {gi}
n
1 h, u
V erify g, U0, A,?, {gi}
n
1 , ?21, ?4, ?5, ?6 h, u, U1, ?1, ?22, ?3
WitGen? EQ {gi}
n
1 -
WitGen? EQ g, g2n, {gi}
n
1 h
WitGen? IP {gi}
n
1 , {Wi}
n
1 -
WitGen? IP g, g2n, {gi}
n
1 , {Wi}
n
1 h
WitV erify ? EQ g1, ?6,W h, hi, hn
WitV erify ? EQ g1, gn+1?i, ?6,W1,W2,W3,W4 h, h1, hi, hn, h2n,W0
WitV erify ? IP ?6,W h, {hi}
n
1
WitV erify ? IP g1, ?6,W1,W2,W3,W4 h, hi, h2n, {hi}
n
1 ,W0
4.2 Security consideration of our proposed block-wise P-
signatures
In this section we examine the security of our proposed block-wise P-signatures based on
asymmetric pairings. Please refer to Figure 4.2, this graph illustrates the logic of proof
reduction of our proposed block-wise P-signatures. Essentially, the left side of this graph
shows the way to prove that the original block-wise P-signatures is secure. In Section 3.4,
we have reviewed the attack model of block-wise P-signatures given by Izabache`ne et al.
[4], which contains three types of forgeries attacks. The block-wise P-signatures based on
symmetric pairings are proved secure against all three kinds of forgeries attacks; to be
more specific, Type-I forgeries are proved secure on the security assumption of q?HSDH
problem while Type-II forgeries are proved secure on the assumption of FlexDH problem.
Moreover, all four different cases of Type-III forgeries are proved secure on the security
assumption of n? FlexDHE problem.
Due to the fact that our asymmetric block-wise P-signatures are essential extended
from the original symmetric ones, the idea of defined attack models and proofs still work
on our designed scheme. However, the security assumptions of q ? HSDH, FlexDH
and n ? FlexDHE are defined in single group G; 1 to well fit into our requirements in
asymmetric pairings, we extend these definitions to asymmetric pairings and prove the
equivalence of them.
Definition 4.1. The q-External Hidden Strong Diffie-Hellman problem (q-XHSDH)
This definition extends Definition 2.4 from group security assumption to asymmetric pair-
1Please refer q ? HSDH problem to Definition 2.4, F lexDH problem to Definition 2.5, and n ?
F lexDHE problem to Definition 2.7.
4.2. SECURITYCONSIDERATIONOF OUR PROPOSEDBLOCK-WISE P-SIGNATURES39
Figure 4.2: Security reduction from symmetric pairings to asymmetric pairings
ings. given two group G1 and G2, and define bilinear map e : G1?G2 ?? GT . q-XHSDH
assumes q-HSDH problem is hard both in G1 and G2
Lemma 4.1. if q-HSDH is secure against forgery, then q-XHSDH is also secure against
forgery.
Proof sketch. Assume an adversary A want to solve q ?HSDH problem with the
help of procedure B that can solve q ? XHSDH problem. Without loss of generality
we make an assumption that the oracle of A is set with two group generator such that
g ? G1 and h ? G2; in other words, once procedure B requires a oracle query, oracle A
will chooses ci ? Z
?
p and answers (g
1/(?+ci), gci , uci1 ) and (h
1/(?+ci), hci , uci2 ) by asking
his oracle twice. After q times’ oracle queries, procedure B outputs a tuple (g1/(?+c), gc,
uc1, h
1/(?+c), hc, uc2) where c 6= ci. Then the adversary A outputs (g
1/(?+c), gc, uc1) as a
forgery to q ?HSDH problem.
Here we argue that making the oracle of A answer two tuples (g1/(?+ci), gci , uci1 )
and (h1/(?+ci), hci , uci2 ) will not increase the probability of success for procedure B to
output the tuple (g1/(?+c), gc, uc1, h
1/(?+c), hc, uc2). The reason is that (g, u1) and (h,
u2) are randomly chosen from G1 and G2, which means procedure B simultaneously and
independently deals with two q ? HSDH problems. Therefore, the hardness of solving
q ?XHSDH problem is equal to solving the problem of q ?HSDH.
Definition 4.2. The Flexible External Diffie-Hellman problem (FlexXDH), given
two groups G1 and G2 of order p, (g, g
a, gb) ? G31 and (h, h
a, hb) ? G32 where a, b ? Z
?
p.
finding tuples (gµ, gµa, gµb) and (hµ, hµa, hµb) such that µ 6= 0.
Lemma 4.2. if FlexDH is secure against forgery, FlexXDH is also secure against forgery.
Proof sketch. Similarly let the adversary A’s oracle with two group elements g ? G1
and h ? G2. A uses a procedure B which can solve the FlexXDH problem, and answer
procedure B’s oracle queries by choosing ai, bi ? Z
?
p and response (g, g
ai , gbi) and (h, hai ,
40 CHAPTER 4. Asymmetric pairing based block-wise P-signatures
hbi). After q times’ queries, procedure B output {(gµ, gµa, gµb), (hµ, hµa, hµb)} such that
µ 6= 0. Finally the adversary outputs (gµ, gµa, gµb) as the answer to FlexDH problem.
Definition 4.3. The Flexible External n-Diffie-Hellman Exponent Problem (n-
FlexXDHE), given two group G1 and G1 of order p, (g, g1, ..., gn, gn+2, ..., g2n) ? G
2n
1 ,
(h, h1, ..., hn, hn+2, ..., h2n) ? G
2n
2 such that gi = g
(?i) and hi = h
(?i) where ? ? Z?p
and i ? [1, 2n] \ {n+ 1}, compute triples (gµ, gµn+1, g
µ
2n) and (h
µ, hµn+1, h
µ
2n) where µ ? Z
?
p,
gn+1 = g
?n+1 and hn+1 = h
?n+1 .
Lemma 4.3. if n? FlexDHE is secure against forgery, n? FlexXDHE is also secure
against forgery.
Proof sketch. Similarly let the adversary A’s oracle with two group elements g ? G1
and h ? G2. A uses a procedure B which can solve the n ? FlexXDHE problem, and
answer procedure B’s oracle queries by choosing ?j ? Z
?
p and response (g, g1, ..., gn,
gn+2, ..., g2n) ? G
2n
1 and (h, h1, ..., hn, hn+2, ..., h2n) ? G
2n
2 such that gi = g
(?ij ) and
hi = h
(?ij ). After q times’ queries, procedure B output {(gµ, gµn+1, g
µ
2n), (h
µ, hµn+1, h
µ
2n) }
where µ ? Z?p, gn+1 = g
?n+1 and hn+1 = h
?n+1 . Finally the adversary outputs (gµ, gµa,
gµb) as the answer to n? FlexDHE problem.
Theorem 4.1. Our asymmetric block-wise P-signatures are proved secure on the hardness
of q-XHSDH problem, FlexXDH problem and n-FXDHE problem.
Proof sketch. We have extended the security assumptions of q ?HSDH, FlexDH
and n?FlexDHE to security assumptions of q?XHSDH, FlexXDH and n?FlexXDHE,
and prove the security of them. Therefore, our asymmetric pairing based block-wise P-
signature can be proven to be secure against all three types of forgery attacks. The prove
can be slightly modified from the original proofs provided by [4] and hence we will omit
the proofs here. In this way, the reduction proof of right-hand side of Figure 4.2 can be
constructed, and our proposed block-wise P-signatures based on asymmetric pairings can
be proved secure.
4.3 Efficiency analysis of our proposed block-wise P-signatures
This section focuses on evaluating efficiency of our proposed asymmetric pairing based
block-wise P-signatures both in theoretical part and in practical part. To evaluate theoret-
ical performance of proposed asymmetric pairing based block-wise P-signatures, without
loss of generality we calculate the group elements used in pairing computation. In terms of
practical implementation, we implement block-wise P-signatures both in symmetric pair-
ings and asymmetric pairings, and then measure the running time of them for efficiency
comparison.
4.3. EFFICIENCYANALYSIS OF OUR PROPOSED BLOCK-WISE P-SIGNATURES41
Figure 4.3: The number of group elements used in Type-1 pairing-based and Type-3
pairing-based block-wise P-signatures – F-signature part
Function BWPS in Type-1 BWPS in Type-3
(# of elements in G) (# of elements in G1) (# of elements in G2)
F ? signatures
KeyGen 1 1 1
Sign n+3 n+2 2
V erify n+12 n+8 6
WitGen? EQ n n 0
WitGen? EQ n+1 n+2 1
WitGen? IP 2n 2n 0
WitGen? IP 2n+2 2n+2 1
WitV erify ? EQ 6 3 3
WitV erify ? EQ 12 7 6
WitV erify ? IP n+3 2 n+1
WitV erify ? IP n+8 6 n+4
4.3.1 Theoretical analysis of proposed block-wise P-signatures
Here we compare theoretical performance of block-wise P-signatures. Firstly let us exam-
ine the performance of F-unforgeable signatures in block-wise P-signatures. Please refer
to Figure 4.3, roughly the result can be classified into three cases. The first case, such as
key generation, signature generation, witness verification of REQ and witness verification
of RIP , the Type-3 setting use one more group element, h ? G2, than the Type-1 setting.
Next, the second case, such as signature verification, witness generation of REQ, and wit-
ness generation of RIP , the asymmetric setting use two more group elements, h, ?22 ? G2,
than the symmetric setting. The third case, such as witness generation of REQ, witness
generation of RIP , witness verification of REQ, and witness verification of RIP , , Both
the asymmetric setting and symmetric setting use the same number of group elements
since the asymmetric setting only use one group generator, g ? G1 or h ? G2, and do not
contain the computation of ?21 ? G1 and ?22 ? G2. In short, the efficiency of our designed
F-unforgeable signature are theoretically competitive to the symmetric one.
In terms of signature proof generation and verification, please refer to Figure 4.4 and
Fig 4.5, our designed block-wise P-signatures show significant improvement in theoretical
analysis. The major advantage comes from modifying the essential component, Groth-
Sahai proof [3] of signature proof generation, from DLIN-based structures to SXDH-based
structures. It is evident that the SXDH-based Groth-Sahai proofs use less group ele-
ments than their DLIN-based counterpart. 2 Signature proof generation of block-wise
2Please see the used group elements comparison between DLIN setting and SXDH setting in Figure 3.3
and Figure 3.2.
42 CHAPTER 4. Asymmetric pairing based block-wise P-signatures
Figure 4.4: The number of group elements used in Type-1 pairing-based block-wise P-
signatures – Signature proof part[4]
Function Size Generation Verification
(# of elements in G) (# of MultiExps) (# of Pairings)
Algorithm SigProve1
R = REQ 80 80 MultiExp 621 Pairing
R = REQ 101 101 MultiExp 828 Pairing
Algorithm SigProve2
R = RIP 65 66 MultiExp 558 Pairing
R = RIP 104 105 MultiExp 828 Pairing
R = REQ 77 77 MultiExp 477 Pairing
R = REQ 107 107 MultiExp 846 Pairing
Figure 4.5: The number of group elements used in Type-3 pairing-based block-wise P-
signatures – Signature proof part
Function Size Generation Verification
(# of elements in (# of MultiExps) (# of Pairings)
G1 and G2)
Algorithm SigProve1
R = REQ 63 63 MultiExp 276 Pairing
R = REQ 77 77 MultiExp 368 Pairing
Algorithm SigProve2
R = RIP 53 54 MultiExp 248 Pairing
R = RIP 83 84 MultiExp 368 Pairing
R = REQ 61 61 MultiExp 212 Pairing
R = REQ 85 85 MultiExp 376 Pairing
P-signatures use three different kinds of equations, which are pairing product equations,
linear pairing equations and linear multi-scalar multiplication equations. In DLIN setting,
pairing product equations cost nine group elements, linear pairing equations cost three
group elements, and linear multi-scalar multiplication equations cost two group elements.
However, SXDH setting requires less to construct proofs: pairing product equations cost
eight group elements, linear pairing equations cost two group elements, and linear multi-
scalar multiplication equations cost one group elements. Such the change significant affect
the theoretical efficiency of signature proof generation and verification.
For example, let us look the case of R = REQ. In DLIN setting, we firstly need to
make (3+ 7+ 5+ 1) = 16 commitments and require 16  3 = 48 group elements in G. And
4.3. EFFICIENCYANALYSIS OF OUR PROPOSED BLOCK-WISE P-SIGNATURES43
then the proof generation contains three pairing product equations, eight linear pairing
product equations and one linear multi-scalar multiplication equation, which totally cost
(3  9 + 8  3 + 1  2) = 53 group elements in G. Therefore, constructing signature proofs
totally cost 48 + 53 = 101 group elements in G. However, in SXDH setting, we firstly
need to make (3 + 8+ 5+ 1) = 17 commitments and require 17  2 = 34 group elements in
G1 and G2. And then the proof generation contains three pairing product equations, nine
linear pairing product equations and one linear multi-scalar multiplication equation, which
totally cost (3  8+9  2+1  1) = 43 group elements in G1 and G2. Therefore, constructing
signature proofs totally cost 34+43 = 77 group elements in G1 and G2. The SXDH setting
save 24 group elements than DLIN setting, which means nearly 23.76%’s enhancement.
In fact, using less group elements means using less multi-exponential computation and
multi-exponential computation take the major computation time in most cryptographic
algorithms; hence this improvement is enormous. Overall in theoretical analysis, Please
refer to Figure 4.6, our new signature proof generation based on SXDH can save nearly
20% of multi-exponential computation.
Figure 4.6: Efficiency comparison between DLIN-based and SXDH-based signature proof
generation
Function (# of MultiExp in (# of MultiExp in Improvement (%)
DLIN-based proof SXDH-based proof
Algorithm SigProve1
R = REQ 80 63 21.25
R = REQ 101 77 23.76
Algorithm SigProve2
R = RIP 66 54 18.18
R = RIP 105 84 20
R = REQ 77 61 20.77
R = REQ 107 85 20.56
In terms of signature proof verification, take R = REQ for example, naive verification
procedure needs 621 pairing computation whether in DLIN setting while SXDH setting
only require 276 pairings. The amount of pairing computation between these two settings
present a enormous difference.
Overall in theoretical analysis, our proposed block-wise P-signatures cost competitive
group elements in the part of F-unforgeable signature and achieve significant improvement
in the part of signature proof generation and verification.
4.3.2 Practical analysis of asymmetric block-wise P-signatures
After seeing the theoretical efficiency analysis of block-wise P-signatures, in this section, we
implement block-wise P-signatures both based on Type-1 pairings and Type-3 pairings.
44 CHAPTER 4. Asymmetric pairing based block-wise P-signatures
Our experiment environment uses computer with Intel Core i5-520M processor ( 3MB
cache and 2.40 GHz) and 2.92 GB random access memory (RAM). The operation system
is Microsoft Windows 7 32-bit. Moreover, we adopt MIRACL Crypto. SDK to do pairing
computation.
MIRACL SDK Library.
MIRACL SDK Library [34], stands for Multi-precision Integer and Rational Arithmetic
Cryptographic Library, is provided by Certivox and is a powerful library for implementing
cryptographic application. MIRACL library is well-known for its supports for state-of-
the-art cryptographic primitives, including implementations of elliptic curves and bilinear
pairings. In the implementation of bilinear pairings, MIRACL library supports Type-1
pairings and Type-3 pairings respectively. For Type-1 pairings, two kinds of pairing-
friendly curves are provided, which are EtaT pairings over GF (2m) and Tate pairing over
GF (p) respectively. And both of two pairings implementation support security degree of
AES-80 and AES-128. In terms of Type-3 pairings, there are five pairing-friend curves
implemented in MIRACL library, which are
- Cocks-Pinch (CP)[35] curve supports security degree of AES-80.
- Miyaji-Nakabayashi-Takano (MNT)[36] curve supports security degree of AES-80.
- Barreto-Naehrig (BN)[37] curve supports security degree of AES-128 and AES-192.
- Kachisa-Schaefer-Scott (KSS)[38] curve supports security degree of AES-192.
- Barreto-Lynn-Scott (BLS)[39] curve supports security degree of AES-256.
From the above pairing curves provided by MIRACL library, it is evident that Type-3
pairings give more flexibility from different security degree. In fact, for security degree
higher than AES-128 there exists no efficient curves for Type-1 pairings.
Experiment result
In our experiment, considering limitation of pairing curves provided by MIRACL library
and practical security issue, we choose curves of Tate Pairing-128 and BN-128 respectively
to implement Type-1 pairing based block-wise P-signatures and our proposed scheme. And
to set a benchmark for every cases in block-wise P-signatures, we choose one message block
for the experiment, even though our implemented block-wise P-signatures can support
multiple message blocks. Moreover, to eliminate the random bias that could happen in
our testing environment, our experiment repeats 20 runs and then do statistical analysis
in IBM SPSS software. the detailed experiment results are collected in Appendix A.1 and
Appendix A.2, and the standard deviation of our experiments show negligibly small for
the performance of block-wise P-signatures based on Type-1 pairings and Type-3 pairings
to be evidently distinguished.
4.3. EFFICIENCYANALYSIS OF OUR PROPOSED BLOCK-WISE P-SIGNATURES45
Figure 4.7: Efficiency comparison between Type-1 pairing based and Type-3 pairing based
block-wise P-signatures (using pairing curves BN-128)
ID Function BWPS in Type-1 BWPS in Type-3 Improvement
(/sec.) (/sec.) (%)
F ? signatures
1 Sign 0.3013 0.0492 83.67
2 V erify 1.2829 0.7039 45.13
3 WitGen? EQ 0.044 0.009 79.54
4 WitGen? EQ 0.0141 0.0492 85.04
5 WitGen? IP 0.043 0.0101 76.51
6 WitGen? IP 0.1002 0.0174 82.63
7 WitV erify ? EQ 0.4273 0.2331 45.44
8 WitV erify ? EQ 1.2307 0.6985 43.24
9 WitV erify ? IP 0.2671 0.1564 41.44
10 WitV erify ? IP 1.1901 0.6931 41.76
SigProve1
11 SigProve1 ? EQ >189 4.6203 >97.55
12 SigProve1 ? EQ >252 6.0987 >97.57
13 SigV erify1 ? EQ >252 13.4915 >94.64
14 SigV erify1 ? EQ >336 18.4456 >94.51
SigProve2
15 SigProve2 ? EQ >152 4.1008 >97.3
16 SigProve2 ? EQ >224 6.1149 >97.27
17 SigProve2 ? IP >128 3.5716 >97.2
18 SigProve2 ? IP >232 6.4235 >97.23
19 SigV erify2 ? EQ >209 12.1482 >94.18
20 SigV erify2 ? EQ >308 18.4185 >94.01
21 SigV erify2 ? IP >176 10.7983 >93.86
22 SigV erify2 ? IP >319 18.8304 >94.09
The experiment results are collected in Figure 4.7. For the F-unforgeable signatures of
block-wise P-signatures, Type-3 pairing-based implementation shows enormous efficiency
while comparing with Type-1 pairing-based implementation. From theoretical analysis of
F-unforgeable in Figure 4.3, it is clear that Type-3 construction costs slightly more group
elements than Type-1 construction; however, the experiment shows extreme efficiency
of Type-3 construction. Here we would like to discuss the efficiency of F-unforgeable
signatures in two groups. The first group contains signature generation Sign and four
cases of witness generationWitGen?EQ,WitGen?EQ,WitGen?IP andWitGen?IP .
The similarity of functions in the first group is that the majority of their computation is
on multiplication of group elements. From the experiment result, it is clear that functions
46 CHAPTER 4. Asymmetric pairing based block-wise P-signatures
in the first group which are ported to Type-3 construction can save approximately 76% to
85%’s running time, which implicitly illustrates elements multiplication in Type-3 pairings
is enormously efficient while comparing to Type-1 pairings. The second group contains
signature verification V erify and four cases of witness verification WitV erify ? EQ,
WitV erify ? EQ, WitV erify ? IP and WitV erify ? IP . These functions take their
major time on doing pairing computation. The experiment result shows transferring F-
unforgeable signatures from Type-1 to Type-3 can save nearly 41% to 45%’s running
time, which is also a great improvement. The result also implicitly illustrates that doing
pairing computation in Type-3 pairings is twice as fast as doing pairing computation in
Type-1 pairings. In short, even though it increases several group elements while porting
F-unforgeable signatures to Type-3 pairings, efficiency can gain significant benefit from
the porting work.
In terms of signature proof generation and verification, Type-3 pairing-based imple-
mentation shows tremendous efficiency while comparing with Type-1 pairing-based imple-
mentation. The efficiency can be analyzed from a general view, which is to compare the
theoretical analysis with practical analysis. From Figure 4.4 and Figure 4.5 we have un-
derstood the fundamental techniques of signature proof generation and verification is quite
different; Type-1 construction is based on DLIN-based Groth-Sahai proofs while Type-3
construction is based on SXDH-based Groth-Sahai proofs. It is clear that SXDH-based
Groth-Sahai proofs require less group elements than DLIN-based one; therefore, Type-3
based signature proof generation and verification are inherently at advantageous position,
approximately 20% faster than Type-1 construction in theoretical analysis. Moreover, con-
structing signature proof and doing verification in block-wise P-signature also inherently
contains huge number of element multiplication and pairing computation, which means a
great deal of running time in generating proof and verification. From our experiment of
even only one message block, signature proof generation and verification take at least 2
minutes to generate a signature proof of SigProve2 ? IP and take at least 3 minutes to
do verification of SigV erify2 ? IP , which is not an affordable running time in practical
application. However, Type-3 construction shows acceptable running time in signature
proof generation and verification, which take about 3.5 seconds in signature proof gen-
eration of SigProve2 ? IP and about 10.7 seconds in verification procedure. Overall
in signature proof generation and verification, the practical experiment result shows in
Figure 4.7 is consistent with theoretical analysis shows in Figure 4.6; moreover, Type-3
construction dramatically extend the advantage of efficiency to approximately 93%? 97%
while comparing with Type-1 construction.
Chapter 5
Optimization of Block-wise
P-signatures
We have successfully redesigned block-wise P-signatures based on asymmetric pairings,
and our proposed new scheme achieves significant improvement in efficiency. Nonetheless,
the efficiency of our designed block-wise P-signatures can be further improved by applying
optimization techniques in our design. In this chapter we describe the techniques we use to
improve asymmetric pairing based block-wise P-signatures and measure the performance
of them.
In Chapter 2.4 we have reviewed two optimization techniques, which are fixed argument
optimization and calculation of pairing product respectively. These two optimization
techniques describe how the fixed elements in G1 and G2 result in performance difference.
Here we focuses on fixed argument optimization and conclude them into three different
cases. The first case is that if both arguments X ? G1 and Y ? G2 are fixed, the power
of pairing product e(X,Y )z for some z ? Z?p can be precomputed. The second case shows
that if the left-hand side argument X ? G1 is fixed, the pairing computation e(X, ) can
be precomputed. The third case is that if the left-hand side argument X ? G1 is fixed,
the computation of group element multiplication Xz for some z ? Z?p can be precomputed.
With these three observation, we try to improve our proposed block-wise p-signatures.
5.1 Optimization of our proposed block-wise P-signature
To apply these three optimization techniques in block-wise p-signatures, it is necessary
to examine each function algorithm to find out the repeated pattern appeared in pairing
computation, so that our proposed scheme can be further improved by the technique of
fixed argument optimization. After fine tuning every function algorithms, an optimized
asymmetric pairing based block-wise P-signature is described as follows.
47
48 CHAPTER 5. Optimization of block-wise P-signatures
Figure 5.1: Optimization example – Signature verification of block-wise P-signatures be-
fore/after optimization
BWPS in Type-3 before optimization BWPS in Type-3 after optimization
e(?, h) = e(?  ?21, ?1) e(g,?) = e(?  ?21, ?1),
e(?21, u) = e(g, ?3) e(?21, u) = e(g, ?3),
e(?4, h) = e(U0, ?22)  e(?5, U1) e(g, ?4) = e(?21, U0)  e(U1, ?5),
e(?5, h) = e(?6, ?22) e(g, ?5) = e(?21, ?6),
e(?21, ?
?1
22 ) = 1GT e(?21, ?
?1
22 ) = 1GT ,
Optimization summary.
Our naively porting to type-3 pairing based block P-signatures leaves a significant space
for optimization. The first observation is that group generators g ? G1 and h ? G2 are
repeatedly used in the verification procedure, including signature verification, witness veri-
fication and proof verification, which leaves an opportunity for argument pre-computation.
However, in implementation of Type-3 pairings G1 ? G2 ?? GT , pairing computation of
fixed elements in G1 can be sped up with fixed argument pre-computation technique. With
this observation, we could align all equations in verification procedures to the form of fixed
left-hand side argument. For example in signature verification, please refer to Figure 5.1,
e(?4, h) in the third equation and e(?5, h) in the fourth equation can be transferred into
the form of e(g, ?4) and e(g, ?5), in this way the form of e(g, ) and can be precomputed
with fixed argument optimization in implementation. Similarly the case e(, ?22) can be
also aligned as e(?21, ). However, since our working environment is in asymmetric pair-
ings, which group elements in G1 and G2 cannot be arbitrarily exchanged, it is necessary
to reconsider in which group arguments work. Fortunately the public key extension of our
proposed block-wise P-signatures provides us a flexible way to decide in which group the
argument work with extra burden; hence the algorithm re-adjusting can be easily achieved.
The second issue is to decide which pairing form, e(A = ga, B = hb) or e(B = gb, A =
ha), can receive most efficiency enhancement for our proposed block-wise P-signatures.
To achieve optimized performance of pairing pre-computation, it is critical to identify the
group elements that are frequently used for the computation of element multiplication on
elliptic curves; so that we can decide in which group the arguments work. It is obvious
that generators g ? G1 and h ? G2 are most frequently used for element multiplication.
The generation of public key set gi = g
(?i) for i ? [1, ..., n, n + 2, ...2n] and hi = h
(?i) for
i ? [1, ..., n, n+2, ...2n] are clear examples. In fact, Among all arguments in the optimized
block-wise P-signatures, we found arguments g, h, g1, h1 and h2n could be the most
used arguments for all computation. Therefore, these arguments can be precomputed in
implementation.
The last optimization technique is to find pairing form where arguments both in G1
and G2 are fixed, so that the power of pairing can be precomputed. In our examination
5.1. OPTIMIZATION OF OUR PROPOSED BLOCK-WISE P-SIGNATURE 49
there shows only one case e(g1, hn)
xi where xi is the i
?thmessage block among all functions
is repeatedly used; With this observation, we can conclude the powering pre-computation
of e(g1, hn) show less efficiency improvement for our proposed block-wise P-signatures.
Our proposed optimized block-wise P-signatures.
With the above three observations we readjust our Type-3 pairing based block-wise P-
signatures.
BWPSigSetup(1k). Taken security parameter k, this function generates params = (n,
G1, G2, GT , g, h, e, f) where G1 and G2 are cyclic groups of prime order p and
generated by generators g and h, e: G1?G2 ?? GT is a bilinear map and U=(U1,U2)
is common reference string (CRS) for SXDH-based Groth-Sahai proof.
BWPKeyGen(params). Choosing ?, ?, ?, ? ? Zp, u ? G2, U0 ? G2, computing
? = g?, ? = h? , U1 = g
? , gi = g
(?i) for i ? [1, ..., n, n + 2, ...2n] and hi = h
(?i) for
i ? [1, ..., n, n + 2, ...2n]. The secret-key sk = (?, ?, ?) and public-key pk = (u, ?,
?, U0, U1, {gi}i?[1,2n]/{n+1}, {hi}i?[1,2n]/{n+1}).
BWPSign(params, sk,m). Taken message m = (m1, ...,mn), the signer firstly chooses
r ? Zp and computes V = h
r 
∏n
j=1 h
mj
n+1?j=h
m1
n    h
mn
1  h
r. Secondly the signer
chooses c ? Zp and computes ? = (?1, ?21, ?22, ?3, ?4, ?5, ?6, r) where
?1 = h
?/?+c, (5.1)
?21 = g
c,
?22 = h
c,
?3 = u
c,
?4 = (U0  V
?)c,
?5 = V
c,
?6 = V
BWPVerify(params, pk,m, ?). Receiving message m = (m1, ...,mn) and ? = (?1, ?21,
?22, ?3, ?4, ?5, ?6, r), the verifier accepts the signature if ?6 = g
r 
∏n
j=1 g
mj
n+1?j and
e(g,?) = e(?  ?21, ?1), (5.2)
e(?21, u) = e(g, ?3),
e(g, ?4) = e(?21, U0)  e(U1, ?5),
e(g, ?5) = e(?21, ?6),
e(?21, ?
?1
22 ) = 1GT ,
BWPWitGen(params,R, i,m,X, ?). Taken relation R, index i, m = (m1, ...,mn), X =
(x1, ..., xn) and ? = (?1, ?2, ?3, ?4, ?5, ?6, r),
50 CHAPTER 5. Optimization of block-wise P-signatures
1. If R = REQ and mi = xi where i ? [1, n], compute the witness
W = hri 
n∏
j=1,j 6=i
h
mj
n+1?j+i. (5.3)
2. If R = REQ and mi 6= xi, where i ? [1, n], compute the witness W = (W0, W1,
W2, W3, W4) where
W0 = g
1/(mi?xi), (5.4)
W1 = h
(mi?xi)
1 ,
W2 = h
(mi?xi),
W3 = h
(mi?xi)
2n
W4 = h
r
i 
n∏
j=1,j 6=i
h
mj
n+1?j+i
3. If R = RIP , i = 0, and , m X = 0, compute the witness
W =
n∏
i=1
W xii for each (5.5)
Wi = h
r
i 
n∏
j=1,j 6=i
h
mj
n+1?j+i
4. If R = RIP , i = 0, and , m  X 6= 0, compute the witness W = (W0, W1,
W2,W3,W4) where
W0 = g
1/(mi?xi), (5.6)
W1 = h
(mi?xi)
1 ,
W2 = h
(mi?xi),
W3 = h
(mi?xi)
2n
W4 =
n∏
i=1
W xi4,i for each
W4,i = h
r
i 
n∏
j=1,j 6=i
h
mj
n+1?j+i
BWPWitVerify(params, pk, i,X,W, ?). Taken public-key pk, index i, X = (x1, ..., xn),
witness W and a valid signature ? = (?1, ?21, ?22, ?3, ?4, ?5, ?6,r),
1. If R = REQ and i ? [1, n], output 1 if
e(gi, ?6) = e(g1, hn)
xi  e(g,W )
5.1. OPTIMIZATION OF OUR PROPOSED BLOCK-WISE P-SIGNATURE 51
2. If R = REQ and i ? [1, n], parse W = (W0, W1, W2, W3, W4) and check if the
following equations hold.
e(gi, ?6  h
?xi
n+1?i) = e(gn,W1)  e(g,W4) (5.7)
e(W0,W1) = e(g1, h),
e(g,W1) = e(g1,W2),
e(g2n,W1) = e(g1,W3),
3. If R = RIP and i = 0, output 1 if
e(g,W ) = e(
n∏
i=1
gxii , ?6)
4. If R = RIP and i = 0, parse W = (W0, W1, W2, W3, W4) and check if the
following equations hold.
e(
n∏
i=1
gxii , ?6) = e(gn,W1)  e(g,W4)
e(W0,W1) = e(g1, h),
e(g,W1) = e(g1,W2),
e(g2n,W1) = e(g1,W3),
BWPSigObtain(pk,Mpart1, openpart1) ?? MBPSigIssue(sk, Vpart1,Mpart2). this in-
teractive protocol provides users to acquire signatures from some organizations.
1. the user chooses rpart1 ? Zp and computes a commitment Vpart1 = h
rpart1 ∏n1
j=1 h
mj
n+1?j for message Mpart1=(m1, ..., mn1). The the user sets openpart1
= Mpart1=(m1, ..., mn1 , r
?) and computes a witness-indistinguishable proof for
knowledge of Mpart1 such that Vpart1 = h
rpart1 
∏n1
j=1 h
mj
n+1?j .
2. the signature issuer chooses rpart2, c ? Zp and computes
V = Vpart1 
n∏
j=n+1
h
mj
n+1?j (5.8)
?1 = h
?/(?+c),
?21 = g
c,
?22 = h
c,
?3 = u
c,
?4 = (U0(V  g
rpart2)?)c,
?5 = (V  g
rpart2)c,
?6 = V  g
rpart2
and return ?¯ = (?1, ?21, ?22, ?3, ?4, ?5, ?6, rpart2).
52 CHAPTER 5. Optimization of block-wise P-signatures
3. the user outputs ? = (?1, ?21, ?22, ?3, ?4, ?5, ?6, r) where r = rpart1 + rpart2.
BWPProve1(params, pk, i, S = {i},m,X, ?). Taken m = (m1, ...,mn), X = (x1, ..., xn)
and ? = (?1, ?21, ?22, ?3, ?4, ?5, ?6, r). Firstly this proof needs to compute { CXt,j
= GSCom(Xt,j , openxt,j) }t?S,j?{1,2,3} where {(Xt,1,Xt,2,Xt,2) = (h
xt
1 , h
xt , hxt2n)}t?S .
Secondly this proof computes commitments for {C?j = GSCom(?j , open?j )}j=1...7.
Thirdly this proof chooses ?7 = ? ? G and ? = 1 ? Zp, computes C?7 = GSCom(?7,
open?7) and C?? = GSCom(??, open?? ), and then constructs a NIZK proof pitheta
proving the following equations.
e(g, ?7) = e(?  ?21, ?1) ? (5.9)
e(?21, u) = e(g, ?3) ?
e(g, ?4) = e(?21, U0)  e(U1, ?5) ?
e(g, ?5) = e(?21, ?6) ?
e(?21, ?
?1
22 ) = 1GT ?
? = 1 ?
e(g?,?/?7) = 1GT
There are two cases for this proof.
- If R = REQ, this proof computes commitment CW = GSCom(W , openW )
where W = BWWitGen(pk, REQ, i, m, X, ?) and then computes proofs pixi ,
{piXt,j}t?S,j=1,2 such that
e(gi, ?6) = e(gn,Xi,1)  e(g,W ) ? (5.10)
e(g1,Xi,2)  e(g,Xi,1) ?
e(g2n,Xi,2)  e(g,Xi,3)
The proof is pi = ({Cxt,j}t?S,j=1,2,3, {C?j}j=1,...,8, CW , C?, pi?, pixi , {pixt,j}t?S,j=1,2, ).
- If R = REQ, this proof computes commitments {CWj}j=0,...,4 to (W0, W1, W2,
W3, W4) and generates proofs pixi , piW satisfying
e(gi, ?6)  e(gn,Xi,1)
?1 = e(gn,W1)  e(g,W4) ? (5.11)
e(W0,W1) = e(g1, h) ?
e(g,W1)  e(g1,W2) ?
e(g2n,W1) = e(g1,W3)
and also generates proof {piXt,j}t?S,j=1,2. The final proof is pi=( {Cxt,j}t?S,j=1,2,3,
{C?j}j=1,...,8, {CWj}j=0,...,4, C?,pi?, pixi , {pixt,j}t?S,j=1,2 ).
BWPProve2(params, pk,R, i,m, ,X, ?). Similar to BWPProve1, firstly this proof com-
putes commitments {C?j}j=1,...,8, C?, as well as proofs pi? and pixi . Then there are
four cases in this proof.
5.1. OPTIMIZATION OF OUR PROPOSED BLOCK-WISE P-SIGNATURE 53
- If R = RIP , compute a commitment CW = GSCom(W,openW ) where W =
BWPWitGen(pk,RIP ,0,m,X,?) and compute a proof piX such that
e(
n∏
j=1
g
xj
j , ?6) = e(g,W ) (5.12)
Finally, the proof pi = ( {C?j}j=1,...,8, CW , C?,pi?, piX ).
- If R = RIP , compute Cg = GSCom(g, openg), {CWj}j=0,...,4 where Wj =
BWPWitGen(pk, RIP , 0,m, X, ?), and select T = h ? mathbbG2 and compute
a proof piX such that
e(W0,W1) = e(g1, T ) ? (5.13)
e(g,W1) = e(g1,W2) ?
e(g2n,W1) = e(g1,W3) ?
e(g? , T/h) = 1GT ?
e(
n∏
j=1
g
xj
j , ?6) = e(gn,W1)  e(g,W4)
Finally, the proof pi = ( {C?j}j=1,...,8, {CWj}j=0,...,4, C?,pi?, piX ).
- If R = REQ compute a commitment CW = GSCom(W,openW ) where W =
BWPWitGen(pk,REQ,i,m,X,?), CXi = GSCom(Xi, openXi) where Xi = h
xi
1 ,
and compute proofs piW and piX such that
e(gi, ?6) = e(gn,Xi)  e(g,W ) ? (5.14)
e(g?,Xi/h
xi
1 ) = 1GT
Finally, the proof pi = ( {C?j}j=1,...,8, CW , CXi , C?,pi?, piW ,piX ).
- If R = REQ, compute { CWj }j=0,...,4 where Wj = BWPWitGen(pk, R
EQ, 0,
m, X, ?), CXi = GSCom(Xi, openXi) where Xi = g
xi
1 , and compute proofs
piXi,W , {piWj}j=1,...,3 piXi , pig such that
e(gi, ?6)  e(gn,Xi)
?1 = e(gn,W1)  e(g,W4) ? (5.15)
e(W0,W1) = e(g1, h) ?
e(g,W1) = e(g1,W2) ?
e(g2n,W1) = e(g1,W3) ?
e(g?,Xi/h
xi
1 , ) = 1GT ?
e(g?, T/h) = 1GT
Finally, the proof pi = ( {C?j}j=1,...,8, {CWj}j=0,...,4, CXi ,C?, pi?, piXi,W , {piWj}j=1,...,3,
pi? ).
54 CHAPTER 5. Optimization of block-wise P-signatures
BWPEqCommProve(params,m, open, open?). Taken two opens openX and openY , two
commitments CX and CY can be respectively computed by CX=GSCom(X, openX)
and CY=GSCom(Y , openY ). To prove X = Y , we can construct an non-interactive
zero-knowledge proof CX  CY = 1GT based on SXDH assumption.
The result after optimization
Figure 5.2: Elements used in G1 and G2 of our proposed optimized block-wise P-signatures
Function elements in G1 elements in G2
F ? signatures
KeyGen g h
Sign g, U0, {gi}
n
1 h, u
V erify g, U0, U1,?, {gi}
n
1 , ?21, ?4 h,A, u, ?1, ?22, ?3, ?5, ?6
WitGen? EQ - {hi}
n
1
WitGen? EQ g h, h2n, {hi}
n
1
WitGen? IP - {hi}
n
1 , {Wi}
n
1
WitGen? IP g h, h2n, {hi}
n
1 , {Wi}
n
1
WitV erify ? EQ g, g1, gi ?6, hn,W
WitV erify ? EQ g1, gi, gn, g2n, ?6,W0 h, hn+1?i,W1,W2,W3,W4
WitV erify ? IP g, {gi}
n
1 ?6,W
WitV erify ? IP g1, gi, g2n, {gi}
n
1 ,W0 h, ?6,W1,W2,W3,W4
Let us examine the difference between our proposed two block-wise P-signatures.
Please compare Figure 4.1 and Figure 5.2, which collect elements used in two group G1
and G2 respectively. The first observation is that these two schemes use the same group
elements, which means the fundamental idea of asymmetric-based block-wise P-signatures
remains unchanged and hence our optimization may not jeopardize the security level of
our proposed scheme. Secondly, it is also clear that the optimized block-wise P-signatures
dispatch more elements of signature set ? = (?1, ?21, ?22, ?3, ?4, ?5, ?6) and witness set
W = (W0, W1, W2, W3, W4) to group G2 while comparing with the naive porting version
of block-wise P-signatures introduced in last chapter. The advantage of this modification
is that while doing verification procedure, we can construct maximal repeated pattern of
fixed left-hand side argument in pairing computation, which can be pre-computed in im-
plementation. Lastly, our modification moves the dynamic elements such as ? and W to
the group G2 of pairing computation, which can hence get the benefit of relatively small
field computation E(Fq) while comparing to E(Fqk) of group G1 computation.
In our modification, we are also interested in knowing how many repeated pairing
patterns we can have to do pairing pre-computation. Figure 5.3 collects all the repeated
appearance of pairing form after the optimization. In the first view of this table, it is
clear that except for WitV erify ? IP , all verification procedure can get benefit from the
5.1. OPTIMIZATION OF OUR PROPOSED BLOCK-WISE P-SIGNATURE 55
Figure 5.3: Collection of repeated pairing forms in block-wise P-signatures before/after
optimization
Function Pairing form # before optimization # after optimization
V erify e(g, ) 1 4
e(?21, ) 1 4
WitV erify ? EQ e(g, ) 0 1
e(g1, ) 1 2(Max)
WitV erify ? EQ e(g, ) 0 2
e(g1, ) 1 5(Max)
e(gn, ) 0 2(Max)
WitV erify ? IP e(g, ) 0 1
WitV erify ? IP e(g, ) 0 2
e(g1, ) 1 3
SigV erify1 ? EQ e(g, ) 1 8
e(?21, ) 1 4
e(g1, ) 0 2(Max)
e(gn, ) 0 2(Max)
SigV erify1 ? EQ e(g, ) 1 7
e(?21, ) 1 4
e(g1, ) 1 3
e(gn, ) 0 2
SigV erify2 ? EQ e(g, ) 2 7
e(?21, ) 1 4
e(gn, ) 1 2(Max)
SigV erify2 ? EQ e(g, ) 2 10
e(?21, ) 1 4
e(g1, ) 1 4(Max)
e(gn, ) 0 2
SigV erify2 ? IP e(g, ) 1 5
e(?21, ) 1 4
SigV erify2 ? IP e(g, ) 2 8
e(?21, ) 1 4
e(g1, ) 1 2
optimization. It is desired to notice that the number of pairing form e(g, ) is dramatically
increased, which indirectly illustrates the advantage of our optimization on asymmetric
pairing based block-wise P-signatures. Other pairing forms such as e(g1, ), e(gn, ) and
e(?21 are also gain the benefit from our optimization. In short, these repeated pairing
pattern can be precomputed and speed up the computation of our optimized block-wise
56 CHAPTER 5. Optimization of block-wise P-signatures
P-signature scheme.
5.1.1 Security consideration of optimized P-signatures
To optimize the proposed block-wise P-signatures we have significantly readjusted the
relative position of group elements in G1 and G2. It is necessary to examine whether the
modified block-wise P-signature scheme is still secure against forgery attack.
Figure 5.4: Security reduction from asymmetric pairings P-signatures to optimized P-
signatures
In Section 4.2 we define the security assumption of q?XHSDH problem, FlexXDH
problem and n ?XFDHE problem for asymmetric pairings and all these three security
are essentially extended from q ? HSDH problem, FlexDH problem and n ? FDHE
problem of single group G into asymmetric pairing groups G1 and G2. With these security
assumption we can reduce the security of our proposed block-wise P-signatures to q ?
XHSDH problem, FlexXDH problem and n?XFDHE problem.
In terms of our optimization on block-wise P-signatures, we also need to carefully
examine if our modification jeopardize the security. Please refer to 5.4, it is necessary to
examine whether the security assumption of q ?XHSDH problem, FlexXDH problem
and n ?XFDHE problem still works in our optimized block-wise P-signatures. Firstly,
the defined q ?XHSDH problem are essentially simultaneously running the q ?HSDH
with generator g ? G1 and generator h ? G2 and try to find a tuple (g
1/(?+c), gc, uc1,
h1/(?+c), hc, uc2) given (g
1/(?+ci), gci , uci1 ) and (h
1/(?+ci), hci , uci2 ) where ci ? Z
?
p. This
security assumption is essentially symmetric except for the underlying group elements g,
u1, h, and u2; in other words, the exponential argument ? and ci are the same. Such
definition give us convenience to transfer one secret from group G1 to group G2. For
example, please refer to first equation in Figure 5.1.
e(?, h) = e(?  ?21, ?1)before optimization (5.16)
e(g,?) = e(?  ?21, ?1)after optimization
5.2. EFFICIENCY OF OPTIMIZED BLOCK-WISE P-SIGNATURES 57
Our modification move the fixed argument ? from e(? = g? , h) = e(g, h)? to e(g,? = h?)
= e(g, h)? . This example is a model technique we used to optimize block-wise P-signature.
It is clear that such the modification will not change the fundamental idea of defined
security assumption, but simply adjust the argument form one group to the other group.
Therefore, q ? XHSDH problem still works in our modification. Similarly, FlexXDH
problem and n ? XFDHE also show the same case as q ? XHSDH, which adjust the
exponent argument from one group to the other group. With this observation we can
conclude that q?XHSDH problem, FlexXDH problem and n?XFDHE problem are
still suitable for the optimized block-wise P-signatures.
Theorem 5.1. The optimized asymmetric block-wise P-signatures are secure on the hard-
ness of q-XHSDH problem, FlexXDH problem and n-XFDHE problem.
Proof sketch. The optimized block-wise P-signature can be proven secure against all
three types of forgery attacks. The prove can be slightly modified from the original proofs
provided by [4] and hence we will omit the proofs here. In this way, the reduction proof
of right-hand side of Figure 5.4 can be constructed.
5.2 Efficiency of optimized block-wise P-signatures
In this section we evaluate how much benefit the optimization can gain in block-wise P-
signatures. Let us examine the theoretical analysis between asymmetric pairing based
block-wise P-signatures without optimization and one with optimization. Please refer to
Figure 5.5, The first observation is that our optimization do not decrease used group
elements in G1 and G2 even though Our modification on the proposed block-wise P-
signatures is huge. Secondly in the witness generation of case R = RIP and case R = RIP
which take the most number of group elements among all cases, we transfer the cost from
group G1 to group G2, which can hence get benefit from the small field computation.
Overall the result is acceptable because our optimization focuses on alignment of pairing
arguments and does not increase or decrease group elements. Therefore, from the view of
theoretical analysis the performance enhancement is relatively small while comparing the
improvement from porting block-wise P-signature from symmetric pairings to asymmetric
pairings.
5.2.1 Pairing pre-computation in MIRACL library
Fortunately MIRACL library has supported a variety of optimization techniques for pair-
ings computation, which are described as follows.
1. Powering pre-computation of bilinear pairings. This function supports pre-computation
of fixed arguments X ? G1 and Y ? G2 in pairing computation e(X,Y ), so that
e(X,Y )z can be sped up for some z ? Z?p. One can use the function to pre-compute
and store the value
precomp for power(X,Y ) (5.17)
58 CHAPTER 5. Optimization of block-wise P-signatures
Figure 5.5: Comparison of used group elements before/after optimization – F-signature
part
Function BWPS before optimization BWPS after optimization
(# in G1) (# in G2) (# in G1) (# in G2)
F ? signatures
KeyGen 1 1 1 1
Sign n+2 2 n+2 2
V erify n+8 6 n+7 7
WitGen? EQ n 0 0 n
WitGen? EQ n+2 1 1 n+2
WitGen? IP 2n 0 0 2n
WitGen? IP 2n+2 1 1 2n+2
WitV erify ? EQ 3 3 3 3
WitV erify ? EQ 7 6 7 6
WitV erify ? IP 2 n+1 n+1 2
WitV erify ? IP 6 n+4 n+4 6
2. Multiplication pre-computation of group elements. This function supports multiplica-
tion pre-computation of element X ? G1 or elements Y ? G2 in element multiplica-
tion, so that Xz or Y z can be sped up for some z ? Z?p. One can use the function to
pre-compute and store the value
precomp for mult(X) (5.18)
precomp for mult(Y )
3. Pairing pre-computation of group elements. This function supports pre-computation
of fixed arguments X ? G1 in pairing computation e(X, ), so that e(X,Y ) can be
sped up for some Y ? G2. One can use function to pre-compute and store the value
precomp for pairing(X) (5.19)
4. Fast multiple pairing products technique. This function speeds up multiple pairing
products by sharing the same Miller variable and final exponentiation. One can use
the following function to compute result
multi pairing(CollectionX, CollectionY ) (5.20)
In our implementation, the first pre-computation technique provided MIRACL library
can less benefit on our optimized scheme since block-wise P-signatures simply contain
one powering computation of bilinear pairings. Also there is no computation of multiple
pairing product in block-wise P-signatures. Therefore, we mainly adopt the second and the
third pre-computation provided by MIRACL library to speed up block-wise P-signatures.
5.2. EFFICIENCY OF OPTIMIZED BLOCK-WISE P-SIGNATURES 59
The detailed experiment results are collected in Appendix A.2 and Appendix A.3, and
the standard deviation of our experiments show negligibly small for the performance of
block-wise P-signatures of naive Type-3 pairing porting and performance of optimized
block-wise P-signatures to be evidently distinguished.
Figure 5.6: Efficiency comparison of block-wise P-signatures without/with optimization
(using pairing curve BN-128)
ID Function BWPS in Type-3 without BWPS in Type-3 with Improvement (%)
optimization(/sec.) optimization (/sec.)
F ? signatures
1 Sign 0.0492 0.0302 38.61
2 V erify 0.7039 0.6554 6.89
3 WitGen? EQ 0.009 0.0041 54.44
4 WitGen? EQ 0.0492 0.0114 19.14
5 WitGen? IP 0.0101 0.0048 52.47
6 WitGen? IP 0.0174 0.0131 24.71
7 WitV erify ?EQ 0.2331 0.212 9.05
8 WitV erify ?EQ 0.6985 0.6086 12.87
9 WitV erify ? IP 0.1564 0.1501 4.02
10 WitV erify ? IP 0.6931 0.6191 10.67
SigProve1
11 SigProve1 ? EQ 4.6203 4.4409 3.88
12 SigProve1 ? EQ 6.0987 5.882 3.55
13 SigV erify1 ? EQ 13.4915 13.2608 1.70
14 SigV erify1 ? EQ 18.4456 17.5681 4.75
SigProve2
15 SigProve2 ? EQ 4.1008 3.9838 2.85
16 SigProve2 ? EQ 6.1149 5.8713 3.98
17 SigProve2 ? IP 3.5716 3.4304 3.95
18 SigProve2 ? IP 6.4235 6.1146 4.80
19 SigV erify2 ? EQ 12.1482 11.8556 2.40
20 SigV erify2 ? EQ 18.4185 17.5311 4.81
21 SigV erify2 ? IP 10.7983 10.4557 3.17
22 SigV erify2 ? IP 18.8304 17.994 4.44
5.2.2 Experiment result.
Please refer to Figure 5.6, the data are collected from 20 runs of experiment with single
block of message. This figure illustrates how the optimization affect the efficiency of block-
60 CHAPTER 5. Optimization of block-wise P-signatures
wise P-signatures, which can be roughly divided into two part: F-unforgeable signatures
and signature proof generation and verification.
Firstly let us examine the performance of optimization in F-unforgeable signatures.
Overall it is clear that efficiency enhancement depends on how large the proportion of
function codes can be precomputed. For the signature generation, it is evident that three
of seven equations in the algorithm can be sped up by pre-computing multiplication of
group elements g and h, which is expected to receive 42.85%’s improvement in efficiency.
Our experiment shows 38.61%’s enhancement, which is consistent to the expected value.
In other words, the result implicitly shows the performance of pre-computing elements
multiplication can show a positive relation with the proportion of codes that can be pre-
computed. In terms of signature verification, our revised scheme possess five of nine pairing
computation can be sped up by the pre-computation of e(g, ), which approximately 41.66
%’s improvement in efficiency. However, our experiment can only get about 7%’s improve-
ment, which illustrates that the fixed argument pre-computation cannot provide consistent
percentage while comparing with expected improvement.
Next let us consider the performance of witness generation and verification. For sig-
nature generation of cases R=REQ and R=RIP , the results show half improvement in
efficiency. Essentially the enormous improvement also depends on the the proportion of
precomputed codes; hence in our experiment with only one message block, the improve-
ment is expected to receive half improvement in running time. The other two cases,
R=REQ and R=RIP , also presents about 20%’s enhancement in efficiency. However, the
receiving efficiency of these two cases will decrease with the increase of message blocks. In
terms of witness verification, the performance of optimization is low. The experiment re-
sult shows approximately 10%’s improvement in the cases R=REQ, R=REQ and R=RIP ,
however, there is only 4% in the case of R=RIP . This phenomenon again supports the
statement that pairing pre-compution of fixed argument can provides lower gain in effi-
ciency enhancement.
Lastly in terms of signature proof generation and verification, none of all cases in
our experiment can get efficiency benefit over 5%, which cannot regarded as a desirable
performance. The situation may result from the complexity of Groth-Sahai proofs. Firstly,
Groth-Sahai commitments essentially is an process of encryption, which means they needs
to use fresh random value to conceal the element to be committed and leaves less space for
pairing pre-computation. Secondly, the verification of Groth-Sahai proofs require hundreds
of pairing computation and the group elements involved in pairing computation are usually
unshown during the verification procedure. These two unfavorable factors result in less
efficiency gain in signature proof generation and verification of block-wise P-signatures.
In summary, our optimization in block-wise P-signatures receive significant perfor-
mance in F-signatures part, and signature proof generation and verification can get less
efficiency enhancement in our optimization.
5.3. OTHER PRACTICAL EFFICIENCY ANALYSIS OF BLOCK P-SIGNATURES61
5.3 Other practical efficiency analysis of block P-signatures
In last section we focus on evaluating the performance of applying optimization techniques
in our revised block-wise P-signatures. All the experiment data are collected on BN curves;
however, it is desirable to know the performance of block-wise P-signature on different
pairing curves. In this section, we discuss and compare how the different pairing curves
affect the performance of block-wise P-signatures.
5.3.1 Efficiency analysis on different pairing curves
The choice of pairing curve is also regarded as an important issue for pairing computation.
Due to the unique design of different pairing curves, the performance of pairing computa-
tion can present unique result. In this section we try to examine how the different pairing
curves affect the performance of block-wise P-signatures. Here the experiment is simpli-
fied and mainly focus on measuring the performance of case R = REQ of F-unforgeable
signatures among different pairing curves. In terms of pairing curves, we adopt CP-80,
MNT-80, BN-128, KSS-192, BLS-256, which left-hand side of the notation is the curve
name, and right-hand side represents the security degree. The code of F-unforgeable sig-
natures we adopted is optimized and contains pairing pre-computation. Moreover, we
increase the number of repeating experiment to 100 and extend the message to 20 blocks,
which can further increase the precision of this experiment. The detailed experiment re-
sults are collected in Appendix A.4, and the standard deviation of our experiments show
negligibly small for the performance of block-wise P-signatures on different pairing curves
to be evidently distinguished.
From a general view, please refer to Figure 5.7, it is interesting that running time of
signature verification and witness verification is increasing with the raise of security de-
gree; however, performance of signature generation and witness generation is close among
different curves with different security degree. As we have understood, signature veri-
fication and witness verification comprise pairing computation that can only get a little
benefit from pairing pre-computation; therefore, it is not surprising that the pairing curves
with higher security degree will take more time on pairing computation. Moreover, there
are two remarkable points showing in this comparison. Please refer to Figure 5.8, firstly
it is noticeable that CP-80 take less time doing verification than MNT-80, which shows
CP-80 take more advantage than MNT-80 on pairing computation of same security de-
gree. Secondly there is a small increase from CP-80 to BN-128; however, the running
time dramatically increase from BN-128 to BLS-256, which illustrate that BN-128 shows
significant performance in pairing computation.
In terms of signature generation and witness generation, the experiment result is im-
pressing. Firstly no matter what pairing curves and security degree we adopt, all these
five pairing curves present excellent performance. In F-unforgeable signatures, signature
generation and witness generation comprise a series of multiplication of group elements on
elliptic curves; hence the experiment result shows that all five pairing curves show remark-
able performance on multiplication on curve points. In spite of high performance of all
62 CHAPTER 5. Optimization of block-wise P-signatures
Figure 5.7: Efficiency comparison among different pairing curves - F-signatures part
pairing curves, there are still two noticeable points. Please refer to Figure 5.8 which give
the detailed data of this experiment, the first point is that MNT-80 perform better than
CP-80 in signature generation and witness generation, which is different from the result
of signature verification and witness verification. This phenomenon illustrates that MNT
curve is better at doing point multiplication than CP curve. The second point is that BN-
128 presents the best performance in signature generation and witness generation, even
better than CP-80 and MNT-80 with lower security degree. This result implicitly suggest
that BN curves possesses tremendous efficiency in doing point multiplication.
In short our experiment provide a reference for application developers to choose which
curves is better for their applications. Considering the security requirement, most cryp-
tographic products require at least AES-128; hence BN-128 can be an appropriate choice.
If applications focus on computational performance and only need lower security degree,
developers can evaluate their applications’ requirement and choose CP-80 or MNT-80. In
practical situation, signature verification can be operated many times and there is only
one signature generation; hence in this situation CP-80 can provide better performance
than MNT-80.
5.3.2 Further efficiency analysis on BN curves
In this section we would like to analyze the performance of BN curves of different security
degree. From the experiment result of BN-128 we have understood that BN curves show
5.3. OTHER PRACTICAL EFFICIENCY ANALYSIS OF BLOCK P-SIGNATURES63
Figure 5.8: Detailed data of efficiency comparison among different pairing curves - F-
signatures part
Function CP-80 MNT-80 BN-128 KSS-192 BLS-256
Sign 0.077 0.047 0.04 0.118 0.2774
V erify 0.2003 0.4333 0.7785 3.6986 6.9683
WitGen ?EQ 0.0351 0.0289 0.0189 0.0668 0.1932
WitV erify ? EQ 0.132 0.3357 0.7316 3.5669 6.7946
well balance on security degree and performance in efficiency. Essentially MIRACL library
allows BN curves being built for the security degree of AES-128 and AES-192, which
inspires us to measure the performance of BN curves of these two security degrees. To
facilitate the comparison between these two curve settings, we set the same experiment
parameters as the environment we set for block-wise P-signatures: 20 runs of one message
block. Please see the experiment result in Figure 5.9.
Firstly let us consider the result of F-signatures part of block-wise P-signatures in
different security degree. Please refer to Figure 5.10, the result indicates that in the sig-
nature generation and witness generation, BN-192 setting present competitive efficiency,
which means these operations can be computed in a fairly short time. However, in terms
of signature verification and witness verification, the running time of BN-192 setting dra-
matically increase. It is remarkable that in the case R=REQ and R=RIP of SigV erify2,
the verification procedures take roughly one second, which is acceptable for the majority
of applications; but, the others operations arise to nearly 3.5 seconds, which is a signifi-
cant difference while comparing to BN-128-setting. In short, for the F-signatures part of
block-wise P-signatures, BN-192 setting present an acceptable result.
Secondly we examine the result of signature proof generation and verification of block-
wise P-signatures. Please refer to Figure 5.11, it is clear that signature proof generation
and verification take terribly long time to complete the computation. Roughly the data
can be divided into two parts, signature proof generation (Function ID 11, 12, 15, 16,
17, 18) and signature proof verification (Function ID 13, 14, 19, 20, 21, 22). The proof
generation part can be done in 40 seconds while the proof verification part take up to 90
seconds. Comparing to BN-128 setting, BN-192 setting cannot be regards to a nice choice
for constructing block-wise P-signatures.
Finally let us compare the efficiency improvement of pre-computation between BN-128
setting and BN-196 setting. Please refer to Figure 5.12, it is surprising that the efficiency
improvement present consistently decline in BN-192 setting while comparing to BN-128
setting. This phenomenon illustrates that the pre-computation for both element multipli-
cation and pairing computation in security degree of AES-128 can take more advantage
than in AES-192. It is reasonable to suppose that the cause comes from the unique prop-
erty of BN curve, and may not happen on other pairing curves.
64 CHAPTER 5. Optimization of block-wise P-signatures
Figure 5.9: Efficiency comparison of block-wise P-signature without/with optimization
(using pairing curve BN-192)
ID Function BWP in Type-3 without BWP in Type-3 with Improvement
optimization(/sec.) optimization (/sec.) (%)
F ? signatures
1 Sign 0.3253 0.2164 33.47
2 V erify 3.6861 3.4822 5.53
3 WitGen? EQ 0.051 0.028 45.09
4 WitGen? EQ 0.0868 0.0735 15.32
5 WitGen? IP 0.0484 0.0239 50.61
6 WitGen? IP 0.1065 0.0811 23.84
7 WitV erify ?EQ 1.2265 1.1321 7.69
8 WitV erify ?EQ 3.5844 3.2391 9.63
9 WitV erify ? IP 0.7813 0.7667 1.86
10 WitV erify ? IP 3.5371 3.2696 7.56
SigProve1
11 SigProve1 ? EQ 26.6617 25.9066 2.83
12 SigProve1 ? EQ 34.3566 33.4852 2.53
13 SigV erify1 ? EQ 68.8043 67.2217 2.30
14 SigV erify1 ? EQ 90.8369 88.7359 2.31
SigProve2
15 SigProve2 ? EQ 23.8078 23.3271 2.01
16 SigProve2 ? EQ 34.4066 33.6923 2.07
17 SigProve2 ? IP 19.5668 18.8773 3.52
18 SigProve2 ? IP 35.1501 34.0464 3.13
19 SigV erify2 ? EQ 61.4989 60.8401 1.07
20 SigV erify2 ? EQ 91.4734 89.4296 2.23
21 SigV erify2 ? IP 52.7504 51.6206 2.14
22 SigV erify2 ? IP 94.3742 91.279 3.27
5.3. OTHER PRACTICAL EFFICIENCY ANALYSIS OF BLOCK P-SIGNATURES65
Figure 5.10: Performance comparison of block-wise P-signatures on pairing curves BN-128
and BN-196 - F-signatures part (please refer x-axis to the ID shows in Figure 5.9)
Figure 5.11: Performance comparison of block-wise P-signatures on pairing curves BN-128
and BN-196 - whole part (please refer x-axis to the ID shows in Figure 5.9)
66 CHAPTER 5. Optimization of block-wise P-signatures
Figure 5.12: Comparison of efficiency enhancement between block-wise P-signatures in
pairing curves BN-128 and BN-196 (please refer x-axis to the ID shows in Figure 5.9)
Chapter 6
Conclusions
In this dissertation we make an comprehensive analysis on block-wise P-signatures from
a variety of efficiency perspectives. For the theoretical efficiency analysis of block-wise
P-signatures, we proposed the first block-wise P-signature scheme based on asymmetric
pairings, which is theoretically regarded to possess efficiency advantage over ones based on
symmetric pairings. Moreover, our proposed block-wise P-signatures can be proven secure
on the assumptions of q-XHSDH problem, Flex-XDH problem and n-XFDHE problem,
which are firstly proposed in our works. Comparing with ordinary block-wise [4] intro-
duced by Izabache`ne et al, our proposed scheme can provide competitive efficiency in
group elements used in signature generation and verification; furthermore, our proposed
scheme can significantly reduce used group elements in signature proofs generation and
verification.
In terms of practical implementation, to verify the correctness of our proposed scheme
and evaluate the performance difference between our designs and Izabache`ne et al.’s works.
We both firstly implement block-wise P-signatures based on symmetric pairings 1. and
ones based on asymmetric pairings 2. Our proposed block-wise P-signatures can get 79%-
85%’s efficiency improvement on signature generation and witness generation, as well
as 41%-45%’s efficiency enhancement on signature verification and witness verification.
Moreover, the signature proof generation and verification based on SXDH construction
can get get nearly 93%-97%’s improvement over ones based on DLIN construction.
In spite of enormous efficiency improvement of our proposed block-wise p-signatures,
we further seek for higher efficiency enhancement by applying optimization techniques in
our proposed schemes. Comparing with our proposed schemes, the optimized block-wise
P-signatures can 19%-52%’s improvement on signature generation and witness genera-
tion while signature verification and witness verification can hence get 4%-12%’ efficiency
enhancement. Moreover, signature proof generation and verification can get benefit of
1%-4%’s efficiency improvement.
1Type-1 pairings in specific is adopted and signature proof generation and verification adopt DLIN-
based Groth-Sahai proof systems.
2Type-3 pairings in specific is adopted and signature proof generation and verification adopt SXDH-
based Groth-Sahai proof systems.
67
68 CHAPTER 8. CONCLUSIONS
Finally, we evaluate the performance of block-wise P-signatures on different pairing
curves and different security degree. In short, Barreto-Naehrig (BN) curve presents well
balance both in fast pairing computation and acceptable security degree for the imple-
mentation of block-wise P-signatures.
In conclusion, our proposed block-wise P-signatures can bring significant efficiency
benefit to the research of P-signatures; moreover, the efficiency analysis on block-wise P-
signatures can also be the reference for the implementation of pairing-based cryptographic
applications.
6.1 Future work of block-wise P-signatures
Block-wise P-signatures are relatively complex digital signatures since they combine a vari-
ety of cryptographic primitives, including digital signatures, attribute-based cryptographic
primitives, predicate cryptographic primitives and non-interactive zero-knowledge proofs.
Although our proposed block-wise P-signatures with optimization have received significant
progress on improving efficiency of them, there are two possible research directions for the
future works.
Efficiency improvement of signature proofs verification
Figure 6.1: Number of pairings computation per proof verification, where n and m stand
for the number of different types of variables. [5]
proof equation Naive verification Batch verification
SXDH
Pairing product equation 5m+ 3n+ 16 m+ 2n+ 8
Multi-scalar multiplication equation in G1 8m+ 2n+ 14 min(2n+ 9, 2m+ n+ 7)
Multi-scalar multiplication equation in G2 8n+ 2m+ 14 min(2m+ 9, 2n+m+ 7)
Quadratic equation 8m+ 8n+ 12 2 min(m,n)+8
SXDH
Pairing product equation 12n+ 27 3n+ 6
Multi-scalar multiplication equation in G 9n + 12m+ 27 3n + 3m+ 6
Quadratic equation 18n+ 24 3n+ 6
Observing the efficiency of our proposed block-wise P-signatures, it is evident that sig-
nature proofs generation and verification still take long time to complete the procedures,
especially on the signature proofs verification.3 To improve the performance of signature
proofs generation and verification, it is clear that we should fundamentally improve the
3Please refer to Figure 4.4 and Figure 4.5
6.1. FUTURE WORK OF BLOCK-WISE P-SIGNATURES 69
performance of Groth-Sahai proof systems. Recently Blazy et al. [5] introduced the tech-
nique that doing batch verification of Groth-Sahai proofs, which can enormously decrease
the number of pairing computation. Please see the performance enhancement of batch
verification in Figure 6.1. The techniques batch verification adopt are three: Moving
the exponent into pairing computation, Moving the product into pairing computation,
and Switching the product. In other words, the batch verification should rearrange the
equations of signature proof verification of block-wise P-signatures by using group element
multiplication, so that the batch verification dramatically decreases necessary pairing com-
putation. In fact, Izabache`ne et al. [4] also suggested to use this batch techniques on their
block-wise P-signatures and they expected to use less than 20 pairing computation to
finish one signature proof verification procedure. Comparing with naive verification, the
technique of batch verification indeed provides a great solution for block-wise P-signatures.
Application of block-wise P-signatures
Block-wise P-signatures are proposed for achieving anonymous credentials systems, which
can be widely used in a variety of application domains: from large system applications
in cloud computing, to small devices such as mobile phones and Oyster cards. From our
experiment result, up to now it is evident that computing block-wise P-signatures still
require machines with powerful computation ability. Motivated by this observation, there
are two directions for the development of block-wise P-signatures. Firstly, considering
the required computing power of block-wise P-signatures, one can focus on constructing
proxy architectures to alleviate the computation burden for portable devices such as mobile
phones. Another possible research direction can focus on the reconstruction of light-weight
block-wise p-signatures, so that the new construction can be used in smart cards or other
devices without powerful computing ability.
Bibliography
[1] Galbraith, S.D., Paterson, K.G., Smart, N.P.: Pairings for cryptographers. Discrete
Applied Mathematics 156(16) (2008) pp. 3113–3121
[2] Scott, M.: On the efficient implementation of pairing-based protocols. In: Cryp-
tography and Coding - 13th IMA International Conference - IMACC 2011, Lecture
Notes in Computer Science vol. 7089, Springer-Verlag (2011) pp.296–308
[3] Groth, J., Sahai, A.: Efficient non-interactive proof systems for bilinear groups. In:
Advances in Cryptology - EUROCRYPT 2008, Lecture Notes in Computer Science
vol. 4965, Springer-Verlag (2008) pp.415–432
[4] Izabache`ne, M., Libert, B., Vergnaud, D.: Block-wise p-signatures and non-
interactive anonymous credentials with efficient attributes. In: Cryptography and
Coding - 13th IMA International Conference - IMACC 2011, Lecture Notes in Com-
puter Science vol. 7089, Springer-Verlag (2011) pp.431–450
[5] Blazy, O., Fuchsbauer, G., Izabache`ne, M., Jambert, A., Sibert, H., Vergnaud, D.:
Batch groth-sahai. In: Applied Cryptography and Network Security - 8th Inter-
national Conference, ACNS 2010, Lecture Notes in Computer Science vol. 6123,
Springer-Verlag (2010) pp.218–235
[6] Chaum, D.: Security without identification: Transaction systems to make big brother
obsolete. Commun. ACM 28(10) (1985) pp. 1030–1044
[7] Damg˚ard, I.: Payment systems and credential mechanisms with provable security
against abuse by individuals. In: Advances in Cryptology - CRYPTO 1988, Lecture
Notes in Computer Science vol. 403, Springer-Verlag (1988) pp.328–335
[8] Lysyanskaya, A., Rivest, R.L., Sahai, A., Wolf, S.: Pseudonym systems. In: Selected
Areas in Cryptography - SAC 1999, Lecture Notes in Computer Science vol. 1758,
Springer-Verlag (1999) pp.184–199
[9] Camenisch, J., Lysyanskaya, A.: An efficient system for non-transferable anonymous
credentials with optional anonymity revocation. In: Advances in Cryptology - EURO-
CRYPT 2001, Lecture Notes in Computer Science vol. 2045, Springer-Verlag (2001)
pp.93–118
70
BIBLIOGRAPHY 71
[10] Camenisch, J., Herreweghen, E.V.: Design and implementation of the idemix anony-
mous credential system. In: ACM Conference on Computer and Communications
Security - CCS2002, ACM (2002) pp.21–30
[11] Camenisch, J., Lysyanskaya, A.: A signature scheme with efficient protocols. In:
Security in Communication Networks, Third International Conference - SCN 2002,
Lecture Notes in Computer Science vol. 2576, Springer-Verlag (2002) pp.268–289
[12] Camenisch, J., Lysyanskaya, A.: Signature schemes and anonymous credentials from
bilinear maps. In: Advances in Cryptology - CRYPTO 2004, Lecture Notes in Com-
puter Science vol. 3152, Springer-Verlag (2004) pp.56–72
[13] Belenkiy, M., Chase, M., Kohlweiss, M., Lysyanskaya, A.: P-signatures and non-
interactive anonymous credentials. In: Theory of Cryptography, Fifth Theory of
Cryptography Conference - TCC 2008, Lecture Notes in Computer Science vol. 4948,
Springer-Verlag (2008) pp.356–374
[14] Belenkiy, M., Chase, M., Kohlweiss, M., Lysyanskaya, A.: Compact e-cash and
simulatable vrfs revisited. In: Pairing-Based Cryptography - Pairing 2009, Lecture
Notes in Computer Science vol. 5671, Springer-Verlag (2009) pp.114–131
[15] Belenkiy, M., Camenisch, J., Chase, M., Kohlweiss, M., Lysyanskaya, A., Shacham,
H.: Randomizable proofs and delegatable anonymous credentials. In: Advances in
Cryptology - CRYPTO 2009, Lecture Notes in Computer Science vol. 5677, Springer-
Verlag (2009) pp.108–125
[16] Goldreich, O., Micali, S., Wigderson, A.: Proofs that yield nothing but their validity
and a methodology of cryptographic protocol design (extended abstract). In: 27th
Annual Symposium on Foundations of Computer Scienc - FOCS 86, IEEE Computer
Society (1986) pp.174–187
[17] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and
signature problems. In: Advances in Cryptology - CRYPTO 1986, Lecture Notes in
Computer Science vol. 263, Springer-Verlag (1986) pp.186–194
[18] Bellare, M., Rogaway, P.: Random oracles are practical: A paradigm for designing
efficient protocols. In: ACM Conference on Computer and Communications Security,
Proceedings of the 1st ACM Conference on Computer and Communications Security
(1993) pp.62–73
[19] Goldwasser, S., Kalai, Y.T.: On the (in)security of the Fiat-Shamir paradigm. In:
44th Symposium on Foundations of Computer Science - FOCS 2003, IEEE Computer
Society (2003) pp.102–113
[20] Canetti, R., Goldreich, O., Halevi, S.: The random oracle methodology, revisited, J.
ACM, vol. 51 (2004) pp.557–594
72 BIBLIOGRAPHY
[21] Camenisch, J., Groß, T.: Efficient attributes for anonymous credentials (extended ver-
sion). IACR Cryptology ePrint Archive http://eprint.iacr.org/2010/496 (2010)
pp.496
[22] Boneh, D., Boyen, X., Shacham, H.: Short group signatures. In: Advances in
Cryptology - CRYPTO 2004, Lecture Notes in Computer Science vol. 3152, Springer-
Verlag (2004) pp.41–55
[23] Scott, M.: Authenticated id-based key exchange and remote log-in with simple token
and pin number. http://eprint.iacr.org/2002/164.pdf (2002)
[24] Boyen, X., Waters, B.: Full-domain subgroup hiding and constant-size group signa-
tures. In: Public Key Cryptography - PKC 2007, Lecture Notes in Computer Science
vol. 4450, Springer-Verlag (2007) pp.1–15
[25] Boneh, D., Gentry, C., Waters, B.: Collusion resistant broadcast encryption with
short ciphertexts and private keys. In: Advances in Cryptology - CRYPTO 2005,
Lecture Notes in Computer Science vol. 3621, Springer-Verlag (2005) pp.258–275
[26] NIST: Nist recommendation for key management part 1: General, nist special
publication. http://csrc.nist.gov/publications/nistpubs/800-57/SP800-57-
Part1.pdf (2005)
[27] Lenstra, A.K.: Handbook of Information Security. Volume 2. Wiley (2005)
[28] ECRYPT: Ecrypt yearly report on algorithms and keysizes.
http://www.ecrypt.eu.org/documents/D.SPA.10-1.1.pdf (2005)
[29] Scott, M.: Computing the tate pairing. In: The Cryptographers’ Track at the RSA
Conference - CT-RSA 2005, Lecture Notes in Computer Science vol. 3376, Springer-
Verlag (2005) pp.293–304
[30] Costello, C., Stebila, D.: Fixed argument pairings. In: Progress in Cryptology -
LATINCRYPT 2010, Lecture Notes in Computer Science vol. 6212, Springer-Verlag
(2010) pp.92–108
[31] Granger, R., Smart, N.P.: On computing products of pairings. IACR Cryptology
ePrint Archive http://eprint.iacr.org/2006/172 (2006) pp.172
[32] Ghadafi, E., Smart, N.P., Warinschi, B.: Groth-sahai proofs revisited. In: Public Key
Cryptography, Lecture Notes in Computer Science vol. 6056, Springer-Verlag (2010)
pp.177–192
[33] Boneh, D., Boyen, X.: Short signatures without random oracles. In: Advances
in Cryptology - EUROCRYPT 2004, Lecture Notes in Computer Science vol. 3027,
Springer-Verlag (2004) pp.56–73
BIBLIOGRAPHY 73
[34] Certivox: Miracl crypto sdk. http://certivox.com/index.php/solutions/miracl-
crypto-sdk/
[35] Blake, I.F., Seroussi, G., Smart, N.P.: Advances in Elliptic Curve Cryptography.
Volume 2. Cambridge University Express (2005)
[36] Miyaji, A., Nakabayashi, M., Takano, S.: New explicit conditions of elliptic curve
traces for fr-reduction. In: IEICE transactions on Fundamentals. Volume E84-A(5).
(2001) pp.1234–1243
[37] Barreto, P.S.L.M., Naehrig, M.: Pairing-friendly elliptic curves of prime order. In:
Selected Areas in Cryptography - SAC 2005, Lecture Notes in Computer Science vol.
3897, Springer-Verlag (2005) pp.319–331
[38] Kachisa, E.J., Schaefer, E.F., Scott, M.: Constructing brezing-weng pairing-friendly
elliptic curves using elements in the cyclotomic field. In: Pairing-Based Cryptography
- Pairing 2008, Lecture Notes in Computer Science vol. 5209, Springer-Verlag (2008)
pp.126–135
[39] Barreto, P.S.L.M., Lynn, B., Scott, M.: Constructing elliptic curves with prescribed
embedding degrees. In: Security in Communication Networks, Third International
Conference - SCN 2002, Lecture Notes in Computer Science vol. 2576, Springer-Verlag
(2002) pp.257–267
Appendix A
Experiment Results
A.1 Experiment result of Type-1 pairing based P-signatures
Figure A.1: Type-1 pairings - case R = REQ
74
A.1. EXPERIMENT RESULT OF TYPE-1 PAIRING BASED P-SIGNATURES 75
Figure A.2: Type-1 pairings - case R = REQ
Figure A.3: Type-1 pairings - case R = RIP
Figure A.4: Type-1 pairings - case R = RIP
76 APPENDIX A. EXPERIMENT RESULTS
A.2 Experiment result of Type-3 pairing based P-signatures
Figure A.5: Type-3 pairings - case R = REQ
Figure A.6: Type-3 pairings - case R = REQ
A.2. EXPERIMENT RESULT OF TYPE-3 PAIRING BASED P-SIGNATURES 77
Figure A.7: Type-3 pairings - case R = RIP
Figure A.8: Type-3 pairings - case R = RIP
78 APPENDIX A. EXPERIMENT RESULTS
A.3 Experiment result of Optimized P-signatures
Figure A.9: Optimized Type-3 pairings - case R = REQ
Figure A.10: Optimized Type-3 pairings - case R = REQ
A.3. EXPERIMENT RESULT OF OPTIMIZED P-SIGNATURES 79
Figure A.11: Optimized Type-3 pairings - case R = RIP
Figure A.12: Optimized Type-3 pairings - case R = RIP
80 APPENDIX A. EXPERIMENT RESULTS
A.4 Experiment result of P-signatures on different curves
Figure A.13: CP-80 - case R = REQ
Figure A.14: MNT-80 - case R = REQ
A.4. EXPERIMENT RESULT OF P-SIGNATURES ON DIFFERENT CURVES 81
Figure A.15: BN-128 - case R = REQ
Figure A.16: KSS-192 - case R = REQ
Figure A.17: BLS-256 - case R = REQ
